<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_lsprof.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"frameobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structseq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rotatingtree.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "This module requires long longs!"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*** Selection of a high-precision timer ***/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>PY_LONG_LONG</name></type>
<name>hpTimer</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>li</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>QueryPerformanceCounter</name><argument_list>(<argument><expr>&amp;<name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>li</name>.<name>QuadPart</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>hpTimerUnit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>li</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>QueryPerformanceFrequency</name><argument_list>(<argument><expr>&amp;<name>li</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>1.0 / <name><name>li</name>.<name>QuadPart</name></name></expr>;</return></then>
	<else>else
		<return>return <expr>0.000001</expr>;</return></else></if>  <comment type="block">/* unlikely */</comment>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* !MS_WINDOWS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_GETTIMEOFDAY</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive> "This module requires gettimeofday() on non-Windows platforms!"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call>)</expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/times.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PY_LONG_LONG</name></type>
<name>hpTimer</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>ret</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GETTIMEOFDAY_NO_TZ</name></cpp:ifdef>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>tv</name></expr></argument>, <argument><expr>(struct <name>timezone</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>ret</name> = <name><name>tv</name>.<name>tv_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <name>ret</name> * 1000000 + <name><name>tv</name>.<name>tv_usec</name></name></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>hpTimerUnit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr>0.000001</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* MS_WINDOWS */</comment>

<comment type="block">/************************************************************/</comment>
<comment type="block">/* Written by Brett Rosen and Ted Czotter */</comment>

<struct_decl>struct <name>_ProfilerEntry</name>;</struct_decl>

<comment type="block">/* represents a function called from another function */</comment>
<typedef>typedef <type><struct>struct <name>_ProfilerSubEntry</name> <block>{
	<decl_stmt><decl><type><name>rotating_node_t</name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>callcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>recursivecallcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>recursionLevel</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerSubEntry</name>;</typedef>

<comment type="block">/* represents a function or user defined block */</comment>
<typedef>typedef <type><struct>struct <name>_ProfilerEntry</name> <block>{
	<decl_stmt><decl><type><name>rotating_node_t</name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>userObj</name></decl>;</decl_stmt> <comment type="block">/* PyCodeObject, or a descriptive str for builtins */</comment>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>tt</name></decl>;</decl_stmt> <comment type="block">/* total time in this entry */</comment>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>it</name></decl>;</decl_stmt> <comment type="block">/* inline time in this entry (not in subcalls) */</comment>
	<decl_stmt><decl><type><name>long</name></type> <name>callcount</name></decl>;</decl_stmt> <comment type="block">/* how many times this was called */</comment>
	<decl_stmt><decl><type><name>long</name></type> <name>recursivecallcount</name></decl>;</decl_stmt> <comment type="block">/* how many times called recursively */</comment>
	<decl_stmt><decl><type><name>long</name></type> <name>recursionLevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>rotating_node_t</name> *</type><name>calls</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_ProfilerContext</name> <block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>t0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>subt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>_ProfilerContext</name> *</type><name>previous</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>ctxEntry</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerContext</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>rotating_node_t</name> *</type><name>profilerEntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>currentProfilerContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>freelistProfilerContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>externalTimer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>externalTimerUnit</name></decl>;</decl_stmt>
}</block></struct></type> <name>ProfilerObject</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POF_ENABLED</name></cpp:macro>     <cpp:value>0x001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POF_SUBCALLS</name></cpp:macro>    <cpp:value>0x002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POF_BUILTINS</name></cpp:macro>    <cpp:value>0x004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POF_NOMEMORY</name></cpp:macro>    <cpp:value>0x100</cpp:value></cpp:define>

<decl_stmt><decl><type><name>staticforward</name> <name>PyTypeObject</name></type> <name>PyProfiler_Type</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyProfiler_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_TypeCheck(op, &amp;PyProfiler_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyProfiler_CheckExact</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PyProfiler_Type)</cpp:value></cpp:define>

<comment type="block">/*** External Timers ***/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLE_TIMER_PRECISION</name></cpp:macro>   <cpp:value>4294967296.0</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>empty_tuple</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PY_LONG_LONG</name></type> <name>CallExternalTimer</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name> <init>= <expr><call><name>PyObject_Call</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr></argument>, <argument><expr><name>empty_tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>pObj</name>-&gt;<name>externalTimerUnit</name></name> &gt; 0.0</expr>)</condition><then> <block>{
		<comment type="block">/* interpret the result as an integer that will be scaled
		   in profiler_getstats() */</comment>
		<expr_stmt><expr><name>result</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* interpret the result as a double measured in seconds.
		   As the profiler works with PY_LONG_LONG internally
		   we convert it to a large integer */</comment>
		<decl_stmt><decl><type><name>double</name></type> <name>val</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* error handling delayed to the code below */</comment>
		<expr_stmt><expr><name>result</name> = <call>(<name>PY_LONG_LONG</name>) <argument_list>(<argument><expr><name>val</name> * <name>DOUBLE_TIMER_PRECISION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_TIMER</name><parameter_list>(<param><type><name>pObj</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((pObj)-&gt;externalTimer ?		\
					CallExternalTimer(pObj) :	\
					hpTimer())</cpp:value></cpp:define>

<comment type="block">/*** ProfilerObject ***/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>normalizeUserObj</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyCFunctionObject</name> *</type><name>fn</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>obj</name></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Replace built-in function objects with a descriptive string
	   because of built-in methods -- keeping a reference to
	   __self__ is probably not a good idea. */</comment>
	<expr_stmt><expr><name>fn</name> = (<name>PyCFunctionObject</name> *)<name>obj</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>fn</name>-&gt;<name>m_self</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* built-in function: look up the module name */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name> <init>= <expr><name><name>fn</name>-&gt;<name>m_module</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>modname</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>mod</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>modname</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else <if>if <condition>(<expr><name>mod</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>modname</name> = <call><name>PyModule_GetName</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>modname</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>modname</name> = "__builtin__"</expr>;</expr_stmt>
			}</block></then></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>modname</name> = "__builtin__"</expr>;</expr_stmt>
		}</block></else></if></else></if>
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
			<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s.%s&gt;"</expr></argument>,
						   <argument><expr><name>modname</name></expr></argument>,
						   <argument><expr><name><name>fn</name>-&gt;<name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s&gt;"</expr></argument>,
						   <argument><expr><name><name>fn</name>-&gt;<name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* built-in method: try to return
			repr(getattr(type(__self__), __name__))
		*/</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name> <init>= <expr><name><name>fn</name>-&gt;<name>m_self</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>fn</name>-&gt;<name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>name</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>mo</name> <init>= <expr><call><name>_PyType_Lookup</name><argument_list>(<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>mo</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>res</name> != <name>NULL</name></expr>)</condition><then>
					<return>return <expr><name>res</name></expr>;</return></then></if>
			}</block></then></if>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;built-in method %s&gt;"</expr></argument>,
					   <argument><expr><name><name>fn</name>-&gt;<name>m_ml</name>-&gt;<name>ml_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>ProfilerEntry</name>*</type>
<name>newProfilerEntry</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>userObj</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>self</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>self</name> = (<name>ProfilerEntry</name>*) <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>userObj</name> = <call><name>normalizeUserObj</name><argument_list>(<argument><expr><name>userObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>userObj</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>header</name>.<name>key</name></name> = <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>userObj</name></name> = <name>userObj</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>tt</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>it</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>callcount</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>recursivecallcount</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>recursionLevel</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>calls</name></name> = <name>EMPTY_ROTATING_TREE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RotatingTree_Add</name><argument_list>(<argument><expr>&amp;<name><name>pObj</name>-&gt;<name>profilerEntries</name></name></expr></argument>, <argument><expr>&amp;<name><name>self</name>-&gt;<name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ProfilerEntry</name>*</type>
<name>getEntry</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(<name>ProfilerEntry</name>*) <call><name>RotatingTree_Get</name><argument_list>(<argument><expr>&amp;<name><name>pObj</name>-&gt;<name>profilerEntries</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ProfilerSubEntry</name> *</type> 
<name>getSubEntry</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>ProfilerEntry</name> *</type><name>caller</name></decl></param>, <param><decl><type><name>ProfilerEntry</name>*</type> <name>entry</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(<name>ProfilerSubEntry</name>*) <call><name>RotatingTree_Get</name><argument_list>(<argument><expr>&amp;<name><name>caller</name>-&gt;<name>calls</name></name></expr></argument>,
						    <argument><expr>(<name>void</name> *)<name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ProfilerSubEntry</name> *</type>
<name>newSubEntry</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>,  <param><decl><type><name>ProfilerEntry</name> *</type><name>caller</name></decl></param>, <param><decl><type><name>ProfilerEntry</name>*</type> <name>entry</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>self</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>self</name> = (<name>ProfilerSubEntry</name>*) <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerSubEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>header</name>.<name>key</name></name> = (<name>void</name> *)<name>entry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>tt</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>it</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>callcount</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>recursivecallcount</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>recursionLevel</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RotatingTree_Add</name><argument_list>(<argument><expr>&amp;<name><name>caller</name>-&gt;<name>calls</name></name></expr></argument>, <argument><expr>&amp;<name><name>self</name>-&gt;<name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>self</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>freeSubEntry</name><parameter_list>(<param><decl><type><name>rotating_node_t</name> *</type><name>header</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>subentry</name> <init>= <expr>(<name>ProfilerSubEntry</name>*) <name>header</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>subentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>freeEntry</name><parameter_list>(<param><decl><type><name>rotating_node_t</name> *</type><name>header</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>entry</name> <init>= <expr>(<name>ProfilerEntry</name>*) <name>header</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RotatingTree_Enum</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>calls</name></name></expr></argument>, <argument><expr><name>freeSubEntry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>userObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clearEntries</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>RotatingTree_Enum</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>profilerEntries</name></name></expr></argument>, <argument><expr><name>freeEntry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pObj</name>-&gt;<name>profilerEntries</name></name> = <name>EMPTY_ROTATING_TREE</name></expr>;</expr_stmt>
	<comment type="block">/* release the memory hold by the free list of ProfilerContexts */</comment>
	<while>while <condition>(<expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>c</name> <init>= <expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name> = <name><name>c</name>-&gt;<name>previous</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initContext</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>ProfilerContext</name> *</type><name>self</name></decl></param>, <param><decl><type><name>ProfilerEntry</name> *</type><name>entry</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>self</name>-&gt;<name>ctxEntry</name></name> = <name>entry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>subt</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>previous</name></name> = <name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name> = <name>self</name></expr>;</expr_stmt>
	<expr_stmt><expr>++<name><name>entry</name>-&gt;<name>recursionLevel</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name><name>pObj</name>-&gt;<name>flags</name></name> &amp; <name>POF_SUBCALLS</name>) &amp;&amp; <name><name>self</name>-&gt;<name>previous</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* find or create an entry for me in my caller's entry */</comment>
		<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>caller</name> <init>= <expr><name><name>self</name>-&gt;<name>previous</name>-&gt;<name>ctxEntry</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>subentry</name> <init>= <expr><call><name>getSubEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>subentry</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>subentry</name> = <call><name>newSubEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>subentry</name></expr>)</condition><then>
			<expr_stmt><expr>++<name><name>subentry</name>-&gt;<name>recursionLevel</name></name></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>t0</name></name> = <call><name>CALL_TIMER</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Stop</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>ProfilerContext</name> *</type><name>self</name></decl></param>, <param><decl><type><name>ProfilerEntry</name> *</type><name>entry</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>tt</name> <init>= <expr><call><name>CALL_TIMER</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>)</argument_list></call> - <name><name>self</name>-&gt;<name>t0</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>it</name> <init>= <expr><name>tt</name> - <name><name>self</name>-&gt;<name>subt</name></name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>self</name>-&gt;<name>previous</name></name></expr>)</condition><then>
		<expr_stmt><expr><name><name>self</name>-&gt;<name>previous</name>-&gt;<name>subt</name></name> += <name>tt</name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name> = <name><name>self</name>-&gt;<name>previous</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr>--<name><name>entry</name>-&gt;<name>recursionLevel</name></name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>entry</name>-&gt;<name>tt</name></name> += <name>tt</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr>++<name><name>entry</name>-&gt;<name>recursivecallcount</name></name></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><name><name>entry</name>-&gt;<name>it</name></name> += <name>it</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name>-&gt;<name>callcount</name></name>++</expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name><name>pObj</name>-&gt;<name>flags</name></name> &amp; <name>POF_SUBCALLS</name>) &amp;&amp; <name><name>self</name>-&gt;<name>previous</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* find or create an entry for me in my caller's entry */</comment>
		<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>caller</name> <init>= <expr><name><name>self</name>-&gt;<name>previous</name>-&gt;<name>ctxEntry</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>subentry</name> <init>= <expr><call><name>getSubEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>subentry</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>--<name><name>subentry</name>-&gt;<name>recursionLevel</name></name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name><name>subentry</name>-&gt;<name>tt</name></name> += <name>tt</name></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr>++<name><name>subentry</name>-&gt;<name>recursivecallcount</name></name></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><name><name>subentry</name>-&gt;<name>it</name></name> += <name>it</name></expr>;</expr_stmt>
			<expr_stmt><expr>++<name><name>subentry</name>-&gt;<name>callcount</name></name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ptrace_enter_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>userObj</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* entering a call to the function identified by 'key'
	   (which can be a PyCodeObject or a PyMethodDef pointer) */</comment>
	<decl_stmt><decl><type><name>ProfilerObject</name> *</type><name>pObj</name> <init>= <expr>(<name>ProfilerObject</name>*)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>profEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>pContext</name></decl>;</decl_stmt>

	<comment type="block">/* In the case of entering a generator expression frame via a
	 * throw (gen_send_ex(.., 1)), we may already have an
	 * Exception set here. We must not mess around with this
	 * exception, and some of the code under here assumes that
	 * PyErr_* is its own to mess around with, so we have to
	 * save and restore any current exception. */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>last_type</name></decl>, *<decl><type ref="prev"/><name>last_value</name></decl>, *<decl><type ref="prev"/><name>last_tb</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>last_type</name></expr></argument>, <argument><expr>&amp;<name>last_value</name></expr></argument>, <argument><expr>&amp;<name>last_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>profEntry</name> = <call><name>getEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>profEntry</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>profEntry</name> = <call><name>newProfilerEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>userObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>profEntry</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>restorePyerr</name>;</goto></then></if>
	}</block></then></if>
	<comment type="block">/* grab a ProfilerContext out of the free list */</comment>
	<expr_stmt><expr><name>pContext</name> = <name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pContext</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name> = <name><name>pContext</name>-&gt;<name>previous</name></name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<comment type="block">/* free list exhausted, allocate a new one */</comment>
		<expr_stmt><expr><name>pContext</name> = (<name>ProfilerContext</name>*)
			<call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pContext</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
			<goto>goto <name>restorePyerr</name>;</goto>
		}</block></then></if>
	}</block></else></if>
	<expr_stmt><expr><call><name>initContext</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>profEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>restorePyerr</name>:</label>
	<expr_stmt><expr><call><name>PyErr_Restore</name><argument_list>(<argument><expr><name>last_type</name></expr></argument>, <argument><expr><name>last_value</name></expr></argument>, <argument><expr><name>last_tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ptrace_leave_call</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* leaving a call to the function identified by 'key' */</comment>
	<decl_stmt><decl><type><name>ProfilerObject</name> *</type><name>pObj</name> <init>= <expr>(<name>ProfilerObject</name>*)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>profEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>pContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pContext</name> = <name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pContext</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>profEntry</name> = <call><name>getEntry</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>profEntry</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Stop</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>profEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name> = <name><name>pContext</name>-&gt;<name>previous</name></name></expr>;</expr_stmt>
	}</block></else></if>
	<comment type="block">/* put pContext into the free list */</comment>
	<expr_stmt><expr><name><name>pContext</name>-&gt;<name>previous</name></name> = <name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pObj</name>-&gt;<name>freelistProfilerContext</name></name> = <name>pContext</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>profiler_callback</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyFrameObject</name> *</type><name>frame</name></decl></param>, <param><decl><type><name>int</name></type> <name>what</name></decl></param>,
		  <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>what</name></expr>)</condition> <block>{

	<comment type="block">/* the 'frame' of a called function is about to start its execution */</comment>
	<case>case <expr><name>PyTrace_CALL</name></expr>:
		<expr_stmt><expr><call><name>ptrace_enter_call</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>void</name> *)<name><name>frame</name>-&gt;<name>f_code</name></name></expr></argument>,
				        <argument><expr>(<name>PyObject</name> *)<name><name>frame</name>-&gt;<name>f_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>

	<comment type="block">/* the 'frame' of a called function is about to finish
	   (either normally or with an exception) */</comment>
	</case><case>case <expr><name>PyTrace_RETURN</name></expr>:
		<expr_stmt><expr><call><name>ptrace_leave_call</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>void</name> *)<name><name>frame</name>-&gt;<name>f_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>

	<comment type="block">/* case PyTrace_EXCEPTION:
		If the exception results in the function exiting, a
		PyTrace_RETURN event will be generated, so we don't need to
		handle it. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PyTrace_C_CALL</name></cpp:ifdef>	<comment type="block">/* not defined in Python &lt;= 2.3 */</comment>
	<comment type="block">/* the Python function 'frame' is issuing a call to the built-in
	   function 'arg' */</comment>
	</case><case>case <expr><name>PyTrace_C_CALL</name></expr>:
		<if>if <condition>(<expr>(((<name>ProfilerObject</name> *)<name>self</name>)-&gt;<name>flags</name> &amp; <name>POF_BUILTINS</name>)
		    &amp;&amp; <call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>ptrace_enter_call</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
					  <argument><expr>((<name>PyCFunctionObject</name> *)<name>arg</name>)-&gt;<name>m_ml</name></expr></argument>,
					  <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<break>break;</break>

	<comment type="block">/* the call to the built-in function 'arg' is returning into its
	   caller 'frame' */</comment>
	</case><case>case <expr><name>PyTrace_C_RETURN</name></expr>:		<comment type="block">/* ...normally */</comment>
	</case><case>case <expr><name>PyTrace_C_EXCEPTION</name></expr>:	<comment type="block">/* ...with an exception set */</comment>
		<if>if <condition>(<expr>(((<name>ProfilerObject</name> *)<name>self</name>)-&gt;<name>flags</name> &amp; <name>POF_BUILTINS</name>)
		    &amp;&amp; <call><name>PyCFunction_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>ptrace_leave_call</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
					  <argument><expr>((<name>PyCFunctionObject</name> *)<name>arg</name>)-&gt;<name>m_ml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case><default>default:
		<break>break;</break>
	</default>}</block></switch>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pending_exception</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>pObj</name>-&gt;<name>flags</name></name> &amp; <name>POF_NOMEMORY</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> -= <name>POF_NOMEMORY</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
				<argument><expr>"memory was exhausted while profiling"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/************************************************************/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>profiler_entry_fields</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"code"</expr>,         <expr>"code object or built-in function name"</expr>}</block></expr>,
	<expr><block>{<expr>"callcount"</expr>,    <expr>"how many times this was called"</expr>}</block></expr>,
	<expr><block>{<expr>"reccallcount"</expr>, <expr>"how many times called recursively"</expr>}</block></expr>,
	<expr><block>{<expr>"totaltime"</expr>,    <expr>"total time in this entry"</expr>}</block></expr>,
	<expr><block>{<expr>"inlinetime"</expr>,   <expr>"inline time in this entry (not in subcalls)"</expr>}</block></expr>,
	<expr><block>{<expr>"calls"</expr>,        <expr>"details of the calls"</expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Field</name></type> <name><name>profiler_subentry_fields</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"code"</expr>,         <expr>"called code object or built-in function name"</expr>}</block></expr>,
	<expr><block>{<expr>"callcount"</expr>,    <expr>"how many times this is called"</expr>}</block></expr>,
	<expr><block>{<expr>"reccallcount"</expr>, <expr>"how many times this is called recursively"</expr>}</block></expr>,
	<expr><block>{<expr>"totaltime"</expr>,    <expr>"total time spent in this call"</expr>}</block></expr>,
	<expr><block>{<expr>"inlinetime"</expr>,   <expr>"inline time (not in further subcalls)"</expr>}</block></expr>,
	<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>profiler_entry_desc</name> <init>= <expr><block>{
	<expr>"_lsprof.profiler_entry"</expr>, <comment type="block">/* name */</comment>
	<expr><name>NULL</name></expr>, <comment type="block">/* doc */</comment>
	<expr><name>profiler_entry_fields</name></expr>,
	<expr>6</expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyStructSequence_Desc</name></type> <name>profiler_subentry_desc</name> <init>= <expr><block>{
	<expr>"_lsprof.profiler_subentry"</expr>, <comment type="block">/* name */</comment>
	<expr><name>NULL</name></expr>, <comment type="block">/* doc */</comment>
	<expr><name>profiler_subentry_fields</name></expr>,
	<expr>5</expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StatsEntryType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>StatsSubEntryType</name></decl>;</decl_stmt>


<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sublist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>factor</name></decl>;</decl_stmt>
}</block></struct></type> <name>statscollector_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>statsForSubEntry</name><parameter_list>(<param><decl><type><name>rotating_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ProfilerSubEntry</name> *</type><name>sentry</name> <init>= <expr>(<name>ProfilerSubEntry</name>*) <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>statscollector_t</name> *</type><name>collect</name> <init>= <expr>(<name>statscollector_t</name>*) <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>entry</name> <init>= <expr>(<name>ProfilerEntry</name>*) <name><name>sentry</name>-&gt;<name>header</name>.<name>key</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sinfo</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>sinfo</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsSubEntryType</name></expr></argument>,
				      <argument><expr>"((Olldd))"</expr></argument>,
				      <argument><expr><name><name>entry</name>-&gt;<name>userObj</name></name></expr></argument>,
				      <argument><expr><name><name>sentry</name>-&gt;<name>callcount</name></name></expr></argument>,
				      <argument><expr><name><name>sentry</name>-&gt;<name>recursivecallcount</name></name></expr></argument>,
				      <argument><expr><name><name>collect</name>-&gt;<name>factor</name></name> * <name><name>sentry</name>-&gt;<name>tt</name></name></expr></argument>,
				      <argument><expr><name><name>collect</name>-&gt;<name>factor</name></name> * <name><name>sentry</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sinfo</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>collect</name>-&gt;<name>sublist</name></name></expr></argument>, <argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>statsForEntry</name><parameter_list>(<param><decl><type><name>rotating_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>entry</name> <init>= <expr>(<name>ProfilerEntry</name>*) <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>statscollector_t</name> *</type><name>collect</name> <init>= <expr>(<name>statscollector_t</name>*) <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>callcount</name></name> == 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>   <comment type="block">/* skip */</comment>

	<if>if <condition>(<expr><name><name>entry</name>-&gt;<name>calls</name></name> != <name>EMPTY_ROTATING_TREE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>collect</name>-&gt;<name>sublist</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>collect</name>-&gt;<name>sublist</name></name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><call><name>RotatingTree_Enum</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>calls</name></name></expr></argument>,
				      <argument><expr><name>statsForSubEntry</name></expr></argument>, <argument><expr><name>collect</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>collect</name>-&gt;<name>sublist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collect</name>-&gt;<name>sublist</name></name> = <name>Py_None</name></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>info</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsEntryType</name></expr></argument>,
				     <argument><expr>"((OllddO))"</expr></argument>,
				     <argument><expr><name><name>entry</name>-&gt;<name>userObj</name></name></expr></argument>,
				     <argument><expr><name><name>entry</name>-&gt;<name>callcount</name></name></expr></argument>,
				     <argument><expr><name><name>entry</name>-&gt;<name>recursivecallcount</name></name></expr></argument>,
				     <argument><expr><name><name>collect</name>-&gt;<name>factor</name></name> * <name><name>entry</name>-&gt;<name>tt</name></name></expr></argument>,
				     <argument><expr><name><name>collect</name>-&gt;<name>factor</name></name> * <name><name>entry</name>-&gt;<name>it</name></name></expr></argument>,
				     <argument><expr><name><name>collect</name>-&gt;<name>sublist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>collect</name>-&gt;<name>sublist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>info</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>collect</name>-&gt;<name>list</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getstats_doc</name></expr></argument>, <argument><expr>"\
getstats() -&gt; list of profiler_entry objects\n\
\n\
Return all information collected by the profiler.\n\
Each profiler_entry is a tuple-like object with the\n\
following attributes:\n\
\n\
    code          code object\n\
    callcount     how many times this was called\n\
    reccallcount  how many times called recursively\n\
    totaltime     total time in this entry\n\
    inlinetime    inline time in this entry (not in subcalls)\n\
    calls         details of the calls\n\
\n\
The calls attribute is either None or a list of\n\
profiler_subentry objects:\n\
\n\
    code          called code object\n\
    callcount     how many times this is called\n\
    reccallcount  how many times this is called recursively\n\
    totaltime     total time spent in this call\n\
    inlinetime    inline time (not in further subcalls)\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>profiler_getstats</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>noarg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>statscollector_t</name></type> <name>collect</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>pending_exception</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>!<name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr>)</condition><then>
		<expr_stmt><expr><name><name>collect</name>.<name>factor</name></name> = <call><name>hpTimerUnit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name><name>pObj</name>-&gt;<name>externalTimerUnit</name></name> &gt; 0.0</expr>)</condition><then>
		<expr_stmt><expr><name><name>collect</name>.<name>factor</name></name> = <name><name>pObj</name>-&gt;<name>externalTimerUnit</name></name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name><name>collect</name>.<name>factor</name></name> = 1.0 / <name>DOUBLE_TIMER_PRECISION</name></expr>;</expr_stmt></else></if></else></if>
	<expr_stmt><expr><name><name>collect</name>.<name>list</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>collect</name>.<name>list</name></name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>RotatingTree_Enum</name><argument_list>(<argument><expr><name><name>pObj</name>-&gt;<name>profilerEntries</name></name></expr></argument>, <argument><expr><name>statsForEntry</name></expr></argument>, <argument><expr>&amp;<name>collect</name></expr></argument>)</argument_list></call>
	    != 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>collect</name>.<name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><name><name>collect</name>.<name>list</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setSubcalls</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>int</name></type> <name>nvalue</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>nvalue</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> &amp;= ~<name>POF_SUBCALLS</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>nvalue</name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |=  <name>POF_SUBCALLS</name></expr>;</expr_stmt></then></if></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setBuiltins</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>int</name></type> <name>nvalue</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>nvalue</name> == 0</expr>)</condition><then>
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> &amp;= ~<name>POF_BUILTINS</name></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>nvalue</name> &gt; 0</expr>)</condition><then> <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyTrace_C_CALL</name></cpp:ifndef>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"builtins=True requires Python &gt;= 2.4"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>pObj</name>-&gt;<name>flags</name></name> |=  <name>POF_BUILTINS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>enable_doc</name></expr></argument>, <argument><expr>"\
enable(subcalls=True, builtins=True)\n\
\n\
Start collecting profiling information.\n\
If 'subcalls' is True, also records for each function\n\
statistics separated according to its current caller.\n\
If 'builtins' is True, records the time spent in\n\
built-in functions separately from their caller.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>profiler_enable</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>subcalls</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>builtins</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"subcalls"</expr>, <expr>"builtins"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|ii:enable"</expr></argument>,
					 <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>subcalls</name></expr></argument>, <argument><expr>&amp;<name>builtins</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>setSubcalls</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>subcalls</name></expr></argument>)</argument_list></call> &lt; 0 || <call><name>setBuiltins</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>builtins</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>profiler_callback</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> |= <name>POF_ENABLED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_unmatched</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>)</parameter_list>
<block>{
	<while>while <condition>(<expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>ProfilerContext</name> *</type><name>pContext</name> <init>= <expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ProfilerEntry</name> *</type><name>profEntry</name><init>= <expr><name><name>pContext</name>-&gt;<name>ctxEntry</name></name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>profEntry</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Stop</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>profEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name><name>pObj</name>-&gt;<name>currentProfilerContext</name></name> = <name><name>pContext</name>-&gt;<name>previous</name></name></expr>;</expr_stmt></else></if>
		<if>if <condition>(<expr><name>pContext</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></while>

}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>disable_doc</name></expr></argument>, <argument><expr>"\
disable()\n\
\n\
Stop collecting profiling information.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>profiler_disable</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>noarg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><name><name>self</name>-&gt;<name>flags</name></name> &amp;= ~<name>POF_ENABLED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>flush_unmatched</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>pending_exception</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>clear_doc</name></expr></argument>, <argument><expr>"\
clear()\n\
\n\
Clear all profiling information collected so far.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>profiler_clear</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>noarg</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>clearEntries</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>profiler_dealloc</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>op</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>op</name>-&gt;<name>flags</name></name> &amp; <name>POF_ENABLED</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>flush_unmatched</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clearEntries</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>op</name>-&gt;<name>externalTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>profiler_init</name><parameter_list>(<param><decl><type><name>ProfilerObject</name> *</type><name>pObj</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>timer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>timeunit</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>subcalls</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PyTrace_C_CALL</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>builtins</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>int</name></type> <name>builtins</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"timer"</expr>, <expr>"timeunit"</expr>,
				       <expr>"subcalls"</expr>, <expr>"builtins"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"|Odii:Profiler"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
					 <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timeunit</name></expr></argument>,
					 <argument><expr>&amp;<name>subcalls</name></expr></argument>, <argument><expr>&amp;<name>builtins</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>setSubcalls</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>subcalls</name></expr></argument>)</argument_list></call> &lt; 0 || <call><name>setBuiltins</name><argument_list>(<argument><expr><name>pObj</name></expr></argument>, <argument><expr><name>builtins</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<expr_stmt><expr><name>o</name> = <name><name>pObj</name>-&gt;<name>externalTimer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pObj</name>-&gt;<name>externalTimer</name></name> = <name>timer</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pObj</name>-&gt;<name>externalTimerUnit</name></name> = <name>timeunit</name></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>profiler_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"getstats"</expr>,    <expr>(<name>PyCFunction</name>)<name>profiler_getstats</name></expr>,
			<expr><name>METH_NOARGS</name></expr>,			<expr><name>getstats_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"enable"</expr>,	<expr>(<name>PyCFunction</name>)<name>profiler_enable</name></expr>,
			<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,	<expr><name>enable_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"disable"</expr>,	<expr>(<name>PyCFunction</name>)<name>profiler_disable</name></expr>,
			<expr><name>METH_NOARGS</name></expr>,			<expr><name>disable_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"clear"</expr>,	<expr>(<name>PyCFunction</name>)<name>profiler_clear</name></expr>,
			<expr><name>METH_NOARGS</name></expr>,			<expr><name>clear_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>profiler_doc</name></expr></argument>, <argument><expr>"\
Profiler(custom_timer=None, time_unit=None, subcalls=True, builtins=True)\n\
\n\
    Builds a profiler object using the specified timer function.\n\
    The default timer is a fast built-in one based on real time.\n\
    For custom timer functions returning integers, time_unit can\n\
    be a float specifying a scale (i.e. how long each integer unit\n\
    is, in seconds).\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>statichere</name> <name>PyTypeObject</name></type> <name>PyProfiler_Type</name> <init>= <expr><block>{
	<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
	0</expr>,                                      <comment type="block">/* ob_size */</comment>
	<expr>"_lsprof.Profiler"</expr>,                     <comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProfilerObject</name></expr></argument>)</argument_list></sizeof></expr>,                 <comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_itemsize */</comment>
	<expr>(<name>destructor</name>)<name>profiler_dealloc</name></expr>,           <comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_print */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_compare */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_call */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_str */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr><name>profiler_doc</name></expr>,                           <comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_iternext */</comment>
	<expr><name>profiler_methods</name></expr>,                       <comment type="block">/* tp_methods */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_members */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_base */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,                                      <comment type="block">/* tp_dictoffset */</comment>
	<expr>(<name>initproc</name>)<name>profiler_init</name></expr>,                <comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,                    <comment type="block">/* tp_alloc */</comment>
	<expr><name>PyType_GenericNew</name></expr>,                      <comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_Del</name></expr>,                           <comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>moduleMethods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_lsprof</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>module</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>module</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_lsprof"</expr></argument>, <argument><expr><name>moduleMethods</name></expr></argument>, <argument><expr>"Fast profiler"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>module</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyProfiler_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"Profiler"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>PyProfiler_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StatsEntryType</name></expr></argument>, 
					  <argument><expr>&amp;<name>profiler_entry_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyStructSequence_InitType</name><argument_list>(<argument><expr>&amp;<name>StatsSubEntryType</name></expr></argument>, 
					  <argument><expr>&amp;<name>profiler_subentry_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*) &amp;<name>StatsSubEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"profiler_entry"</expr></argument>,
			   <argument><expr>(<name>PyObject</name>*) &amp;<name>StatsEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>"profiler_subentry"</expr></argument>,
			   <argument><expr>(<name>PyObject</name>*) &amp;<name>StatsSubEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>empty_tuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>initialized</name> = 1</expr>;</expr_stmt>
}</block></function>
</unit>
