<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/zlib/deflate.h"><comment type="block">/* deflate.h -- internal compression state
 * Copyright (C) 1995-2004 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</comment>

<comment type="block">/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */</comment>

<comment type="block">/* @(#) $Id$ */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFLATE_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFLATE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zutil.h"</cpp:file></cpp:include>

<comment type="block">/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip encoding
   should be left enabled. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_GZIP</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>GZIP</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Internal compression state.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LENGTH_CODES</name></cpp:macro> <cpp:value>29</cpp:value></cpp:define>
<comment type="block">/* number of length codes, not counting the special END_BLOCK code */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITERALS</name></cpp:macro>  <cpp:value>256</cpp:value></cpp:define>
<comment type="block">/* number of literal bytes 0..255 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_CODES</name></cpp:macro> <cpp:value>(LITERALS+1+LENGTH_CODES)</cpp:value></cpp:define>
<comment type="block">/* number of Literal or Length codes, including the END_BLOCK code */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D_CODES</name></cpp:macro>   <cpp:value>30</cpp:value></cpp:define>
<comment type="block">/* number of distance codes */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_CODES</name></cpp:macro>  <cpp:value>19</cpp:value></cpp:define>
<comment type="block">/* number of codes used to transfer the bit lengths */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAP_SIZE</name></cpp:macro> <cpp:value>(2*L_CODES+1)</cpp:value></cpp:define>
<comment type="block">/* maximum heap size */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BITS</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>
<comment type="block">/* All codes must not exceed MAX_BITS bits */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_STATE</name></cpp:macro>    <cpp:value>42</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_STATE</name></cpp:macro>   <cpp:value>69</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAME_STATE</name></cpp:macro>    <cpp:value>73</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMENT_STATE</name></cpp:macro> <cpp:value>91</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HCRC_STATE</name></cpp:macro>   <cpp:value>103</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUSY_STATE</name></cpp:macro>   <cpp:value>113</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINISH_STATE</name></cpp:macro> <cpp:value>666</cpp:value></cpp:define>
<comment type="block">/* Stream status */</comment>


<comment type="block">/* Data structure describing a single value and its code string. */</comment>
<typedef>typedef <type><struct>struct <name>ct_data_s</name> <block>{
    <union>union <block>{
        <decl_stmt><decl><type><name>ush</name></type>  <name>freq</name></decl>;</decl_stmt>       <comment type="block">/* frequency count */</comment>
        <decl_stmt><decl><type><name>ush</name></type>  <name>code</name></decl>;</decl_stmt>       <comment type="block">/* bit string */</comment>
    }</block> <decl><name>fc</name></decl>;</union>
    <union>union <block>{
        <decl_stmt><decl><type><name>ush</name></type>  <name>dad</name></decl>;</decl_stmt>        <comment type="block">/* father node in Huffman tree */</comment>
        <decl_stmt><decl><type><name>ush</name></type>  <name>len</name></decl>;</decl_stmt>        <comment type="block">/* length of bit string */</comment>
    }</block> <decl><name>dl</name></decl>;</union>
}</block></struct></type> <name>FAR</name> <name>ct_data</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Freq</name></cpp:macro> <cpp:value>fc.freq</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Code</name></cpp:macro> <cpp:value>fc.code</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Dad</name></cpp:macro>  <cpp:value>dl.dad</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Len</name></cpp:macro>  <cpp:value>dl.len</cpp:value></cpp:define>

<typedef>typedef <type>struct <name>static_tree_desc_s</name></type>  <name>static_tree_desc</name>;</typedef>

<typedef>typedef <type><struct>struct <name>tree_desc_s</name> <block>{
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>dyn_tree</name></decl>;</decl_stmt>           <comment type="block">/* the dynamic tree */</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>max_code</name></decl>;</decl_stmt>            <comment type="block">/* largest code with non zero frequency */</comment>
    <decl_stmt><decl><type><name>static_tree_desc</name> *</type><name>stat_desc</name></decl>;</decl_stmt> <comment type="block">/* the corresponding static tree */</comment>
}</block></struct></type> <name>FAR</name> <name>tree_desc</name>;</typedef>

<typedef>typedef <type><name>ush</name></type> <name>Pos</name>;</typedef>
<typedef>typedef <type><name>Pos</name> <name>FAR</name></type> <name>Posf</name>;</typedef>
<typedef>typedef <type><name>unsigned</name></type> <name>IPos</name>;</typedef>

<comment type="block">/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */</comment>

<typedef>typedef <type><struct>struct <name>internal_state</name> <block>{
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>      <comment type="block">/* pointer back to this zlib stream */</comment>
    <decl_stmt><decl><type><name>int</name></type>   <name>status</name></decl>;</decl_stmt>        <comment type="block">/* as the name implies */</comment>
    <decl_stmt><decl><type><name>Bytef</name> *</type><name>pending_buf</name></decl>;</decl_stmt>  <comment type="block">/* output still pending */</comment>
    <decl_stmt><decl><type><name>ulg</name></type>   <name>pending_buf_size</name></decl>;</decl_stmt> <comment type="block">/* size of pending_buf */</comment>
    <decl_stmt><decl><type><name>Bytef</name> *</type><name>pending_out</name></decl>;</decl_stmt>  <comment type="block">/* next pending byte to output to the stream */</comment>
    <decl_stmt><decl><type><name>uInt</name></type>   <name>pending</name></decl>;</decl_stmt>      <comment type="block">/* nb of bytes in the pending buffer */</comment>
    <decl_stmt><decl><type><name>int</name></type>   <name>wrap</name></decl>;</decl_stmt>          <comment type="block">/* bit 0 true for zlib, bit 1 true for gzip */</comment>
    <decl_stmt><decl><type><name>gz_headerp</name></type>  <name>gzhead</name></decl>;</decl_stmt>  <comment type="block">/* gzip header information to write */</comment>
    <decl_stmt><decl><type><name>uInt</name></type>   <name>gzindex</name></decl>;</decl_stmt>      <comment type="block">/* where in extra, name, or comment */</comment>
    <decl_stmt><decl><type><name>Byte</name></type>  <name>method</name></decl>;</decl_stmt>        <comment type="block">/* STORED (for zip only) or DEFLATED */</comment>
    <decl_stmt><decl><type><name>int</name></type>   <name>last_flush</name></decl>;</decl_stmt>    <comment type="block">/* value of flush param for previous deflate call */</comment>

                <comment type="block">/* used by deflate.c: */</comment>

    <decl_stmt><decl><type><name>uInt</name></type>  <name>w_size</name></decl>;</decl_stmt>        <comment type="block">/* LZ77 window size (32K by default) */</comment>
    <decl_stmt><decl><type><name>uInt</name></type>  <name>w_bits</name></decl>;</decl_stmt>        <comment type="block">/* log2(w_size)  (8..16) */</comment>
    <decl_stmt><decl><type><name>uInt</name></type>  <name>w_mask</name></decl>;</decl_stmt>        <comment type="block">/* w_size - 1 */</comment>

    <decl_stmt><decl><type><name>Bytef</name> *</type><name>window</name></decl>;</decl_stmt>
    <comment type="block">/* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */</comment>

    <decl_stmt><decl><type><name>ulg</name></type> <name>window_size</name></decl>;</decl_stmt>
    <comment type="block">/* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */</comment>

    <decl_stmt><decl><type><name>Posf</name> *</type><name>prev</name></decl>;</decl_stmt>
    <comment type="block">/* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */</comment>

    <decl_stmt><decl><type><name>Posf</name> *</type><name>head</name></decl>;</decl_stmt> <comment type="block">/* Heads of the hash chains or NIL. */</comment>

    <decl_stmt><decl><type><name>uInt</name></type>  <name>ins_h</name></decl>;</decl_stmt>          <comment type="block">/* hash index of string to be inserted */</comment>
    <decl_stmt><decl><type><name>uInt</name></type>  <name>hash_size</name></decl>;</decl_stmt>      <comment type="block">/* number of elements in hash table */</comment>
    <decl_stmt><decl><type><name>uInt</name></type>  <name>hash_bits</name></decl>;</decl_stmt>      <comment type="block">/* log2(hash_size) */</comment>
    <decl_stmt><decl><type><name>uInt</name></type>  <name>hash_mask</name></decl>;</decl_stmt>      <comment type="block">/* hash_size-1 */</comment>

    <decl_stmt><decl><type><name>uInt</name></type>  <name>hash_shift</name></decl>;</decl_stmt>
    <comment type="block">/* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH &gt;= hash_bits
     */</comment>

    <decl_stmt><decl><type><name>long</name></type> <name>block_start</name></decl>;</decl_stmt>
    <comment type="block">/* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */</comment>

    <decl_stmt><decl><type><name>uInt</name></type> <name>match_length</name></decl>;</decl_stmt>           <comment type="block">/* length of best match */</comment>
    <decl_stmt><decl><type><name>IPos</name></type> <name>prev_match</name></decl>;</decl_stmt>             <comment type="block">/* previous match */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>match_available</name></decl>;</decl_stmt>         <comment type="block">/* set if previous match exists */</comment>
    <decl_stmt><decl><type><name>uInt</name></type> <name>strstart</name></decl>;</decl_stmt>               <comment type="block">/* start of string to insert */</comment>
    <decl_stmt><decl><type><name>uInt</name></type> <name>match_start</name></decl>;</decl_stmt>            <comment type="block">/* start of matching string */</comment>
    <decl_stmt><decl><type><name>uInt</name></type> <name>lookahead</name></decl>;</decl_stmt>              <comment type="block">/* number of valid bytes ahead in window */</comment>

    <decl_stmt><decl><type><name>uInt</name></type> <name>prev_length</name></decl>;</decl_stmt>
    <comment type="block">/* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */</comment>

    <decl_stmt><decl><type><name>uInt</name></type> <name>max_chain_length</name></decl>;</decl_stmt>
    <comment type="block">/* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */</comment>

    <decl_stmt><decl><type><name>uInt</name></type> <name>max_lazy_match</name></decl>;</decl_stmt>
    <comment type="block">/* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels &gt;= 4.
     */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>max_insert_length</name></cpp:macro>  <cpp:value>max_lazy_match</cpp:value></cpp:define>
    <comment type="block">/* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels &lt;= 3.
     */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>    <comment type="block">/* compression level (1..9) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt> <comment type="block">/* favor or force Huffman coding*/</comment>

    <decl_stmt><decl><type><name>uInt</name></type> <name>good_match</name></decl>;</decl_stmt>
    <comment type="block">/* Use a faster search when the previous match is longer than this */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>nice_match</name></decl>;</decl_stmt> <comment type="block">/* Stop searching when current match exceeds this */</comment>

                <comment type="block">/* used by trees.c: */</comment>
    <comment type="block">/* Didn't use ct_data typedef below to supress compiler warning */</comment>
    <decl_stmt><decl><type>struct <name>ct_data_s</name></type> <name><name>dyn_ltree</name><index>[<expr><name>HEAP_SIZE</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* literal and length tree */</comment>
    <decl_stmt><decl><type>struct <name>ct_data_s</name></type> <name><name>dyn_dtree</name><index>[<expr>2*<name>D_CODES</name>+1</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* distance tree */</comment>
    <decl_stmt><decl><type>struct <name>ct_data_s</name></type> <name><name>bl_tree</name><index>[<expr>2*<name>BL_CODES</name>+1</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Huffman tree for bit lengths */</comment>

    <decl_stmt><decl><type>struct <name>tree_desc_s</name></type> <name>l_desc</name></decl>;</decl_stmt>               <comment type="block">/* desc. for literal tree */</comment>
    <decl_stmt><decl><type>struct <name>tree_desc_s</name></type> <name>d_desc</name></decl>;</decl_stmt>               <comment type="block">/* desc. for distance tree */</comment>
    <decl_stmt><decl><type>struct <name>tree_desc_s</name></type> <name>bl_desc</name></decl>;</decl_stmt>              <comment type="block">/* desc. for bit length tree */</comment>

    <decl_stmt><decl><type><name>ush</name></type> <name><name>bl_count</name><index>[<expr><name>MAX_BITS</name>+1</expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* number of codes at each bit length for an optimal tree */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name><name>heap</name><index>[<expr>2*<name>L_CODES</name>+1</expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* heap used to build the Huffman trees */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>heap_len</name></decl>;</decl_stmt>               <comment type="block">/* number of elements in the heap */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>heap_max</name></decl>;</decl_stmt>               <comment type="block">/* element of largest frequency */</comment>
    <comment type="block">/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */</comment>

    <decl_stmt><decl><type><name>uch</name></type> <name><name>depth</name><index>[<expr>2*<name>L_CODES</name>+1</expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* Depth of each subtree used as tie breaker for trees of equal frequency
     */</comment>

    <decl_stmt><decl><type><name>uchf</name> *</type><name>l_buf</name></decl>;</decl_stmt>          <comment type="block">/* buffer for literals or lengths */</comment>

    <decl_stmt><decl><type><name>uInt</name></type>  <name>lit_bufsize</name></decl>;</decl_stmt>
    <comment type="block">/* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */</comment>

    <decl_stmt><decl><type><name>uInt</name></type> <name>last_lit</name></decl>;</decl_stmt>      <comment type="block">/* running index in l_buf */</comment>

    <decl_stmt><decl><type><name>ushf</name> *</type><name>d_buf</name></decl>;</decl_stmt>
    <comment type="block">/* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */</comment>

    <decl_stmt><decl><type><name>ulg</name></type> <name>opt_len</name></decl>;</decl_stmt>        <comment type="block">/* bit length of current block with optimal trees */</comment>
    <decl_stmt><decl><type><name>ulg</name></type> <name>static_len</name></decl>;</decl_stmt>     <comment type="block">/* bit length of current block with static trees */</comment>
    <decl_stmt><decl><type><name>uInt</name></type> <name>matches</name></decl>;</decl_stmt>       <comment type="block">/* number of string matches in current block */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>last_eob_len</name></decl>;</decl_stmt>   <comment type="block">/* bit length of EOB code for last block */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ulg</name></type> <name>compressed_len</name></decl>;</decl_stmt> <comment type="block">/* total bit length of compressed file mod 2^32 */</comment>
    <decl_stmt><decl><type><name>ulg</name></type> <name>bits_sent</name></decl>;</decl_stmt>      <comment type="block">/* bit length of compressed data sent mod 2^32 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>ush</name></type> <name>bi_buf</name></decl>;</decl_stmt>
    <comment type="block">/* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bi_valid</name></decl>;</decl_stmt>
    <comment type="block">/* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */</comment>

}</block></struct></type> <name>FAR</name> <name>deflate_state</name>;</typedef>

<comment type="block">/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>put_byte</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{s-&gt;pending_buf[s-&gt;pending++] = (c);}</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_LOOKAHEAD</name></cpp:macro> <cpp:value>(MAX_MATCH+MIN_MATCH+1)</cpp:value></cpp:define>
<comment type="block">/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DIST</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((s)-&gt;w_size-MIN_LOOKAHEAD)</cpp:value></cpp:define>
<comment type="block">/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */</comment>

        <comment type="block">/* in trees.c */</comment>
<decl_stmt><decl><type><name>void</name> <name>_tr_init</name></type>         <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name>  <name>_tr_tally</name></type>        <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>unsigned</name> <name>dist</name>, <name>unsigned</name> <name>lc</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <name>_tr_flush_block</name></type>  <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>charf</name> *<name>buf</name>, <name>ulg</name> <name>stored_len</name>,
                          <name>int</name> <name>eof</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <name>_tr_align</name></type>        <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <name>_tr_stored_block</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>charf</name> *<name>buf</name>, <name>ulg</name> <name>stored_len</name>,
                          <name>int</name> <name>eof</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>d_code</name><parameter_list>(<param><type><name>dist</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>((dist) &lt; 256 ? _dist_code[dist] : _dist_code[256+((dist)&gt;&gt;7)])</cpp:value></cpp:define>
<comment type="block">/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG</name></cpp:ifndef>
<comment type="block">/* Inline versions of _tr_tally for speed: */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>uch</name></type> <name><name>_length_code</name><index>[]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>uch</name></type> <name><name>_dist_code</name><index>[]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>uch</name></type> <name><name>_length_code</name><index>[]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>uch</name></type> <name><name>_dist_code</name><index>[]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_tr_tally_lit</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>, <param><type><name>flush</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>{ uch cc = (c); \
    s-&gt;d_buf[s-&gt;last_lit] = 0; \
    s-&gt;l_buf[s-&gt;last_lit++] = cc; \
    s-&gt;dyn_ltree[cc].Freq++; \
    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \
   }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_tr_tally_dist</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>distance</name></type></param>, <param><type><name>length</name></type></param>, <param><type><name>flush</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>{ uch len = (length); \
    ush dist = (distance); \
    s-&gt;d_buf[s-&gt;last_lit] = dist; \
    s-&gt;l_buf[s-&gt;last_lit++] = len; \
    dist--; \
    s-&gt;dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s-&gt;dyn_dtree[d_code(dist)].Freq++; \
    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \
  }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_tr_tally_lit</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>, <param><type><name>flush</name></type></param>)</parameter_list></cpp:macro> <cpp:value>flush = _tr_tally(s, 0, c)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_tr_tally_dist</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>distance</name></type></param>, <param><type><name>length</name></type></param>, <param><type><name>flush</name></type></param>)</parameter_list></cpp:macro> \
              <cpp:value>flush = _tr_tally(s, distance, length)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEFLATE_H */</comment>
</unit>
