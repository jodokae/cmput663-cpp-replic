<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/zlib/deflate.c"><comment type="block">/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</comment>

<comment type="block">/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin &amp; Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&amp;G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in http://www.ietf.org/rfc/rfc1951.txt
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */</comment>

<comment type="block">/* @(#) $Id$ */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deflate.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>deflate_copyright</name><index>[]</index></name> <init>=
   <expr>" deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly "</expr></init></decl>;</decl_stmt>
<comment type="block">/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */</comment>

<comment type="block">/* ===========================================================================
 *  Function prototypes.
 */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>need_more</name></decl>,      <comment type="block">/* block not completed, need more input or more output */</comment>
    <decl><name>block_done</name></decl>,     <comment type="block">/* block flush performed */</comment>
    <decl><name>finish_started</name></decl>, <comment type="block">/* finish started, need only more output at next deflate */</comment>
    <decl><name>finish_done</name></decl>     <comment type="block">/* finish done, accept no more input or output */</comment>
}</block></enum></type> <name>block_state</name>;</typedef>

<typedef>typedef <macro><name>block_state</name> <argument_list>(<argument>*compress_func</argument>)</argument_list></macro> <expr_stmt><expr><call><name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<comment type="block">/* Compression function. Returns the block state after the call. */</comment>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>fill_window</name></type>    <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_stored</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_fast</name></type>   <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_slow</name></type>   <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>lm_init</name></type>        <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>putShortMSB</name></type>    <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>uInt</name> <name>b</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>flush_pending</name></type>  <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>read_buf</name></type>        <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>Bytef</name> *<name>buf</name>, <name>unsigned</name> <name>size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ASMV</name></cpp:ifdef>
      <decl_stmt><decl><type><name>void</name> <name>match_init</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt> <comment type="block">/* asm code initialization */</comment>
      <decl_stmt><decl><type><name>uInt</name> <name>longest_match</name></type>  <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>IPos</name> <name>cur_match</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>local</name> <name>uInt</name> <name>longest_match</name></type>  <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>IPos</name> <name>cur_match</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>local</name> <name>uInt</name> <name>longest_match_fast</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>IPos</name> <name>cur_match</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>local</name>  <name>void</name> <name>check_match</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>IPos</name> <name>start</name>, <name>IPos</name> <name>match</name>,
                            <name>int</name> <name>length</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Local data
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NIL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/* Tail of hash chains */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TOO_FAR</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>TOO_FAR</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_LOOKAHEAD</name></cpp:macro> <cpp:value>(MAX_MATCH+MIN_MATCH+1)</cpp:value></cpp:define>
<comment type="block">/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */</comment>

<comment type="block">/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */</comment>
<typedef>typedef <type><struct>struct <name>config_s</name> <block>{
   <decl_stmt><decl><type><name>ush</name></type> <name>good_length</name></decl>;</decl_stmt> <comment type="block">/* reduce lazy search above this match length */</comment>
   <decl_stmt><decl><type><name>ush</name></type> <name>max_lazy</name></decl>;</decl_stmt>    <comment type="block">/* do not perform lazy search above this match length */</comment>
   <decl_stmt><decl><type><name>ush</name></type> <name>nice_length</name></decl>;</decl_stmt> <comment type="block">/* quit search above this match length */</comment>
   <decl_stmt><decl><type><name>ush</name></type> <name>max_chain</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>compress_func</name></type> <name>func</name></decl>;</decl_stmt>
}</block></struct></type> <name>config</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>config</name></type> <name><name>configuration_table</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*      good lazy nice chain */</comment>
<comment type="block">/* 0 */</comment> <expr><block>{<expr>0</expr>,    <expr>0</expr>,  <expr>0</expr>,    <expr>0</expr>, <expr><name>deflate_stored</name></expr>}</block></expr>,  <comment type="block">/* store only */</comment>
<comment type="block">/* 1 */</comment> <expr><block>{<expr>4</expr>,    <expr>4</expr>,  <expr>8</expr>,    <expr>4</expr>, <expr><name>deflate_fast</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* max speed, no lazy matches */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>config</name></type> <name><name>configuration_table</name><index>[<expr>10</expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*      good lazy nice chain */</comment>
<comment type="block">/* 0 */</comment> <expr><block>{<expr>0</expr>,    <expr>0</expr>,  <expr>0</expr>,    <expr>0</expr>, <expr><name>deflate_stored</name></expr>}</block></expr>,  <comment type="block">/* store only */</comment>
<comment type="block">/* 1 */</comment> <expr><block>{<expr>4</expr>,    <expr>4</expr>,  <expr>8</expr>,    <expr>4</expr>, <expr><name>deflate_fast</name></expr>}</block></expr>, <comment type="block">/* max speed, no lazy matches */</comment>
<comment type="block">/* 2 */</comment> <expr><block>{<expr>4</expr>,    <expr>5</expr>, <expr>16</expr>,    <expr>8</expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,
<comment type="block">/* 3 */</comment> <expr><block>{<expr>4</expr>,    <expr>6</expr>, <expr>32</expr>,   <expr>32</expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,

<comment type="block">/* 4 */</comment> <expr><block>{<expr>4</expr>,    <expr>4</expr>, <expr>16</expr>,   <expr>16</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,  <comment type="block">/* lazy matches */</comment>
<comment type="block">/* 5 */</comment> <expr><block>{<expr>8</expr>,   <expr>16</expr>, <expr>32</expr>,   <expr>32</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<comment type="block">/* 6 */</comment> <expr><block>{<expr>8</expr>,   <expr>16</expr>, <expr>128</expr>, <expr>128</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<comment type="block">/* 7 */</comment> <expr><block>{<expr>8</expr>,   <expr>32</expr>, <expr>128</expr>, <expr>256</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<comment type="block">/* 8 */</comment> <expr><block>{<expr>32</expr>, <expr>128</expr>, <expr>258</expr>, <expr>1024</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,
<comment type="block">/* 9 */</comment> <expr><block>{<expr>32</expr>, <expr>258</expr>, <expr>258</expr>, <expr>4096</expr>, <expr><name>deflate_slow</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* max compression */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4
 * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different
 * meaning.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EQUAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/* result of memcmp for equal strings */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUMMY_DECL</name></cpp:ifndef>
<struct>struct <name>static_tree_desc_s</name> <block>{<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>}</block>;</struct> <comment type="block">/* for buggy compilers */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_HASH</name><parameter_list>(<param><type><name>s</name></type></param>,<param><type><name>h</name></type></param>,<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)</cpp:value></cpp:define>


<comment type="block">/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_STRING</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>str</name></type></param>, <param><type><name>match_head</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>(UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \
    match_head = s-&gt;head[s-&gt;ins_h], \
    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_STRING</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>str</name></type></param>, <param><type><name>match_head</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>(UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \
    match_head = s-&gt;prev[(str) &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h], \
    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_HASH</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>s-&gt;head[s-&gt;hash_size-1] = NIL; \
    zmemzero((Bytef *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));</cpp:value></cpp:define>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateInit_</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>level</name></type></decl></param>, <param><decl><type><name>version</name></type></decl></param>, <param><decl><type><name>stream_size</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{
    <return>return <expr><call><name>deflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr><name>MAX_WBITS</name></expr></argument>, <argument><expr><name>DEF_MEM_LEVEL</name></expr></argument>,
                         <argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>
    <comment type="block">/* To do: ignore strm-&gt;next_in if we use it as window */</comment>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateInit2_</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>level</name></type></decl></param>, <param><decl><type><name>method</name></type></decl></param>, <param><decl><type><name>windowBits</name></type></decl></param>, <param><decl><type><name>memLevel</name></type></decl></param>, <param><decl><type><name>strategy</name></type></decl></param>,
                  <param><decl><type><name>version</name></type></decl></param>, <param><decl><type><name>stream_size</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>method</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>windowBits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>memLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>strategy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wrap</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>my_version</name><index>[]</index></name> <init>= <expr><name>ZLIB_VERSION</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ushf</name> *</type><name>overlay</name></decl>;</decl_stmt>
    <comment type="block">/* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is &lt;= 24 bits.
     */</comment>

    <if>if <condition>(<expr><name>version</name> == <name>Z_NULL</name> || <name><name>version</name><index>[<expr>0</expr>]</index></name> != <name><name>my_version</name><index>[<expr>0</expr>]</index></name> ||
        <name>stream_size</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
        <return>return <expr><name>Z_VERSION_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>zalloc</name></name> == (<name>alloc_func</name>)0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>zalloc</name></name> = <name>zcalloc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>opaque</name></name> = (<name>voidpf</name>)0</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>zfree</name></name> == (<name>free_func</name>)0</expr>)</condition><then> <expr_stmt><expr><name><name>strm</name>-&gt;<name>zfree</name></name> = <name>zcfree</name></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
    <if>if <condition>(<expr><name>level</name> != 0</expr>)</condition><then> <expr_stmt><expr><name>level</name> = 1</expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><name>level</name> == <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><then> <expr_stmt><expr><name>level</name> = 6</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>windowBits</name> &lt; 0</expr>)</condition><then> <block>{ <comment type="block">/* suppress zlib wrapper */</comment>
        <expr_stmt><expr><name>wrap</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>windowBits</name> = -<name>windowBits</name></expr>;</expr_stmt>
    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr><name>windowBits</name> &gt; 15</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wrap</name> = 2</expr>;</expr_stmt>       <comment type="block">/* write gzip wrapper instead */</comment>
        <expr_stmt><expr><name>windowBits</name> -= 16</expr>;</expr_stmt>
    }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>memLevel</name> &lt; 1 || <name>memLevel</name> &gt; <name>MAX_MEM_LEVEL</name> || <name>method</name> != <name>Z_DEFLATED</name> ||
        <name>windowBits</name> &lt; 8 || <name>windowBits</name> &gt; 15 || <name>level</name> &lt; 0 || <name>level</name> &gt; 9 ||
        <name>strategy</name> &lt; 0 || <name>strategy</name> &gt; <name>Z_FIXED</name></expr>)</condition><then> <block>{
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>windowBits</name> == 8</expr>)</condition><then> <expr_stmt><expr><name>windowBits</name> = 9</expr>;</expr_stmt></then></if>  <comment type="block">/* until 256-byte window bug fixed */</comment>
    <expr_stmt><expr><name>s</name> = (<name>deflate_state</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>s</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name></name> = (struct <name>internal_state</name> <name>FAR</name> *)<name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>strm</name></name> = <name>strm</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>wrap</name></name> = <name>wrap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>gzhead</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>w_bits</name></name> = <name>windowBits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>w_size</name></name> = 1 &lt;&lt; <name><name>s</name>-&gt;<name>w_bits</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>w_mask</name></name> = <name><name>s</name>-&gt;<name>w_size</name></name> - 1</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>hash_bits</name></name> = <name>memLevel</name> + 7</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>hash_size</name></name> = 1 &lt;&lt; <name><name>s</name>-&gt;<name>hash_bits</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>hash_mask</name></name> = <name><name>s</name>-&gt;<name>hash_size</name></name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>hash_shift</name></name> =  ((<name><name>s</name>-&gt;<name>hash_bits</name></name>+<name>MIN_MATCH</name>-1)/<name>MIN_MATCH</name>)</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>window</name></name> = (<name>Bytef</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr>2*<sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>prev</name></name>   = (<name>Posf</name> *)  <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>head</name></name>   = (<name>Posf</name> *)  <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>hash_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>lit_bufsize</name></name> = 1 &lt;&lt; (<name>memLevel</name> + 6)</expr>;</expr_stmt> <comment type="block">/* 16K elements by default */</comment>

    <expr_stmt><expr><name>overlay</name> = (<name>ushf</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>lit_bufsize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> = (<name>uchf</name> *) <name>overlay</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>pending_buf_size</name></name> = (<name>ulg</name>)<name><name>s</name>-&gt;<name>lit_bufsize</name></name> * (<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>+2L)</expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>window</name></name> == <name>Z_NULL</name> || <name><name>s</name>-&gt;<name>prev</name></name> == <name>Z_NULL</name> || <name><name>s</name>-&gt;<name>head</name></name> == <name>Z_NULL</name> ||
        <name><name>s</name>-&gt;<name>pending_buf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>FINISH_STATE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name>*)<call><name>ERR_MSG</name><argument_list>(<argument><expr><name>Z_MEM_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deflateEnd</name> <argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>d_buf</name></name> = <name>overlay</name> + <name><name>s</name>-&gt;<name>lit_bufsize</name></name>/<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>l_buf</name></name> = <name><name>s</name>-&gt;<name>pending_buf</name></name> + (1+<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>)*<name><name>s</name>-&gt;<name>lit_bufsize</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>level</name></name> = <name>level</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>strategy</name></name> = <name>strategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>method</name></name> = (<name>Byte</name>)<name>method</name></expr>;</expr_stmt>

    <return>return <expr><call><name>deflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateSetDictionary</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>dictionary</name></type></decl></param>, <param><decl><type><name>dictLength</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> *</type><name>dictionary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type>  <name>dictLength</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type> <name>length</name> <init>= <expr><name>dictLength</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> || <name>dictionary</name> == <name>Z_NULL</name> ||
        <name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> == 2 ||
        (<name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> == 1 &amp;&amp; <name><name>strm</name>-&gt;<name>state</name>-&gt;<name>status</name></name> != <name>INIT_STATE</name>)</expr>)</condition><then>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>adler32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>length</name> &lt; <name>MIN_MATCH</name></expr>)</condition><then> <return>return <expr><name>Z_OK</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>length</name> &gt; <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>length</name> = <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dictionary</name> += <name>dictLength</name> - <name>length</name></expr>;</expr_stmt> <comment type="block">/* use the tail of the dictionary */</comment>
    }</block></then></if>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> = <name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>block_start</name></name> = (<name>long</name>)<name>length</name></expr>;</expr_stmt>

    <comment type="block">/* Insert all strings in the hash table (except for the last two bytes).
     * s-&gt;lookahead stays null, so s-&gt;ins_h will be recomputed at the next
     * call of fill_window.
     */</comment>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>ins_h</name></name> = <name><name>s</name>-&gt;<name>window</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt;= <name>length</name> - <name>MIN_MATCH</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <if>if <condition>(<expr><name>hash_head</name></expr>)</condition><then> <expr_stmt><expr><name>hash_head</name> = 0</expr>;</expr_stmt></then></if>  <comment type="block">/* to make compiler happy */</comment>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateReset</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> ||
        <name><name>strm</name>-&gt;<name>zalloc</name></name> == (<name>alloc_func</name>)0 || <name><name>strm</name>-&gt;<name>zfree</name></name> == (<name>free_func</name>)0</expr>)</condition><then> <block>{
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_in</name></name> = <name><name>strm</name>-&gt;<name>total_out</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = <name>Z_NULL</name></expr>;</expr_stmt> <comment type="block">/* use zfree if we ever allocate msg dynamically */</comment>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>data_type</name></name> = <name>Z_UNKNOWN</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>s</name> = (<name>deflate_state</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>pending</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>pending_out</name></name> = <name><name>s</name>-&gt;<name>pending_buf</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>wrap</name></name> = -<name><name>s</name>-&gt;<name>wrap</name></name></expr>;</expr_stmt> <comment type="block">/* was made negative by deflate(..., Z_FINISH); */</comment>
    }</block></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name><name>s</name>-&gt;<name>wrap</name></name> ? <name>INIT_STATE</name> : <name>BUSY_STATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> =
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
        <name><name>s</name>-&gt;<name>wrap</name></name> == 2 ? <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> :
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <call><name>adler32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = <name>Z_NO_FLUSH</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_tr_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lm_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateSetHeader</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>head</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_headerp</name></type> <name>head</name></decl>;</decl_stmt>
<block>{
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> != 2</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>gzhead</name></name> = <name>head</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflatePrime</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>bits</name></type></decl></param>, <param><decl><type><name>value</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<block>{
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>bi_valid</name></name> = <name>bits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>bi_buf</name></name> = <call>(<name>ush</name>)<argument_list>(<argument><expr><name>value</name> &amp; ((1 &lt;&lt; <name>bits</name>) - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateParams</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>level</name></type></decl></param>, <param><decl><type><name>strategy</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>compress_func</name></type> <name>func</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>Z_OK</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
    <if>if <condition>(<expr><name>level</name> != 0</expr>)</condition><then> <expr_stmt><expr><name>level</name> = 1</expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><name>level</name> == <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><then> <expr_stmt><expr><name>level</name> = 6</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>level</name> &lt; 0 || <name>level</name> &gt; 9 || <name>strategy</name> &lt; 0 || <name>strategy</name> &gt; <name>Z_FIXED</name></expr>)</condition><then> <block>{
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>func</name> = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>func</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>func</name> != <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>func</name> &amp;&amp; <name><name>strm</name>-&gt;<name>total_in</name></name> != 0</expr>)</condition><then> <block>{
        <comment type="block">/* Flush the last buffer: */</comment>
        <expr_stmt><expr><name>err</name> = <call><name>deflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_PARTIAL_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>level</name></name> != <name>level</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>level</name></name> = <name>level</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>max_lazy_match</name></name>   = <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>max_lazy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>good_match</name></name>       = <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>good_length</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>nice_match</name></name>       = <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>nice_length</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>max_chain_length</name></name> = <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name>.<name>max_chain</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>strategy</name></name> = <name>strategy</name></expr>;</expr_stmt>
    <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateTune</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>good_length</name></type></decl></param>, <param><decl><type><name>max_lazy</name></type></decl></param>, <param><decl><type><name>nice_length</name></type></decl></param>, <param><decl><type><name>max_chain</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>good_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_lazy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nice_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_chain</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>good_match</name></name> = <name>good_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>max_lazy_match</name></name> = <name>max_lazy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>nice_match</name></name> = <name>nice_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>max_chain_length</name></name> = <name>max_chain</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* =========================================================================
 * For the default windowBits of 15 and memLevel of 8, this function returns
 * a close to exact, as well as small, upper bound on the compressed size.
 * They are coded as constants here for a reason--if the #define's are
 * changed, then this function needs to be changed as well.  The return
 * value for 15 and 8 only works for those exact settings.
 *
 * For any setting other than those defaults for windowBits and memLevel,
 * the value returned is a conservative worst case for the maximum expansion
 * resulting from using fixed blocks instead of stored blocks, which deflate
 * can emit on compressed data for some combinations of the parameters.
 *
 * This function could be more sophisticated to provide closer upper bounds
 * for every combination of windowBits and memLevel, as well as wrap.
 * But even the conservative upper bound of about 14% expansion does not
 * seem onerous for output buffer allocation.
 */</comment>
<function><type><name>uLong</name> <name>ZEXPORT</name></type> <name>deflateBound</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>sourceLen</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uLong</name></type> <name>sourceLen</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uLong</name></type> <name>destLen</name></decl>;</decl_stmt>

    <comment type="block">/* conservative upper bound */</comment>
    <expr_stmt><expr><name>destLen</name> = <name>sourceLen</name> +
              ((<name>sourceLen</name> + 7) &gt;&gt; 3) + ((<name>sourceLen</name> + 63) &gt;&gt; 6) + 11</expr>;</expr_stmt>

    <comment type="block">/* if can't get parameters, return conservative bound */</comment>
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then>
        <return>return <expr><name>destLen</name></expr>;</return></then></if>

    <comment type="block">/* if not default parameters, return conservative bound */</comment>
    <expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>w_bits</name></name> != 15 || <name><name>s</name>-&gt;<name>hash_bits</name></name> != 8 + 7</expr>)</condition><then>
        <return>return <expr><name>destLen</name></expr>;</return></then></if>

    <comment type="block">/* default settings: return tight bound for that case */</comment>
    <return>return <expr><call><name>compressBound</name><argument_list>(<argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>putShortMSB</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>b</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type> <name>b</name></decl>;</decl_stmt>
<block>{
    <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name>b</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name>b</name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm-&gt;next_out buffer and copying into it.
 * (See also read_buf()).
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>flush_pending</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> <init>= <expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> &gt; <name><name>strm</name>-&gt;<name>avail_out</name></name></expr>)</condition><then> <expr_stmt><expr><name>len</name> = <name><name>strm</name>-&gt;<name>avail_out</name></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <return>return;</return></then></if>

    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>next_out</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_out</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>next_out</name></name>  += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_out</name></name>  += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_out</name></name> += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>avail_out</name></name>  -= <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending</name></name> -= <name>len</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending</name></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_out</name></name> = <name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_buf</name></name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflate</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>old_flush</name></decl>;</decl_stmt> <comment type="block">/* value of flush param for previous deflate call */</comment>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> ||
        <name>flush</name> &gt; <name>Z_FINISH</name> || <name>flush</name> &lt; 0</expr>)</condition><then> <block>{
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>s</name> = <name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>next_out</name></name> == <name>Z_NULL</name> ||
        (<name><name>strm</name>-&gt;<name>next_in</name></name> == <name>Z_NULL</name> &amp;&amp; <name><name>strm</name>-&gt;<name>avail_in</name></name> != 0) ||
        (<name><name>s</name>-&gt;<name>status</name></name> == <name>FINISH_STATE</name> &amp;&amp; <name>flush</name> != <name>Z_FINISH</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_STREAM_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>strm</name></name> = <name>strm</name></expr>;</expr_stmt> <comment type="block">/* just in case */</comment>
    <expr_stmt><expr><name>old_flush</name> = <name><name>s</name>-&gt;<name>last_flush</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = <name>flush</name></expr>;</expr_stmt>

    <comment type="block">/* Write the header */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>INIT_STATE</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> == 2</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>31</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>139</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>level</name></name> == 9 ? 2 :
                            (<name><name>s</name>-&gt;<name>strategy</name></name> &gt;= <name>Z_HUFFMAN_ONLY</name> || <name><name>s</name>-&gt;<name>level</name></name> &lt; 2 ?
                             4 : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>OS_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>BUSY_STATE</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>text</name></name> ? 1 : 0) +
                            (<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> ? 2 : 0) +
                            (<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra</name></name> == <name>Z_NULL</name> ? 0 : 4) +
                            (<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>name</name></name> == <name>Z_NULL</name> ? 0 : 8) +
                            (<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>comment</name></name> == <name>Z_NULL</name> ? 0 : 16)</expr></argument>
                        )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>time</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>time</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>time</name></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>time</name></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>level</name></name> == 9 ? 2 :
                            (<name><name>s</name>-&gt;<name>strategy</name></name> &gt;= <name>Z_HUFFMAN_ONLY</name> || <name><name>s</name>-&gt;<name>level</name></name> &lt; 2 ?
                             4 : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>os</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra_len</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra_len</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name></expr></argument>,
                                        <argument><expr><name><name>s</name>-&gt;<name>pending</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>gzindex</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>EXTRA_STATE</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{
            <decl_stmt><decl><type><name>uInt</name></type> <name>header</name> <init>= <expr>(<name>Z_DEFLATED</name> + ((<name><name>s</name>-&gt;<name>w_bits</name></name>-8)&lt;&lt;4)) &lt;&lt; 8</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uInt</name></type> <name>level_flags</name></decl>;</decl_stmt>

            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> &gt;= <name>Z_HUFFMAN_ONLY</name> || <name><name>s</name>-&gt;<name>level</name></name> &lt; 2</expr>)</condition><then>
                <expr_stmt><expr><name>level_flags</name> = 0</expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>level</name></name> &lt; 6</expr>)</condition><then>
                <expr_stmt><expr><name>level_flags</name> = 1</expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>level</name></name> == 6</expr>)</condition><then>
                <expr_stmt><expr><name>level_flags</name> = 2</expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name>level_flags</name> = 3</expr>;</expr_stmt></else></if></else></if></else></if>
            <expr_stmt><expr><name>header</name> |= (<name>level_flags</name> &lt;&lt; 6)</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> != 0</expr>)</condition><then> <expr_stmt><expr><name>header</name> |= <name>PRESET_DICT</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>header</name> += 31 - (<name>header</name> % 31)</expr>;</expr_stmt>

            <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>BUSY_STATE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Save the adler32 of the preset dictionary: */</comment>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &amp; 0xffff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>adler32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>EXTRA_STATE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* start of bytes to update crc */</comment>

            <while>while <condition>(<expr><name><name>s</name>-&gt;<name>gzindex</name></name> &lt; (<name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra_len</name></name> &amp; 0xffff)</expr>)</condition> <block>{
                <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
                        <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
                                            <argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>beg</name> = <name><name>s</name>-&gt;<name>pending</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then>
                        <break>break;</break></then></if>
                }</block></then></if>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra</name><index>[<expr><name><name>s</name>-&gt;<name>gzindex</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>gzindex</name></name>++</expr>;</expr_stmt>
            }</block></while>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
                                    <argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzindex</name></name> == <name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>extra_len</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>gzindex</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>NAME_STATE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>NAME_STATE</name></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>NAME_STATE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* start of bytes to update crc */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

            <do>do <block>{
                <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
                        <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
                                            <argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>beg</name> = <name><name>s</name>-&gt;<name>pending</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>val</name> = 1</expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>val</name> = <name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>name</name><index>[<expr><name><name>s</name>-&gt;<name>gzindex</name></name>++</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>val</name> != 0</expr>)</condition>;</do>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
                                    <argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>val</name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>gzindex</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>COMMENT_STATE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>COMMENT_STATE</name></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>COMMENT_STATE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>comment</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uInt</name></type> <name>beg</name> <init>= <expr><name><name>s</name>-&gt;<name>pending</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* start of bytes to update crc */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

            <do>do <block>{
                <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
                        <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
                                            <argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>beg</name> = <name><name>s</name>-&gt;<name>pending</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> == <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>val</name> = 1</expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>val</name> = <name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>comment</name><index>[<expr><name><name>s</name>-&gt;<name>gzindex</name></name>++</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>val</name> != 0</expr>)</condition>;</do>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>pending</name></name> &gt; <name>beg</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pending_buf</name></name> + <name>beg</name></expr></argument>,
                                    <argument><expr><name><name>s</name>-&gt;<name>pending</name></name> - <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>val</name> == 0</expr>)</condition><then>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>HCRC_STATE</name></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>HCRC_STATE</name></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>HCRC_STATE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>gzhead</name>-&gt;<name>hcrc</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> + 2 &gt; <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> + 2 &lt;= <name><name>s</name>-&gt;<name>pending_buf_size</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>BUSY_STATE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>BUSY_STATE</name></expr>;</expr_stmt></else></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Flush as much pending output as possible */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>pending</name></name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */</comment>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = -1</expr>;</expr_stmt>
            <return>return <expr><name>Z_OK</name></expr>;</return>
        }</block></then></if>

    <comment type="block">/* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */</comment>
    }</block></then> <else>else <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_in</name></name> == 0 &amp;&amp; <name>flush</name> &lt;= <name>old_flush</name> &amp;&amp;
               <name>flush</name> != <name>Z_FINISH</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <comment type="block">/* User must not provide more input after the first FINISH: */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>status</name></name> == <name>FINISH_STATE</name> &amp;&amp; <name><name>strm</name>-&gt;<name>avail_in</name></name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Start a new block or continue the current one.
     */</comment>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_in</name></name> != 0 || <name><name>s</name>-&gt;<name>lookahead</name></name> != 0 ||
        (<name>flush</name> != <name>Z_NO_FLUSH</name> &amp;&amp; <name><name>s</name>-&gt;<name>status</name></name> != <name>FINISH_STATE</name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>block_state</name></type> <name>bstate</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>bstate</name> = (*(<name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>func</name>))(<name>s</name>, <name>flush</name>)</expr>;</expr_stmt>

        <if>if <condition>(<expr><name>bstate</name> == <name>finish_started</name> || <name>bstate</name> == <name>finish_done</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>status</name></name> = <name>FINISH_STATE</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>bstate</name> == <name>need_more</name> || <name>bstate</name> == <name>finish_started</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = -1</expr>;</expr_stmt> <comment type="block">/* avoid BUF_ERROR next call, see above */</comment>
            }</block></then></if>
            <return>return <expr><name>Z_OK</name></expr>;</return>
            <comment type="block">/* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name>bstate</name> == <name>block_done</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>flush</name> == <name>Z_PARTIAL_FLUSH</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>_tr_align</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{ <comment type="block">/* FULL_FLUSH or SYNC_FLUSH */</comment>
                <expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>char</name>*)0</expr></argument>, <argument><expr>0L</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */</comment>
                <if>if <condition>(<expr><name>flush</name> == <name>Z_FULL_FLUSH</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* forget history */</comment>
                }</block></then></if>
            }</block></else></if>
            <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{
              <expr_stmt><expr><name><name>s</name>-&gt;<name>last_flush</name></name> = -1</expr>;</expr_stmt> <comment type="block">/* avoid BUF_ERROR at next call, see above */</comment>
              <return>return <expr><name>Z_OK</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>avail_out</name></name> &gt; 0</expr></argument>, <argument><expr>"bug2"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>flush</name> != <name>Z_FINISH</name></expr>)</condition><then> <return>return <expr><name>Z_OK</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> &lt;= 0</expr>)</condition><then> <return>return <expr><name>Z_STREAM_END</name></expr>;</return></then></if>

    <comment type="block">/* Write the trailer */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> == 2</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>total_in</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>total_in</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>total_in</name></name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>Byte</name>)<argument_list>(<argument><expr>(<name><name>strm</name>-&gt;<name>total_in</name></name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
        <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &gt;&gt; 16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name> &amp; 0xffff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>wrap</name></name> &gt; 0</expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>wrap</name></name> = -<name><name>s</name>-&gt;<name>wrap</name></name></expr>;</expr_stmt></then></if> <comment type="block">/* write the trailer only once! */</comment>
    <return>return <expr><name><name>s</name>-&gt;<name>pending</name></name> != 0 ? <name>Z_OK</name> : <name>Z_STREAM_END</name></expr>;</return>
}</block></function>

<comment type="block">/* ========================================================================= */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateEnd</name> <parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <expr_stmt><expr><name>status</name> = <name><name>strm</name>-&gt;<name>state</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> != <name>INIT_STATE</name> &amp;&amp;
        <name>status</name> != <name>EXTRA_STATE</name> &amp;&amp;
        <name>status</name> != <name>NAME_STATE</name> &amp;&amp;
        <name>status</name> != <name>COMMENT_STATE</name> &amp;&amp;
        <name>status</name> != <name>HCRC_STATE</name> &amp;&amp;
        <name>status</name> != <name>BUSY_STATE</name> &amp;&amp;
        <name>status</name> != <name>FINISH_STATE</name></expr>)</condition><then> <block>{
      <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Deallocate in reverse order of allocations: */</comment>
    <expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>pending_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>status</name> == <name>BUSY_STATE</name> ? <name>Z_DATA_ERROR</name> : <name>Z_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateCopy</name> <parameter_list>(<param><decl><type><name>dest</name></type></decl></param>, <param><decl><type><name>source</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>source</name></decl>;</decl_stmt>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAXSEG_64K</name></cpp:ifdef>
    <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>ds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>ss</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ushf</name> *</type><name>overlay</name></decl>;</decl_stmt>


    <if>if <condition>(<expr><name>source</name> == <name>Z_NULL</name> || <name>dest</name> == <name>Z_NULL</name> || <name><name>source</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ss</name> = <name><name>source</name>-&gt;<name>state</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ds</name> = (<name>deflate_state</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ds</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>dest</name>-&gt;<name>state</name></name> = (struct <name>internal_state</name> <name>FAR</name> *) <name>ds</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name>-&gt;<name>strm</name></name> = <name>dest</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ds</name>-&gt;<name>window</name></name> = (<name>Bytef</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr>2*<sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name>-&gt;<name>prev</name></name>   = (<name>Posf</name> *)  <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name>-&gt;<name>head</name></name>   = (<name>Posf</name> *)  <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>hash_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>overlay</name> = (<name>ushf</name> *) <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>lit_bufsize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name>-&gt;<name>pending_buf</name></name> = (<name>uchf</name> *) <name>overlay</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>ds</name>-&gt;<name>window</name></name> == <name>Z_NULL</name> || <name><name>ds</name>-&gt;<name>prev</name></name> == <name>Z_NULL</name> || <name><name>ds</name>-&gt;<name>head</name></name> == <name>Z_NULL</name> ||
        <name><name>ds</name>-&gt;<name>pending_buf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>deflateEnd</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* following zmemcpy do not work for 16-bit MSDOS */</comment>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>w_size</name></name> * 2 * <sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name>-&gt;<name>prev</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>prev</name></name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>w_size</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><name><name>ds</name>-&gt;<name>hash_size</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name>-&gt;<name>pending_buf</name></name></expr></argument>, <argument><expr><name><name>ss</name>-&gt;<name>pending_buf</name></name></expr></argument>, <argument><expr>(<name>uInt</name>)<name><name>ds</name>-&gt;<name>pending_buf_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ds</name>-&gt;<name>pending_out</name></name> = <name><name>ds</name>-&gt;<name>pending_buf</name></name> + (<name><name>ss</name>-&gt;<name>pending_out</name></name> - <name><name>ss</name>-&gt;<name>pending_buf</name></name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name>-&gt;<name>d_buf</name></name> = <name>overlay</name> + <name><name>ds</name>-&gt;<name>lit_bufsize</name></name>/<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name>-&gt;<name>l_buf</name></name> = <name><name>ds</name>-&gt;<name>pending_buf</name></name> + (1+<sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof>)*<name><name>ds</name>-&gt;<name>lit_bufsize</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ds</name>-&gt;<name>l_desc</name>.<name>dyn_tree</name></name> = <name><name>ds</name>-&gt;<name>dyn_ltree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name>-&gt;<name>d_desc</name>.<name>dyn_tree</name></name> = <name><name>ds</name>-&gt;<name>dyn_dtree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ds</name>-&gt;<name>bl_desc</name>.<name>dyn_tree</name></name> = <name><name>ds</name>-&gt;<name>bl_tree</name></name></expr>;</expr_stmt>

    <return>return <expr><name>Z_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MAXSEG_64K */</comment>
}</block></function>

<comment type="block">/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm-&gt;next_in buffer and copying from it.
 * (See also flush_pending()).
 */</comment>
<function><type><name>local</name> <name>int</name></type> <name>read_buf</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>size</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bytef</name> *</type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> <init>= <expr><name><name>strm</name>-&gt;<name>avail_in</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> &gt; <name>size</name></expr>)</condition><then> <expr_stmt><expr><name>len</name> = <name>size</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><name><name>strm</name>-&gt;<name>avail_in</name></name>  -= <name>len</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>adler32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GZIP</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>state</name>-&gt;<name>wrap</name></name> == 2</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name>-&gt;<name>adler</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>next_in</name></name>  += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_in</name></name> += <name>len</name></expr>;</expr_stmt>

    <return>return <expr>(<name>int</name>)<name>len</name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>lm_init</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <expr_stmt><expr><name><name>s</name>-&gt;<name>window_size</name></name> = (<name>ulg</name>)2L*<name><name>s</name>-&gt;<name>w_size</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the default configuration parameters:
     */</comment>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>max_lazy_match</name></name>   = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>max_lazy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>good_match</name></name>       = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>good_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>nice_match</name></name>       = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>nice_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>max_chain_length</name></name> = <name><name>configuration_table</name><index>[<expr><name><name>s</name>-&gt;<name>level</name></name></expr>]</index></name>.<name>max_chain</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>block_start</name></name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <name><name>s</name>-&gt;<name>prev_length</name></name> = <name>MIN_MATCH</name>-1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>match_available</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>ins_h</name></name> = 0</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ASMV</name></cpp:ifdef>
    <expr_stmt><expr><call><name>match_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* initialize the asm code */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<comment type="block">/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1
 * OUT assertion: the match length is not greater than s-&gt;lookahead.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ASMV</name></cpp:ifndef>
<comment type="block">/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */</comment>
<function><type><name>local</name> <name>uInt</name></type> <name>longest_match</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>cur_match</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IPos</name></type> <name>cur_match</name></decl>;</decl_stmt>                             <comment type="block">/* current match */</comment>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>chain_length</name> <init>= <expr><name><name>s</name>-&gt;<name>max_chain_length</name></name></expr></init></decl>;</decl_stmt><comment type="block">/* max hash chain length */</comment>
    <decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>scan</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* current string */</comment>
    <decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>match</name></decl>;</decl_stmt>                       <comment type="block">/* matched string */</comment>
    <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>                           <comment type="block">/* length of current match */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>best_len</name> <init>= <expr><name><name>s</name>-&gt;<name>prev_length</name></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* best match length so far */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nice_match</name> <init>= <expr><name><name>s</name>-&gt;<name>nice_match</name></name></expr></init></decl>;</decl_stmt>             <comment type="block">/* stop if match long enough */</comment>
    <decl_stmt><decl><type><name>IPos</name></type> <name>limit</name> <init>= <expr><name><name>s</name>-&gt;<name>strstart</name></name> &gt; (<name>IPos</name>)<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> ?
        <name><name>s</name>-&gt;<name>strstart</name></name> - (<name>IPos</name>)<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> : <name>NIL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Stop when cur_match becomes &lt;= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */</comment>
    <decl_stmt><decl><type><name>Posf</name> *</type><name>prev</name> <init>= <expr><name><name>s</name>-&gt;<name>prev</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uInt</name></type> <name>wmask</name> <init>= <expr><name><name>s</name>-&gt;<name>w_mask</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNALIGNED_OK</name></cpp:ifdef>
    <comment type="block">/* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */</comment>
    <decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>strend</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name> + <name>MAX_MATCH</name> - 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>ush</name></type> <name>scan_start</name> <init>= <expr>*(<name>ushf</name>*)<name>scan</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>ush</name></type> <name>scan_end</name>   <init>= <expr>*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+<name>best_len</name>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>strend</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name> + <name>MAX_MATCH</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Byte</name></type> <name>scan_end1</name>  <init>= <expr><name><name>scan</name><index>[<expr><name>best_len</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Byte</name></type> <name>scan_end</name>   <init>= <expr><name><name>scan</name><index>[<expr><name>best_len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>hash_bits</name></name> &gt;= 8 &amp;&amp; <name>MAX_MATCH</name> == 258</expr></argument>, <argument><expr>"Code too clever"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Do not waste too much time if we already have a good match: */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>prev_length</name></name> &gt;= <name><name>s</name>-&gt;<name>good_match</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>chain_length</name> &gt;&gt;= 2</expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */</comment>
    <if>if <condition>(<expr>(<name>uInt</name>)<name>nice_match</name> &gt; <name><name>s</name>-&gt;<name>lookahead</name></name></expr>)</condition><then> <expr_stmt><expr><name>nice_match</name> = <name><name>s</name>-&gt;<name>lookahead</name></name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>(<name>ulg</name>)<name><name>s</name>-&gt;<name>strstart</name></name> &lt;= <name><name>s</name>-&gt;<name>window_size</name></name>-<name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr>"need lookahead"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do <block>{
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_match</name> &lt; <name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr>"no future"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> = <name><name>s</name>-&gt;<name>window</name></name> + <name>cur_match</name></expr>;</expr_stmt>

        <comment type="block">/* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_OK</name></expr></argument>)</argument_list></call> &amp;&amp; <name>MAX_MATCH</name> == 258)</expr></cpp:if>
        <comment type="block">/* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */</comment>
        <if>if <condition>(<expr>*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+<name>best_len</name>-1</expr></argument>)</argument_list></call> != <name>scan_end</name> ||
            *(<name>ushf</name>*)<name>match</name> != <name>scan_start</name></expr>)</condition><then> <continue>continue;</continue></then></if>

        <comment type="block">/* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><index>[<expr>2</expr>]</index></name> == <name><name>match</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>"scan[2]?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name>++</expr>, <expr><name>match</name>++</expr>;</expr_stmt>
        <do>do <block>{
        }</block> while <condition>(<expr>*<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+=2</expr></argument>)</argument_list></call> == *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+=2</expr></argument>)</argument_list></call> &amp;&amp;
                 *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+=2</expr></argument>)</argument_list></call> == *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+=2</expr></argument>)</argument_list></call> &amp;&amp;
                 *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+=2</expr></argument>)</argument_list></call> == *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+=2</expr></argument>)</argument_list></call> &amp;&amp;
                 *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+=2</expr></argument>)</argument_list></call> == *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>match</name>+=2</expr></argument>)</argument_list></call> &amp;&amp;
                 <name>scan</name> &lt; <name>strend</name></expr>)</condition>;</do>
        <comment type="block">/* The funny "do {}" generates better code on most compilers */</comment>

        <comment type="block">/* Here, scan &lt;= window+strstart+257 */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> &lt;= <name><name>s</name>-&gt;<name>window</name></name>+<call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window_size</name></name>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"wild scan"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>scan</name> == *<name>match</name></expr>)</condition><then> <expr_stmt><expr><name>scan</name>++</expr>;</expr_stmt></then></if>

        <expr_stmt><expr><name>len</name> = (<name>MAX_MATCH</name> - 1) - <call>(<name>int</name>)<argument_list>(<argument><expr><name>strend</name>-<name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> = <name>strend</name> - (<name>MAX_MATCH</name>-1)</expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* UNALIGNED_OK */</comment>

        <if>if <condition>(<expr><name><name>match</name><index>[<expr><name>best_len</name></expr>]</index></name>   != <name>scan_end</name>  ||
            <name><name>match</name><index>[<expr><name>best_len</name>-1</expr>]</index></name> != <name>scan_end1</name> ||
            *<name>match</name>            != *<name>scan</name>     ||
            *++<name>match</name>          != <name><name>scan</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then>      <continue>continue;</continue></then></if>

        <comment type="block">/* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS &gt;= 8.
         */</comment>
        <expr_stmt><expr><name>scan</name> += 2</expr>, <expr><name>match</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>*<name>scan</name> == *<name>match</name></expr></argument>, <argument><expr>"match[2]?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */</comment>
        <do>do <block>{
        }</block> while <condition>(<expr>*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
                 *++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
                 *++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
                 *++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
                 <name>scan</name> &lt; <name>strend</name></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> &lt;= <name><name>s</name>-&gt;<name>window</name></name>+<call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window_size</name></name>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"wild scan"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>len</name> = <name>MAX_MATCH</name> - <call>(<name>int</name>)<argument_list>(<argument><expr><name>strend</name> - <name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> = <name>strend</name> - <name>MAX_MATCH</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* UNALIGNED_OK */</comment>

        <if>if <condition>(<expr><name>len</name> &gt; <name>best_len</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>match_start</name></name> = <name>cur_match</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>best_len</name> = <name>len</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>len</name> &gt;= <name>nice_match</name></expr>)</condition><then> <break>break;</break></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNALIGNED_OK</name></cpp:ifdef>
            <expr_stmt><expr><name>scan_end</name> = *<call>(<name>ushf</name>*)<argument_list>(<argument><expr><name>scan</name>+<name>best_len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>scan_end1</name>  = <name><name>scan</name><index>[<expr><name>best_len</name>-1</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>scan_end</name>   = <name><name>scan</name><index>[<expr><name>best_len</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then></if>
    }</block> while <condition>(<expr>(<name>cur_match</name> = <name><name>prev</name><index>[<expr><name>cur_match</name> &amp; <name>wmask</name></expr>]</index></name>) &gt; <name>limit</name>
             &amp;&amp; --<name>chain_length</name> != 0</expr>)</condition>;</do>

    <if>if <condition>(<expr>(<name>uInt</name>)<name>best_len</name> &lt;= <name><name>s</name>-&gt;<name>lookahead</name></name></expr>)</condition><then> <return>return <expr>(<name>uInt</name>)<name>best_len</name></expr>;</return></then></if>
    <return>return <expr><name><name>s</name>-&gt;<name>lookahead</name></name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ASMV */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FASTEST */</comment>

<comment type="block">/* ---------------------------------------------------------------------------
 * Optimized version for level == 1 or strategy == Z_RLE only
 */</comment>
<function><type><name>local</name> <name>uInt</name></type> <name>longest_match_fast</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>cur_match</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IPos</name></type> <name>cur_match</name></decl>;</decl_stmt>                             <comment type="block">/* current match */</comment>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>scan</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* current string */</comment>
    <decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>match</name></decl>;</decl_stmt>                       <comment type="block">/* matched string */</comment>
    <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>                           <comment type="block">/* length of current match */</comment>
    <decl_stmt><decl><type><name>register</name> <name>Bytef</name> *</type><name>strend</name> <init>= <expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name> + <name>MAX_MATCH</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>hash_bits</name></name> &gt;= 8 &amp;&amp; <name>MAX_MATCH</name> == 258</expr></argument>, <argument><expr>"Code too clever"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>(<name>ulg</name>)<name><name>s</name>-&gt;<name>strstart</name></name> &lt;= <name><name>s</name>-&gt;<name>window_size</name></name>-<name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr>"need lookahead"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_match</name> &lt; <name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr>"no future"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>match</name> = <name><name>s</name>-&gt;<name>window</name></name> + <name>cur_match</name></expr>;</expr_stmt>

    <comment type="block">/* Return failure if the match length is less than 2:
     */</comment>
    <if>if <condition>(<expr><name><name>match</name><index>[<expr>0</expr>]</index></name> != <name><name>scan</name><index>[<expr>0</expr>]</index></name> || <name><name>match</name><index>[<expr>1</expr>]</index></name> != <name><name>scan</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <return>return <expr><name>MIN_MATCH</name>-1</expr>;</return></then></if>

    <comment type="block">/* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS &gt;= 8.
     */</comment>
    <expr_stmt><expr><name>scan</name> += 2</expr>, <expr><name>match</name> += 2</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>*<name>scan</name> == *<name>match</name></expr></argument>, <argument><expr>"match[2]?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */</comment>
    <do>do <block>{
    }</block> while <condition>(<expr>*++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
             *++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
             *++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
             *++<name>scan</name> == *++<name>match</name> &amp;&amp; *++<name>scan</name> == *++<name>match</name> &amp;&amp;
             <name>scan</name> &lt; <name>strend</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> &lt;= <name><name>s</name>-&gt;<name>window</name></name>+<call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window_size</name></name>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"wild scan"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> = <name>MAX_MATCH</name> - <call>(<name>int</name>)<argument_list>(<argument><expr><name>strend</name> - <name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>len</name> &lt; <name>MIN_MATCH</name></expr>)</condition><then> <return>return <expr><name>MIN_MATCH</name> - 1</expr>;</return></then></if>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>match_start</name></name> = <name>cur_match</name></expr>;</expr_stmt>
    <return>return <expr>(<name>uInt</name>)<name>len</name> &lt;= <name><name>s</name>-&gt;<name>lookahead</name></name> ? (<name>uInt</name>)<name>len</name> : <name><name>s</name>-&gt;<name>lookahead</name></name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<comment type="block">/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>check_match</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>start</name></type></decl></param>, <param><decl><type><name>match</name></type></decl></param>, <param><decl><type><name>length</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IPos</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<block>{
    <comment type="block">/* check that the match is indeed a match */</comment>
    <if>if <condition>(<expr><call><name>zmemcmp</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window</name></name> + <name>match</name></expr></argument>,
                <argument><expr><name><name>s</name>-&gt;<name>window</name></name> + <name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> != <name>EQUAL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>" start %u, match %u, length %d\n"</expr></argument>,
                <argument><expr><name>start</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <do>do <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%c%c"</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name>match</name>++</expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name>start</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> while <condition>(<expr>--<name>length</name> != 0</expr>)</condition>;</do>
        <expr_stmt><expr><call><name>z_error</name><argument_list>(<argument><expr>"invalid match"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>z_verbose</name> &gt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"\\[%d,%d]"</expr></argument>, <argument><expr><name>start</name>-<name>match</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <do>do <block>{ <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name>start</name>++</expr>]</index></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block> while <condition>(<expr>--<name>length</name> != 0</expr>)</condition>;</do>
    }</block></then></if>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>check_match</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>start</name></type></param>, <param><type><name>match</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>

<comment type="block">/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead &lt; MIN_LOOKAHEAD
 * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>fill_window</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>unsigned</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>Posf</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>more</name></decl>;</decl_stmt>    <comment type="block">/* Amount of free space at the end of the window. */</comment>
    <decl_stmt><decl><type><name>uInt</name></type> <name>wsize</name> <init>= <expr><name><name>s</name>-&gt;<name>w_size</name></name></expr></init></decl>;</decl_stmt>

    <do>do <block>{
        <expr_stmt><expr><name>more</name> = <call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window_size</name></name> -(<name>ulg</name>)<name><name>s</name>-&gt;<name>lookahead</name></name> -(<name>ulg</name>)<name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Deal with !@#$% 64K limit: */</comment>
        <if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> &lt;= 2</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>more</name> == 0 &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> == 0 &amp;&amp; <name><name>s</name>-&gt;<name>lookahead</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>more</name> = <name>wsize</name></expr>;</expr_stmt>

            }</block></then> <else>else <if>if <condition>(<expr><name>more</name> == <call>(<name>unsigned</name>)<argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* Very unlikely, but possible on 16 bit machine if
                 * strstart == 0 &amp;&amp; lookahead == 1 (input done a byte at time)
                 */</comment>
                <expr_stmt><expr><name>more</name>--</expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></then></if>

        <comment type="block">/* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> &gt;= <name>wsize</name>+<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

            <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name></name>+<name>wsize</name></expr></argument>, <argument><expr>(<name>unsigned</name>)<name>wsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>match_start</name></name> -= <name>wsize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>    -= <name>wsize</name></expr>;</expr_stmt> <comment type="block">/* we now have strstart &gt;= MAX_DIST */</comment>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>block_start</name></name> -= (<name>long</name>) <name>wsize</name></expr>;</expr_stmt>

            <comment type="block">/* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level &gt; 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */</comment>
            <comment type="block">/* %%% avoid this when Z_RLE */</comment>
            <expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>hash_size</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> = &amp;<name><name>s</name>-&gt;<name>head</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
            <do>do <block>{
                <expr_stmt><expr><name>m</name> = *--<name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name> = <call>(<name>Pos</name>)<argument_list>(<argument><expr><name>m</name> &gt;= <name>wsize</name> ? <name>m</name>-<name>wsize</name> : <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr>--<name>n</name></expr>)</condition>;</do>

            <expr_stmt><expr><name>n</name> = <name>wsize</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
            <expr_stmt><expr><name>p</name> = &amp;<name><name>s</name>-&gt;<name>prev</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
            <do>do <block>{
                <expr_stmt><expr><name>m</name> = *--<name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>p</name> = <call>(<name>Pos</name>)<argument_list>(<argument><expr><name>m</name> &gt;= <name>wsize</name> ? <name>m</name>-<name>wsize</name> : <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* If n is not on any hash chain, prev[n] is garbage but
                 * its value will never be used.
                 */</comment>
            }</block> while <condition>(<expr>--<name>n</name></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>more</name> += <name>wsize</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strm</name>-&gt;<name>avail_in</name></name> == 0</expr>)</condition><then> <return>return;</return></then></if>

        <comment type="block">/* If there was no sliding:
         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;
         *    more == window_size - lookahead - strstart
         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * =&gt; more &gt;= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;
         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.
         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>more</name> &gt;= 2</expr></argument>, <argument><expr>"more &lt; 2"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>n</name> = <call><name>read_buf</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>strm</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name></name> + <name><name>s</name>-&gt;<name>strstart</name></name> + <name><name>s</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> += <name>n</name></expr>;</expr_stmt>

        <comment type="block">/* Initialize the hash value now that we have some input: */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>ins_h</name></name> = <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIN_MATCH</name> != 3</expr></cpp:if>
            <expr_stmt><expr><name>Call</name> <macro><name>UPDATE_HASH</name><argument_list>()</argument_list></macro> <name>MIN_MATCH</name>-3 <name>more</name> <name>times</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then></if>
        <comment type="block">/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */</comment>

    }</block> while <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name> &amp;&amp; <name><name>s</name>-&gt;<name>strm</name>-&gt;<name>avail_in</name></name> != 0</expr>)</condition>;</do>
}</block></function>

<comment type="block">/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_BLOCK_ONLY</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>eof</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
   _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? \
                   (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : \
                   (charf *)Z_NULL), \
                (ulg)((long)s-&gt;strstart - s-&gt;block_start), \
                (eof)); \
   s-&gt;block_start = s-&gt;strstart; \
   flush_pending(s-&gt;strm); \
   Tracev((stderr,"[FLUSH]")); \
}</cpp:value></cpp:define>

<comment type="block">/* Same but force premature exit if necessary. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_BLOCK</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>eof</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
   FLUSH_BLOCK_ONLY(s, eof); \
   if (s-&gt;strm-&gt;avail_out == 0) return (eof) ? finish_started : need_more; \
}</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */</comment>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_stored</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
    <comment type="block">/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */</comment>
    <decl_stmt><decl><type><name>ulg</name></type> <name>max_block_size</name> <init>= <expr>0xffff</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ulg</name></type> <name>max_start</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>max_block_size</name> &gt; <name><name>s</name>-&gt;<name>pending_buf_size</name></name> - 5</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>max_block_size</name> = <name><name>s</name>-&gt;<name>pending_buf_size</name></name> - 5</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Copy as much as possible from input to output: */</comment>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <comment type="block">/* Fill the window as much as possible: */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt;= 1</expr>)</condition><then> <block>{

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>strstart</name></name> &lt; <name><name>s</name>-&gt;<name>w_size</name></name>+<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> ||
                   <name><name>s</name>-&gt;<name>block_start</name></name> &gt;= (<name>long</name>)<name><name>s</name>-&gt;<name>w_size</name></name></expr></argument>, <argument><expr>"slide too late"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> == 0 &amp;&amp; <name>flush</name> == <name>Z_NO_FLUSH</name></expr>)</condition><then> <return>return <expr><name>need_more</name></expr>;</return></then></if>

            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> == 0</expr>)</condition><then> <break>break;</break></then></if> <comment type="block">/* flush the current block */</comment>
        }</block></then></if>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>block_start</name></name> &gt;= 0L</expr></argument>, <argument><expr>"block gone"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> += <name><name>s</name>-&gt;<name>lookahead</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> = 0</expr>;</expr_stmt>

        <comment type="block">/* Emit a stored block if pending_buf will be full: */</comment>
        <expr_stmt><expr><name>max_start</name> = <name><name>s</name>-&gt;<name>block_start</name></name> + <name>max_block_size</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> == 0 || (<name>ulg</name>)<name><name>s</name>-&gt;<name>strstart</name></name> &gt;= <name>max_start</name></expr>)</condition><then> <block>{
            <comment type="block">/* strstart == 0 is possible when wraparound on 16-bit machine */</comment>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> = <call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>strstart</name></name> - <name>max_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> = (<name>uInt</name>)<name>max_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strstart</name></name> - (<name>uInt</name>)<name><name>s</name>-&gt;<name>block_start</name></name> &gt;= <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name> == <name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>flush</name> == <name>Z_FINISH</name> ? <name>finish_done</name> : <name>block_done</name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */</comment>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_fast</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* head of the hash chain */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt>           <comment type="block">/* set if current block must be flushed */</comment>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <comment type="block">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name> &amp;&amp; <name>flush</name> == <name>Z_NO_FLUSH</name></expr>)</condition><then> <block>{
                <return>return <expr><name>need_more</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> == 0</expr>)</condition><then> <break>break;</break></then></if> <comment type="block">/* flush the current block */</comment>
        }</block></then></if>

        <comment type="block">/* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Find the longest match, discarding those &lt;= prev_length.
         * At this point we have always match_length &lt; MIN_MATCH
         */</comment>
        <if>if <condition>(<expr><name>hash_head</name> != <name>NIL</name> &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> &lt;= <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FASTEST</name></cpp:ifdef>
            <if>if <condition>(<expr>(<name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_HUFFMAN_ONLY</name> &amp;&amp; <name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_RLE</name>) ||
                (<name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_RLE</name> &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> == 1)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match_fast</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_HUFFMAN_ONLY</name> &amp;&amp; <name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_RLE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_RLE</name> &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> == 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match_fast</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* longest_match() or longest_match_fast() sets match_start */</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_length</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>match_start</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>match_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name> - <name><name>s</name>-&gt;<name>match_start</name></name></expr></argument>,
                           <argument><expr><name><name>s</name>-&gt;<name>match_length</name></name> - <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> -= <name><name>s</name>-&gt;<name>match_length</name></name></expr>;</expr_stmt>

            <comment type="block">/* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_length</name></name> &lt;= <name><name>s</name>-&gt;<name>max_insert_length</name></name> &amp;&amp;
                <name><name>s</name>-&gt;<name>lookahead</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name>--</expr>;</expr_stmt> <comment type="block">/* string at strstart already in table */</comment>
                <do>do <block>{
                    <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */</comment>
                }</block> while <condition>(<expr>--<name><name>s</name>-&gt;<name>match_length</name></name> != 0</expr>)</condition>;</do>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
            }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name> += <name><name>s</name>-&gt;<name>match_length</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>ins_h</name></name> = <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIN_MATCH</name> != 3</expr></cpp:if>
                <expr_stmt><expr><name>Call</name> <macro><name>UPDATE_HASH</name><argument_list>()</argument_list></macro> <name>MIN_MATCH</name>-3 <name>more</name> <name>times</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */</comment>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <comment type="block">/* No match, output a literal byte */</comment>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>,"%c", <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_tr_tally_lit</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name>--</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><name>bflush</name></expr>)</condition><then> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name> == <name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>flush</name> == <name>Z_FINISH</name> ? <name>finish_done</name> : <name>block_done</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FASTEST</name></cpp:ifndef>
<comment type="block">/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */</comment>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_slow</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* head of hash chain */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt>              <comment type="block">/* set if current block must be flushed */</comment>

    <comment type="block">/* Process the input block. */</comment>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <comment type="block">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &lt; <name>MIN_LOOKAHEAD</name> &amp;&amp; <name>flush</name> == <name>Z_NO_FLUSH</name></expr>)</condition><then> <block>{
                <return>return <expr><name>need_more</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> == 0</expr>)</condition><then> <break>break;</break></then></if> <comment type="block">/* flush the current block */</comment>
        }</block></then></if>

        <comment type="block">/* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>lookahead</name></name> &gt;= <name>MIN_MATCH</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Find the longest match, discarding those &lt;= prev_length.
         */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>prev_length</name></name> = <name><name>s</name>-&gt;<name>match_length</name></name></expr>, <expr><name><name>s</name>-&gt;<name>prev_match</name></name> = <name><name>s</name>-&gt;<name>match_start</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <name>MIN_MATCH</name>-1</expr>;</expr_stmt>

        <if>if <condition>(<expr><name>hash_head</name> != <name>NIL</name> &amp;&amp; <name><name>s</name>-&gt;<name>prev_length</name></name> &lt; <name><name>s</name>-&gt;<name>max_lazy_match</name></name> &amp;&amp;
            <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> &lt;= <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */</comment>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_HUFFMAN_ONLY</name> &amp;&amp; <name><name>s</name>-&gt;<name>strategy</name></name> != <name>Z_RLE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_RLE</name> &amp;&amp; <name><name>s</name>-&gt;<name>strstart</name></name> - <name>hash_head</name> == 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <call><name>longest_match_fast</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>
            <comment type="block">/* longest_match() or longest_match_fast() sets match_start */</comment>

            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_length</name></name> &lt;= 5 &amp;&amp; (<name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_FILTERED</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TOO_FAR</name> &lt;= 32767</expr></cpp:if>
                || (<name><name>s</name>-&gt;<name>match_length</name></name> == <name>MIN_MATCH</name> &amp;&amp;
                    <name><name>s</name>-&gt;<name>strstart</name></name> - <name><name>s</name>-&gt;<name>match_start</name></name> &gt; <name>TOO_FAR</name>)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                )</expr>)</condition><then> <block>{

                <comment type="block">/* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */</comment>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <name>MIN_MATCH</name>-1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <comment type="block">/* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>prev_length</name></name> &gt;= <name>MIN_MATCH</name> &amp;&amp; <name><name>s</name>-&gt;<name>match_length</name></name> &lt;= <name><name>s</name>-&gt;<name>prev_length</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uInt</name></type> <name>max_insert</name> <init>= <expr><name><name>s</name>-&gt;<name>strstart</name></name> + <name><name>s</name>-&gt;<name>lookahead</name></name> - <name>MIN_MATCH</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Do not insert strings in hash table beyond this. */</comment>

            <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>prev_match</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>prev_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name> -1 - <name><name>s</name>-&gt;<name>prev_match</name></name></expr></argument>,
                           <argument><expr><name><name>s</name>-&gt;<name>prev_length</name></name> - <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */</comment>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name> -= <name><name>s</name>-&gt;<name>prev_length</name></name>-1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>prev_length</name></name> -= 2</expr>;</expr_stmt>
            <do>do <block>{
                <if>if <condition>(<expr>++<name><name>s</name>-&gt;<name>strstart</name></name> &lt;= <name>max_insert</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block> while <condition>(<expr>--<name><name>s</name>-&gt;<name>prev_length</name></name> != 0</expr>)</condition>;</do>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>match_available</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>match_length</name></name> = <name>MIN_MATCH</name>-1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>

            <if>if <condition>(<expr><name>bflush</name></expr>)</condition><then> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        }</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_available</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */</comment>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>,"%c", <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>_tr_tally_lit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>bflush</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>FLUSH_BLOCK_ONLY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name>--</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strm</name>-&gt;<name>avail_out</name></name> == 0</expr>)</condition><then> <return>return <expr><name>need_more</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <comment type="block">/* There is no previous match to compare with, wait for
             * the next step to decide.
             */</comment>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>match_available</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>strstart</name></name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>lookahead</name></name>--</expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></for>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>flush</name> != <name>Z_NO_FLUSH</name></expr></argument>, <argument><expr>"no flush?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>match_available</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>,"%c", <name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_tr_tally_lit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>window</name><index>[<expr><name><name>s</name>-&gt;<name>strstart</name></name>-1</expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>match_available</name></name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name> == <name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>flush</name> == <name>Z_FINISH</name> ? <name>finish_done</name> : <name>block_done</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FASTEST */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */</comment>
local block_state deflate_rle(s, flush)
    deflate_state *s;
    int flush;
{
    int bflush;         <comment type="block">/* set if current block must be flushed */</comment>
    uInt run;           <comment type="block">/* length of run */</comment>
    uInt max;           <comment type="block">/* maximum length of run */</comment>
    uInt prev;          <comment type="block">/* byte at distance one to match */</comment>
    Bytef *scan;        <comment type="block">/* scan for end of run */</comment>

    for (;;) {
        <comment type="block">/* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest encodable run.
         */</comment>
        if (s-&gt;lookahead &lt; MAX_MATCH) {
            fill_window(s);
            if (s-&gt;lookahead &lt; MAX_MATCH &amp;&amp; flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s-&gt;lookahead == 0) break; <comment type="block">/* flush the current block */</comment>
        }

        <comment type="block">/* See how many times the previous byte repeats */</comment>
        run = 0;
        if (s-&gt;strstart &gt; 0) {      <comment type="block">/* if there is a previous byte, that is */</comment>
            max = s-&gt;lookahead &lt; MAX_MATCH ? s-&gt;lookahead : MAX_MATCH;
            scan = s-&gt;window + s-&gt;strstart - 1;
            prev = *scan++;
            do {
                if (*scan++ != prev)
                    break;
            } while (++run &lt; max);
        }

        <comment type="block">/* Emit match if have run of MIN_MATCH or longer, else emit literal */</comment>
        if (run &gt;= MIN_MATCH) {
            check_match(s, s-&gt;strstart, s-&gt;strstart - 1, run);
            _tr_tally_dist(s, 1, run - MIN_MATCH, bflush);
            s-&gt;lookahead -= run;
            s-&gt;strstart += run;
        } else {
            <comment type="block">/* No match, output a literal byte */</comment>
            Tracevv((stderr,"%c", s-&gt;window[s-&gt;strstart]));
            _tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);
            s-&gt;lookahead--;
            s-&gt;strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
