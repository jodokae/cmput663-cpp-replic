<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/zlib/gzio.c"><comment type="block">/* gzio.c -- IO on .gz files
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Compile this file with -DNO_GZCOMPRESS to avoid the compression code.
 */</comment>

<comment type="block">/* @(#) $Id$ */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zutil.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_DEFLATE</name></cpp:ifdef>       <comment type="block">/* for compatibility with old definition */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NO_GZCOMPRESS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUMMY_DECL</name></cpp:ifndef>
<struct>struct <name>internal_state</name> <block>{<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>}</block>;</struct> <comment type="block">/* for buggy compilers */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_BUFSIZE</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>MAXSEG_64K</name></cpp:ifdef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BUFSIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define> <comment type="block">/* minimize memory usage for 16-bit DOS */</comment>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BUFSIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_PRINTF_BUFSIZE</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>Z_PRINTF_BUFSIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__MVS__</name></cpp:ifdef>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> map (fdopen , "\174\174FDOPEN")</cpp:pragma>
   <function_decl><type><name>FILE</name> *</type><name>fdopen</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>STDC</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>voidp</name>  <name>malloc</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>uInt</name> <name>size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>void</name>   <name>free</name></type>   <name>OF</name><argument_list>(<argument><expr>(<name>voidpf</name> <name>ptr</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC</name><parameter_list>(<param><type><name>size</name></type></param>)</parameter_list></cpp:macro> <cpp:value>malloc(size)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYFREE</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{if (p) free(p);}</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <specifier>const</specifier></type> <name><name>gz_magic</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr>0x1f</expr>, <expr>0x8b</expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* gzip magic header */</comment>

<comment type="block">/* gzip flag byte */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASCII_FLAG</name></cpp:macro>   <cpp:value>0x01</cpp:value></cpp:define> <comment type="block">/* bit 0 set: file probably ascii text */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_CRC</name></cpp:macro>     <cpp:value>0x02</cpp:value></cpp:define> <comment type="block">/* bit 1 set: header CRC present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_FIELD</name></cpp:macro>  <cpp:value>0x04</cpp:value></cpp:define> <comment type="block">/* bit 2 set: extra field present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ORIG_NAME</name></cpp:macro>    <cpp:value>0x08</cpp:value></cpp:define> <comment type="block">/* bit 3 set: original file name present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMENT</name></cpp:macro>      <cpp:value>0x10</cpp:value></cpp:define> <comment type="block">/* bit 4 set: file comment present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESERVED</name></cpp:macro>     <cpp:value>0xE0</cpp:value></cpp:define> <comment type="block">/* bits 5..7: reserved */</comment>

<typedef>typedef <type><struct>struct <name>gz_stream</name> <block>{
    <decl_stmt><decl><type><name>z_stream</name></type> <name>stream</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>z_err</name></decl>;</decl_stmt>   <comment type="block">/* error code for last stream operation */</comment>
    <decl_stmt><decl><type><name>int</name></type>      <name>z_eof</name></decl>;</decl_stmt>   <comment type="block">/* set if end of input file */</comment>
    <decl_stmt><decl><type><name>FILE</name>     *</type><name>file</name></decl>;</decl_stmt>   <comment type="block">/* .gz file */</comment>
    <decl_stmt><decl><type><name>Byte</name>     *</type><name>inbuf</name></decl>;</decl_stmt>  <comment type="block">/* input buffer */</comment>
    <decl_stmt><decl><type><name>Byte</name>     *</type><name>outbuf</name></decl>;</decl_stmt> <comment type="block">/* output buffer */</comment>
    <decl_stmt><decl><type><name>uLong</name></type>    <name>crc</name></decl>;</decl_stmt>     <comment type="block">/* crc32 of uncompressed data */</comment>
    <decl_stmt><decl><type><name>char</name>     *</type><name>msg</name></decl>;</decl_stmt>    <comment type="block">/* error message */</comment>
    <decl_stmt><decl><type><name>char</name>     *</type><name>path</name></decl>;</decl_stmt>   <comment type="block">/* path name for debugging only */</comment>
    <decl_stmt><decl><type><name>int</name></type>      <name>transparent</name></decl>;</decl_stmt> <comment type="block">/* 1 if input file is not a .gz file */</comment>
    <decl_stmt><decl><type><name>char</name></type>     <name>mode</name></decl>;</decl_stmt>    <comment type="block">/* 'w' or 'r' */</comment>
    <decl_stmt><decl><type><name>z_off_t</name></type>  <name>start</name></decl>;</decl_stmt>   <comment type="block">/* start of compressed data in file (header skipped) */</comment>
    <decl_stmt><decl><type><name>z_off_t</name></type>  <name>in</name></decl>;</decl_stmt>      <comment type="block">/* bytes into deflate or inflate */</comment>
    <decl_stmt><decl><type><name>z_off_t</name></type>  <name>out</name></decl>;</decl_stmt>     <comment type="block">/* bytes out of deflate or inflate */</comment>
    <decl_stmt><decl><type><name>int</name></type>      <name>back</name></decl>;</decl_stmt>    <comment type="block">/* one character push-back */</comment>
    <decl_stmt><decl><type><name>int</name></type>      <name>last</name></decl>;</decl_stmt>    <comment type="block">/* true if push-back is last character */</comment>
}</block></struct></type> <name>gz_stream</name>;</typedef>


<decl_stmt><decl><type><name>local</name> <name>gzFile</name> <name>gz_open</name></type>      <name>OF</name><argument_list>(<argument><expr>(const <name>char</name> *<name>path</name>, const <name>char</name> *<name>mode</name>, <name>int</name>  <name>fd</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>do_flush</name></type>        <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name>    <name>get_byte</name></type>     <name>OF</name><argument_list>(<argument><expr>(<name>gz_stream</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name>   <name>check_header</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gz_stream</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name>    <name>destroy</name></type>      <name>OF</name><argument_list>(<argument><expr>(<name>gz_stream</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name>   <name>putLong</name></type>      <name>OF</name><argument_list>(<argument><expr>(<name>FILE</name> *<name>file</name>, <name>uLong</name> <name>x</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>uLong</name>  <name>getLong</name></type>      <name>OF</name><argument_list>(<argument><expr>(<name>gz_stream</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="block">/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
   or path name (if fd == -1).
     gz_open returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/</comment>
<function><type><name>local</name> <name>gzFile</name></type> <name>gz_open</name> <parameter_list>(<param><decl><type><name>path</name></type></decl></param>, <param><decl><type><name>mode</name></type></decl></param>, <param><decl><type><name>fd</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>fd</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><name>Z_DEFAULT_COMPRESSION</name></expr></init></decl>;</decl_stmt> <comment type="block">/* compression level */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>strategy</name> <init>= <expr><name>Z_DEFAULT_STRATEGY</name></expr></init></decl>;</decl_stmt> <comment type="block">/* compression strategy */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr>(<name>char</name>*)<name>mode</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>fmode</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* copy of mode, without the compression level */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>m</name> <init>= <expr><name>fmode</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>path</name> || !<name>mode</name></expr>)</condition><then> <return>return <expr><name>Z_NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>s</name> = (<name>gz_stream</name> *)<call><name>ALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <return>return <expr><name>Z_NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>zalloc</name></name> = (<name>alloc_func</name>)0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>zfree</name></name> = (<name>free_func</name>)0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>opaque</name></name> = (<name>voidpf</name>)0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>file</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>msg</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>transparent</name></name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>path</name></name> = (<name>char</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>path</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* do this early for debugging */</comment>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>mode</name></name> = '\0'</expr>;</expr_stmt>
    <do>do <block>{
        <if>if <condition>(<expr>*<name>p</name> == 'r'</expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>mode</name></name> = 'r'</expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr>*<name>p</name> == 'w' || *<name>p</name> == 'a'</expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>mode</name></name> = 'w'</expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr>*<name>p</name> &gt;= '0' &amp;&amp; *<name>p</name> &lt;= '9'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>level</name> = *<name>p</name> - '0'</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr>*<name>p</name> == 'f'</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>strategy</name> = <name>Z_FILTERED</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr>*<name>p</name> == 'h'</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>strategy</name> = <name>Z_HUFFMAN_ONLY</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr>*<name>p</name> == 'R'</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>strategy</name> = <name>Z_RLE</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr>*<name>m</name>++ = *<name>p</name></expr>;</expr_stmt> <comment type="block">/* copy the mode */</comment>
        }</block></else></if></else></if></else></if></else></if>
    }</block> while <condition>(<expr>*<name>p</name>++ &amp;&amp; <name>m</name> != <name>fmode</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>fmode</name></expr></argument>)</argument_list></sizeof></expr>)</condition>;</do>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == '\0'</expr>)</condition><then> <return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_GZCOMPRESS</name></cpp:ifdef>
        <expr_stmt><expr><name>err</name> = <name>Z_STREAM_ERROR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>err</name> = <call><name>deflateInit2</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>level</name></expr></argument>,
                           <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr>-<name>MAX_WBITS</name></expr></argument>, <argument><expr><name>DEF_MEM_LEVEL</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* windowBits is passed &lt; 0 to suppress zlib header */</comment>

        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name> = (<name>Byte</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><name>err</name> != <name>Z_OK</name> || <name><name>s</name>-&gt;<name>outbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name>  = <name><name>s</name>-&gt;<name>inbuf</name></name> = (<name>Byte</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>err</name> = <call><name>inflateInit2</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr>-<name>MAX_WBITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* windowBits is passed &lt; 0 to tell that there is no zlib header.
         * Note that in this case inflate *requires* an extra "dummy" byte
         * after the compressed stream in order to complete decompression and
         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
         * present after the compressed stream.
         */</comment>
        <if>if <condition>(<expr><name>err</name> != <name>Z_OK</name> || <name><name>s</name>-&gt;<name>inbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return>
        }</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>Z_BUFSIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>file</name></name> = <name>fd</name> &lt; 0 ? <call><name>F_OPEN</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>fmode</name></expr></argument>)</argument_list></call> : (<name>FILE</name>*)<call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>fmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>file</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>destroy</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
        <comment type="block">/* Write a very simple .gz header:
         */</comment>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>"%c%c%c%c%c%c%c%c%c%c"</expr></argument>, <argument><expr><name><name>gz_magic</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>gz_magic</name><index>[<expr>1</expr>]</index></name></expr></argument>,
             <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr>0</expr></argument> <comment type="block">/*flags*/</comment>, <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument> <comment type="block">/*time*/</comment>, <argument><expr>0</expr></argument> <comment type="block">/*xflags*/</comment>, <argument><expr><name>OS_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>start</name></name> = 10L</expr>;</expr_stmt>
        <comment type="block">/* We use 10L instead of ftell(s-&gt;file) to because ftell causes an
         * fflush on some systems. This version of the library doesn't use
         * start anyway in write mode, so this initialization is not
         * necessary.
         */</comment>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>check_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip the .gz header */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>start</name></name> = <call><name>ftell</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call> - <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr>(<name>gzFile</name>)<name>s</name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing.
*/</comment>
<function><type><name>gzFile</name> <name>ZEXPORT</name></type> <name>gzopen</name> <parameter_list>(<param><decl><type><name>path</name></type></decl></param>, <param><decl><type><name>mode</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
<block>{
    <return>return <expr><call><name>gz_open</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
   to mimic the behavio(u)r of fdopen.
*/</comment>
<function><type><name>gzFile</name> <name>ZEXPORT</name></type> <name>gzdopen</name> <parameter_list>(<param><decl><type><name>fd</name></type></decl></param>, <param><decl><type><name>mode</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr>46</expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* allow for up to 128-bit integers */</comment>

    <if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then> <return>return <expr>(<name>gzFile</name>)<name>Z_NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"&lt;fd:%d&gt;"</expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* for debugging */</comment>

    <return>return <expr><call><name>gz_open</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
 * Update the compression level and strategy
 */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzsetparams</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>level</name></type></decl></param>, <param><decl><type><name>strategy</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'w'</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <comment type="block">/* Make room to allow flushing */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{

        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call> != <name>Z_BUFSIZE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>Z_BUFSIZE</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>deflateParams</name> <argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
   for end of file.
   IN assertion: the stream s has been sucessfully opened for reading.
*/</comment>
<function><type><name>local</name> <name>int</name></type> <name>get_byte</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_eof</name></name></expr>)</condition><then> <return>return <expr><name>EOF</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = (<name>uInt</name>)<call><name>fread</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 1</expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt></then></if>
            <return>return <expr><name>EOF</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name>--</expr>;</expr_stmt>
    <return>return <expr>*(<name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name>)++</expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
      Check the gzip header of a gz_stream opened for reading. Set the stream
    mode to transparent if the gzip magic header is not present; set s-&gt;err
    to Z_DATA_ERROR if the magic header is present but the rest of the header
    is incorrect.
    IN assertion: the stream s has already been created sucessfully;
       s-&gt;stream.avail_in is zero for the first time, but may be non-zero
       for concatenated .gz files.
*/</comment>
<function><type><name>local</name> <name>void</name></type> <name>check_header</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>method</name></decl>;</decl_stmt> <comment type="block">/* method byte */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>  <comment type="block">/* flags byte */</comment>
    <decl_stmt><decl><type><name>uInt</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

    <comment type="block">/* Assure two bytes in the buffer so we can peek ahead -- handle case
       where first byte of header is at the end of the buffer after the last
       gzip segment */</comment>
    <expr_stmt><expr><name>len</name> = <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len</name> &lt; 2</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>len</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>inbuf</name><index>[<expr>0</expr>]</index></name> = <name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = (<name>uInt</name>)<call><name>fread</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name> + <name>len</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name> &gt;&gt; <name>len</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>len</name> == 0 &amp;&amp; <call><name>ferror</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> += <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> &lt; 2</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>transparent</name></name> = <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Peek ahead to check the gzip magic header */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name><index>[<expr>0</expr>]</index></name> != <name><name>gz_magic</name><index>[<expr>0</expr>]</index></name> ||
        <name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name><index>[<expr>1</expr>]</index></name> != <name><name>gz_magic</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>transparent</name></name> = 1</expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> -= 2</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> += 2</expr>;</expr_stmt>

    <comment type="block">/* Check the rest of the gzip header */</comment>
    <expr_stmt><expr><name>method</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>method</name> != <name>Z_DEFLATED</name> || (<name>flags</name> &amp; <name>RESERVED</name>) != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_DATA_ERROR</name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* Discard time, xflags and OS code: */</comment>
    <for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; 6</expr>;</condition> <incr><expr><name>len</name>++</expr></incr>) <expr_stmt><expr>(<name>void</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

    <if>if <condition>(<expr>(<name>flags</name> &amp; <name>EXTRA_FIELD</name>) != 0</expr>)</condition><then> <block>{ <comment type="block">/* skip the extra field */</comment>
        <expr_stmt><expr><name>len</name>  =  (<name>uInt</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> += ((<name>uInt</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)&lt;&lt;8</expr>;</expr_stmt>
        <comment type="block">/* len is garbage if EOF but the loop below will quit anyway */</comment>
        <while>while <condition>(<expr><name>len</name>-- != 0 &amp;&amp; <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> != <name>EOF</name></expr>)</condition> <empty_stmt>;</empty_stmt></while>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>flags</name> &amp; <name>ORIG_NAME</name>) != 0</expr>)</condition><then> <block>{ <comment type="block">/* skip the original file name */</comment>
        <while>while <condition>(<expr>(<name>c</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>c</name> != <name>EOF</name></expr>)</condition> <empty_stmt>;</empty_stmt></while>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>flags</name> &amp; <name>COMMENT</name>) != 0</expr>)</condition><then> <block>{   <comment type="block">/* skip the .gz file comment */</comment>
        <while>while <condition>(<expr>(<name>c</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>c</name> != <name>EOF</name></expr>)</condition> <empty_stmt>;</empty_stmt></while>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>flags</name> &amp; <name>HEAD_CRC</name>) != 0</expr>)</condition><then> <block>{  <comment type="block">/* skip the header crc */</comment>
        <for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; 2</expr>;</condition> <incr><expr><name>len</name>++</expr></incr>) <expr_stmt><expr>(<name>void</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name><name>s</name>-&gt;<name>z_eof</name></name> ? <name>Z_DATA_ERROR</name> : <name>Z_OK</name></expr>;</expr_stmt>
}</block></function>

 <comment type="block">/* ===========================================================================
 * Cleanup then free the given gz_stream. Return a zlib error code.
   Try freeing in the reverse order of allocations.
 */</comment>
<function><type><name>local</name> <name>int</name></type> <name>destroy</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>Z_OK</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>state</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_GZCOMPRESS</name></cpp:ifdef>
            <expr_stmt><expr><name>err</name> = <name>Z_STREAM_ERROR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>err</name> = <call><name>deflateEnd</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'r'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>err</name> = <call><name>inflateEnd</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>file</name></name> != <name>NULL</name> &amp;&amp; <call><name>fclose</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ESPIPE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>errno</name> != <name>ESPIPE</name></expr>)</condition><then> <comment type="block">/* fclose is broken for pipes in HP/UX */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>err</name> = <name>Z_ERRNO</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> &lt; 0</expr>)</condition><then> <expr_stmt><expr><name>err</name> = <name><name>s</name>-&gt;<name>z_err</name></name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Reads the given number of uncompressed bytes from the compressed file.
   gzread returns the number of bytes actually read (0 for end of file).
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzread</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>voidp</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bytef</name> *</type><name>start</name> <init>= <expr>(<name>Bytef</name>*)<name>buf</name></expr></init></decl>;</decl_stmt> <comment type="block">/* starting point for crc computation */</comment>
    <decl_stmt><decl><type><name>Byte</name>  *</type><name>next_out</name></decl>;</decl_stmt> <comment type="block">/* == stream.next_out but not forced far (for MSDOS) */</comment>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r'</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_DATA_ERROR</name> || <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_ERRNO</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>  <comment type="block">/* EOF */</comment>

    <expr_stmt><expr><name>next_out</name> = (<name>Byte</name>*)<name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = (<name>Bytef</name>*)<name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>len</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> &amp;&amp; <name><name>s</name>-&gt;<name>back</name></name> != <name>EOF</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>next_out</name>++ = <name><name>s</name>-&gt;<name>back</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name>--</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>start</name>++</expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>last</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_STREAM_END</name></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <while>while <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> != 0</expr>)</condition> <block>{

        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>transparent</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* Copy first the lookahead bytes: */</comment>
            <decl_stmt><decl><type><name>uInt</name></type> <name>n</name> <init>= <expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>n</name> &gt; <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>)</condition><then> <expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>next_out</name> += <name>n</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name>next_out</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name>   += <name>n</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> -= <name>n</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name>  -= <name>n</name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> -=
                    (<name>uInt</name>)<call><name>fread</name><argument_list>(<argument><expr><name>next_out</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>len</name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name>  += <name>len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> += <name>len</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 1</expr>;</expr_stmt></then></if>
            <return>return <expr>(<name>int</name>)<name>len</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> == 0 &amp;&amp; !<name><name>s</name>-&gt;<name>z_eof</name></name></expr>)</condition><then> <block>{

            <expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = (<name>uInt</name>)<call><name>fread</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 1</expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <call><name>inflate</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name></expr>)</condition><then> <block>{
            <comment type="block">/* Check CRC and original size */</comment>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>crc</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> - <name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>start</name> = <name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name>getLong</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> != <name><name>s</name>-&gt;<name>crc</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_DATA_ERROR</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr>(<name>void</name>)<call><name>getLong</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* The uncompressed length returned by above getlong() may be
                 * different from s-&gt;out in case of concatenated .gz files.
                 * Check for such files:
                 */</comment>
                <expr_stmt><expr><call><name>check_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_OK</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>inflateReset</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_OK</name> || <name><name>s</name>-&gt;<name>z_eof</name></name></expr>)</condition><then> <break>break;</break></then></if>
    }</block></while>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>crc</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> - <name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>len</name> == <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> &amp;&amp;
        (<name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_DATA_ERROR</name> || <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_ERRNO</name>)</expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
    <return>return <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>len</name> - <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* ===========================================================================
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzgetc</name><parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

    <return>return <expr><call><name>gzread</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 1 ? <name>c</name> : -1</expr>;</return>
}</block></function>


<comment type="block">/* ===========================================================================
      Push one byte back onto the stream.
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzungetc</name><parameter_list>(<param><decl><type><name>c</name></type></decl></param>, <param><decl><type><name>file</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r' || <name>c</name> == <name>EOF</name> || <name><name>s</name>-&gt;<name>back</name></name> != <name>EOF</name></expr>)</condition><then> <return>return <expr><name>EOF</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name>--</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>last</name></name> = (<name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>last</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>c</name></expr>;</return>
}</block></function>


<comment type="block">/* ===========================================================================
      Reads bytes from the compressed file until len-1 characters are
   read, or a newline character is read and transferred to buf, or an
   end-of-file condition is encountered.  The string is then terminated
   with a null character.
      gzgets returns buf, or Z_NULL in case of error.

      The current implementation is not optimized at all.
*/</comment>
<function><type><name>char</name> * <name>ZEXPORT</name></type> <name>gzgets</name><parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>b</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>buf</name> == <name>Z_NULL</name> || <name>len</name> &lt;= 0</expr>)</condition><then> <return>return <expr><name>Z_NULL</name></expr>;</return></then></if>

    <while>while <condition>(<expr>--<name>len</name> &gt; 0 &amp;&amp; <call><name>gzread</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 1 &amp;&amp; *<name>buf</name>++ != '\n'</expr>)</condition> <empty_stmt>;</empty_stmt></while>
    <expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><name>b</name> == <name>buf</name> &amp;&amp; <name>len</name> &gt; 0 ? <name>Z_NULL</name> : <name>b</name></expr>;</return>
}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_GZCOMPRESS</name></cpp:ifndef>
<comment type="block">/* ===========================================================================
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of bytes actually written (0 in case of error).
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzwrite</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>voidpc</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'w'</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = (<name>Bytef</name>*)<name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = <name>len</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> != 0</expr>)</condition> <block>{

        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> == 0</expr>)</condition><then> <block>{

            <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call> != <name>Z_BUFSIZE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>Z_BUFSIZE</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <call><name>deflate</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_OK</name></expr>)</condition><then> <break>break;</break></then></if>
    }</block></while>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>crc</name></name></expr></argument>, <argument><expr>(const <name>Bytef</name> *)<name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>len</name> - <name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* ===========================================================================
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STDC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<function><type><name>int</name> <name>ZEXPORTVA</name></type> <name>gzprintf</name> <parameter_list>(<param><decl><type><name>gzFile</name></type> <name>file</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <comment type="block">/* args */</comment> <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>Z_PRINTF_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_vsnprintf</name></cpp:ifdef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>HAS_vsprintf_void</name></cpp:ifdef>
    <expr_stmt><expr>(<name>void</name>)<call><name>vsprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>)
        <if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> == 0</expr>)</condition><then> <break>break;</break></then></if></for>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>len</name> = <call><name>vsprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>HAS_vsnprintf_void</name></cpp:ifdef>
    <expr_stmt><expr>(<name>void</name>)<call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>len</name> = <call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>len</name> &lt;= 0 || <name>len</name> &gt;= (<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> || <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> != 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <return>return <expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>unsigned</name>)<name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* not ANSI C */</comment>

<function><type><name>int</name> <name>ZEXPORTVA</name></type> <name>gzprintf</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>format</name></type></decl></param>, <param><decl><type><name>a1</name></type></decl></param>, <param><decl><type><name>a2</name></type></decl></param>, <param><decl><type><name>a3</name></type></decl></param>, <param><decl><type><name>a4</name></type></decl></param>, <param><decl><type><name>a5</name></type></decl></param>, <param><decl><type><name>a6</name></type></decl></param>, <param><decl><type><name>a7</name></type></decl></param>, <param><decl><type><name>a8</name></type></decl></param>, <param><decl><type><name>a9</name></type></decl></param>, <param><decl><type><name>a10</name></type></decl></param>,
                       <param><decl><type><name>a11</name></type></decl></param>, <param><decl><type><name>a12</name></type></decl></param>, <param><decl><type><name>a13</name></type></decl></param>, <param><decl><type><name>a14</name></type></decl></param>, <param><decl><type><name>a15</name></type></decl></param>, <param><decl><type><name>a16</name></type></decl></param>, <param><decl><type><name>a17</name></type></decl></param>, <param><decl><type><name>a18</name></type></decl></param>, <param><decl><type><name>a19</name></type></decl></param>, <param><decl><type><name>a20</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>a1</name></decl>, <decl><type ref="prev"/><name>a2</name></decl>, <decl><type ref="prev"/><name>a3</name></decl>, <decl><type ref="prev"/><name>a4</name></decl>, <decl><type ref="prev"/><name>a5</name></decl>, <decl><type ref="prev"/><name>a6</name></decl>, <decl><type ref="prev"/><name>a7</name></decl>, <decl><type ref="prev"/><name>a8</name></decl>, <decl><type ref="prev"/><name>a9</name></decl>, <decl><type ref="prev"/><name>a10</name></decl>,
        <decl><type ref="prev"/><name>a11</name></decl>, <decl><type ref="prev"/><name>a12</name></decl>, <decl><type ref="prev"/><name>a13</name></decl>, <decl><type ref="prev"/><name>a14</name></decl>, <decl><type ref="prev"/><name>a15</name></decl>, <decl><type ref="prev"/><name>a16</name></decl>, <decl><type ref="prev"/><name>a17</name></decl>, <decl><type ref="prev"/><name>a18</name></decl>, <decl><type ref="prev"/><name>a19</name></decl>, <decl><type ref="prev"/><name>a20</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>Z_PRINTF_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_snprintf</name></cpp:ifdef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>HAS_sprintf_void</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>, <argument><expr><name>a5</name></expr></argument>, <argument><expr><name>a6</name></expr></argument>, <argument><expr><name>a7</name></expr></argument>, <argument><expr><name>a8</name></expr></argument>,
            <argument><expr><name>a9</name></expr></argument>, <argument><expr><name>a10</name></expr></argument>, <argument><expr><name>a11</name></expr></argument>, <argument><expr><name>a12</name></expr></argument>, <argument><expr><name>a13</name></expr></argument>, <argument><expr><name>a14</name></expr></argument>, <argument><expr><name>a15</name></expr></argument>, <argument><expr><name>a16</name></expr></argument>, <argument><expr><name>a17</name></expr></argument>, <argument><expr><name>a18</name></expr></argument>, <argument><expr><name>a19</name></expr></argument>, <argument><expr><name>a20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name>len</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>)
        <if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> == 0</expr>)</condition><then> <break>break;</break></then></if></for>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>len</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>, <argument><expr><name>a5</name></expr></argument>, <argument><expr><name>a6</name></expr></argument>, <argument><expr><name>a7</name></expr></argument>, <argument><expr><name>a8</name></expr></argument>,
                <argument><expr><name>a9</name></expr></argument>, <argument><expr><name>a10</name></expr></argument>, <argument><expr><name>a11</name></expr></argument>, <argument><expr><name>a12</name></expr></argument>, <argument><expr><name>a13</name></expr></argument>, <argument><expr><name>a14</name></expr></argument>, <argument><expr><name>a15</name></expr></argument>, <argument><expr><name>a16</name></expr></argument>, <argument><expr><name>a17</name></expr></argument>, <argument><expr><name>a18</name></expr></argument>, <argument><expr><name>a19</name></expr></argument>, <argument><expr><name>a20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>HAS_snprintf_void</name></cpp:ifdef>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>, <argument><expr><name>a5</name></expr></argument>, <argument><expr><name>a6</name></expr></argument>, <argument><expr><name>a7</name></expr></argument>, <argument><expr><name>a8</name></expr></argument>,
             <argument><expr><name>a9</name></expr></argument>, <argument><expr><name>a10</name></expr></argument>, <argument><expr><name>a11</name></expr></argument>, <argument><expr><name>a12</name></expr></argument>, <argument><expr><name>a13</name></expr></argument>, <argument><expr><name>a14</name></expr></argument>, <argument><expr><name>a15</name></expr></argument>, <argument><expr><name>a16</name></expr></argument>, <argument><expr><name>a17</name></expr></argument>, <argument><expr><name>a18</name></expr></argument>, <argument><expr><name>a19</name></expr></argument>, <argument><expr><name>a20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>len</name> = <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>, <argument><expr><name>a4</name></expr></argument>, <argument><expr><name>a5</name></expr></argument>, <argument><expr><name>a6</name></expr></argument>, <argument><expr><name>a7</name></expr></argument>, <argument><expr><name>a8</name></expr></argument>,
                 <argument><expr><name>a9</name></expr></argument>, <argument><expr><name>a10</name></expr></argument>, <argument><expr><name>a11</name></expr></argument>, <argument><expr><name>a12</name></expr></argument>, <argument><expr><name>a13</name></expr></argument>, <argument><expr><name>a14</name></expr></argument>, <argument><expr><name>a15</name></expr></argument>, <argument><expr><name>a16</name></expr></argument>, <argument><expr><name>a17</name></expr></argument>, <argument><expr><name>a18</name></expr></argument>, <argument><expr><name>a19</name></expr></argument>, <argument><expr><name>a20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>len</name> &lt;= 0 || <name>len</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> || <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> != 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <return>return <expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzputc</name><parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>c</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cc</name> <init>= <expr>(<name>unsigned</name> <name>char</name>) <name>c</name></expr></init></decl>;</decl_stmt> <comment type="block">/* required for big endian systems */</comment>

    <return>return <expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>&amp;<name>cc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> == 1 ? (<name>int</name>)<name>cc</name> : -1</expr>;</return>
}</block></function>


<comment type="block">/* ===========================================================================
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzputs</name><parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <return>return <expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>s</name></expr></argument>, <argument><expr>(<name>unsigned</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* ===========================================================================
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function.
*/</comment>
<function><type><name>local</name> <name>int</name></type> <name>do_flush</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>uInt</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'w'</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = 0</expr>;</expr_stmt> <comment type="block">/* should be zero already anyway */</comment>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name>len</name> = <name>Z_BUFSIZE</name> - <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>len</name> != 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name>uInt</name>)<call><name>fwrite</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call> != <name>len</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_ERRNO</name></expr>;</expr_stmt>
                <return>return <expr><name>Z_ERRNO</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_out</name></name> = <name><name>s</name>-&gt;<name>outbuf</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> = <name>Z_BUFSIZE</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>done</name></expr>)</condition><then> <break>break;</break></then></if>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> += <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <call><name>deflate</name><argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>stream</name></name>)</expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> -= <name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name></expr>;</expr_stmt>

        <comment type="block">/* Ignore the second of two consecutive flushes: */</comment>
        <if>if <condition>(<expr><name>len</name> == 0 &amp;&amp; <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_BUF_ERROR</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt></then></if>

        <comment type="block">/* deflate has finished flushing only when it hasn't used up
         * all the available space in the output buffer:
         */</comment>
        <expr_stmt><expr><name>done</name> = (<name><name>s</name>-&gt;<name>stream</name>.<name>avail_out</name></name> != 0 || <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name>)</expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_OK</name> &amp;&amp; <name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_STREAM_END</name></expr>)</condition><then> <break>break;</break></then></if>
    }</block></for>
    <return>return  <expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name> ? <name>Z_OK</name> : <name><name>s</name>-&gt;<name>z_err</name></name></expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzflush</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
     <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>do_flush</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <return>return <expr><name>err</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return  <expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name> ? <name>Z_OK</name> : <name><name>s</name>-&gt;<name>z_err</name></name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_GZCOMPRESS */</comment>

<comment type="block">/* ===========================================================================
      Sets the starting position for the next gzread or gzwrite on the given
   compressed file. The offset represents a number of bytes in the
      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error.
      SEEK_END is not implemented, returns error.
      In this version of the library, gzseek can be extremely slow.
*/</comment>
<function><type><name>z_off_t</name> <name>ZEXPORT</name></type> <name>gzseek</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>offset</name></type></decl></param>, <param><decl><type><name>whence</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>whence</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name>whence</name> == <name>SEEK_END</name> ||
        <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_ERRNO</name> || <name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_DATA_ERROR</name></expr>)</condition><then> <block>{
        <return>return <expr>-1L</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_GZCOMPRESS</name></cpp:ifdef>
        <return>return <expr>-1L</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if>if <condition>(<expr><name>whence</name> == <name>SEEK_SET</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>offset</name> -= <name><name>s</name>-&gt;<name>in</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>

        <comment type="block">/* At this point, offset is the number of zero bytes to write. */</comment>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>inbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>inbuf</name></name> = (<name>Byte</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* for seeking */</comment>
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>inbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
            <expr_stmt><expr><call><name>zmemzero</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>, <argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <while>while <condition>(<expr><name>offset</name> &gt; 0</expr>)</condition>  <block>{
            <decl_stmt><decl><type><name>uInt</name></type> <name>size</name> <init>= <expr><name>Z_BUFSIZE</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>offset</name> &lt; <name>Z_BUFSIZE</name></expr>)</condition><then> <expr_stmt><expr><name>size</name> = (<name>uInt</name>)<name>offset</name></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><name>size</name> = <call><name>gzwrite</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>inbuf</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>

            <expr_stmt><expr><name>offset</name> -= <name>size</name></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><name><name>s</name>-&gt;<name>in</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <comment type="block">/* Rest of function is for reading only */</comment>

    <comment type="block">/* compute absolute position */</comment>
    <if>if <condition>(<expr><name>whence</name> == <name>SEEK_CUR</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>offset</name> += <name><name>s</name>-&gt;<name>out</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>transparent</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* map to fseek */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>

        <expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> = <name><name>s</name>-&gt;<name>out</name></name> = <name>offset</name></expr>;</expr_stmt>
        <return>return <expr><name>offset</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* For a negative seek, rewind and use positive seek */</comment>
    <if>if <condition>(<expr><name>offset</name> &gt;= <name><name>s</name>-&gt;<name>out</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>offset</name> -= <name><name>s</name>-&gt;<name>out</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>gzrewind</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <return>return <expr>-1L</expr>;</return>
    }</block></then></if></else></if>
    <comment type="block">/* offset is now the number of bytes to skip. */</comment>

    <if>if <condition>(<expr><name>offset</name> != 0 &amp;&amp; <name><name>s</name>-&gt;<name>outbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>outbuf</name></name> = (<name>Byte</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><name>Z_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>outbuf</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>offset</name> &amp;&amp; <name><name>s</name>-&gt;<name>back</name></name> != <name>EOF</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name>--</expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>last</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_STREAM_END</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <while>while <condition>(<expr><name>offset</name> &gt; 0</expr>)</condition>  <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name>Z_BUFSIZE</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>offset</name> &lt; <name>Z_BUFSIZE</name></expr>)</condition><then> <expr_stmt><expr><name>size</name> = (<name>int</name>)<name>offset</name></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><name>size</name> = <call><name>gzread</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>outbuf</name></name></expr></argument>, <argument><expr>(<name>uInt</name>)<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>size</name> &lt;= 0</expr>)</condition><then> <return>return <expr>-1L</expr>;</return></then></if>
        <expr_stmt><expr><name>offset</name> -= <name>size</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name><name>s</name>-&gt;<name>out</name></name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Rewinds input file.
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzrewind</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r'</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>back</name></name> = <name>EOF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>avail_in</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>stream</name>.<name>next_in</name></name> = <name><name>s</name>-&gt;<name>inbuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>crc</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>s</name>-&gt;<name>transparent</name></name></expr>)</condition><then> <expr_stmt><expr>(<name>void</name>)<call><name>inflateReset</name><argument_list>(<argument><expr>&amp;<name><name>s</name>-&gt;<name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>in</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>out</name></name> = 0</expr>;</expr_stmt>
    <return>return <expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.
*/</comment>
<function><type><name>z_off_t</name> <name>ZEXPORT</name></type> <name>gztell</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
    <return>return <expr><call><name>gzseek</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>0L</expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzeof</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* With concatenated compressed files that can have embedded
     * crc trailers, z_eof is no longer the only/best indicator of EOF
     * on a gz_stream. Handle end-of-stream error explicitly here.
     */</comment>
    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r'</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_eof</name></name></expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
    <return>return <expr><name><name>s</name>-&gt;<name>z_err</name></name> == <name>Z_STREAM_END</name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Returns 1 if reading and doing so transparently, otherwise zero.
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzdirect</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name> || <name><name>s</name>-&gt;<name>mode</name></name> != 'r'</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <return>return <expr><name><name>s</name>-&gt;<name>transparent</name></name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
   Outputs a long in LSB order to the given file
*/</comment>
<function><type><name>local</name> <name>void</name></type> <name>putLong</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>x</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>FILE</name> *</type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uLong</name></type> <name>x</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; 4</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>x</name> &amp; 0xff</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> &gt;&gt;= 8</expr>;</expr_stmt>
    }</block></for>
}</block></function>

<comment type="block">/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets z_err in case
   of error.
*/</comment>
<function><type><name>local</name> <name>uLong</name></type> <name>getLong</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>uLong</name></type> <name>x</name> <init>= <expr>(<name>uLong</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> += ((<name>uLong</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)&lt;&lt;8</expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> += ((<name>uLong</name>)<call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)&lt;&lt;16</expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> = <call><name>get_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>c</name> == <name>EOF</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_DATA_ERROR</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>x</name> += ((<name>uLong</name>)<name>c</name>)&lt;&lt;24</expr>;</expr_stmt>
    <return>return <expr><name>x</name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state.
*/</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzclose</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mode</name></name> == 'w'</expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_GZCOMPRESS</name></cpp:ifdef>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if>if <condition>(<expr><call><name>do_flush</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call> != <name>Z_OK</name></expr>)</condition><then>
            <return>return <expr><call><name>destroy</name><argument_list>(<argument><expr>(<name>gz_stream</name>*)<name>file</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <expr_stmt><expr><call><name>putLong</name> <argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>putLong</name> <argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><call>(<name>uLong</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>in</name></name> &amp; 0xffffffff</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <return>return <expr><call><name>destroy</name><argument_list>(<argument><expr>(<name>gz_stream</name>*)<name>file</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STDC</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>zstrerror</name><parameter_list>(<param><type><name>errnum</name></type></param>)</parameter_list></cpp:macro> <cpp:value>strerror(errnum)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>zstrerror</name><parameter_list>(<param><type><name>errnum</name></type></param>)</parameter_list></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> * <name>ZEXPORT</name></type> <name>gzerror</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>, <param><decl><type><name>errnum</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> *</type><name>errnum</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>errnum</name> = <name>Z_STREAM_ERROR</name></expr>;</expr_stmt>
        <return>return <expr>(const <name>char</name>*)<call><name>ERR_MSG</name><argument_list>(<argument><expr><name>Z_STREAM_ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>errnum</name> = <name><name>s</name>-&gt;<name>z_err</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>errnum</name> == <name>Z_OK</name></expr>)</condition><then> <return>return <expr>(const <name>char</name>*)""</expr>;</return></then></if>

    <expr_stmt><expr><name>m</name> = <call>(<name>char</name>*)<argument_list>(<argument><expr>*<name>errnum</name> == <name>Z_ERRNO</name> ? <call><name>zstrerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call> : <name><name>s</name>-&gt;<name>stream</name>.<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>m</name> == <name>NULL</name> || *<name>m</name> == '\0'</expr>)</condition><then> <expr_stmt><expr><name>m</name> = (<name>char</name>*)<call><name>ERR_MSG</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>z_err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>TRYFREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>msg</name></name> = (<name>char</name>*)<call><name>ALLOC</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> + 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>msg</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr>(const <name>char</name>*)<call><name>ERR_MSG</name><argument_list>(<argument><expr><name>Z_MEM_ERROR</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>, <argument><expr>": "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>msg</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(const <name>char</name>*)<name><name>s</name>-&gt;<name>msg</name></name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
     Clear the error and end-of-file flags, and do the same for the real file.
*/</comment>
<function><type><name>void</name> <name>ZEXPORT</name></type> <name>gzclearerr</name> <parameter_list>(<param><decl><type><name>file</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>gz_stream</name> *</type><name>s</name> <init>= <expr>(<name>gz_stream</name>*)<name>file</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <return>return;</return></then></if>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>z_err</name></name> != <name>Z_STREAM_END</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>z_err</name></name> = <name>Z_OK</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>z_eof</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
