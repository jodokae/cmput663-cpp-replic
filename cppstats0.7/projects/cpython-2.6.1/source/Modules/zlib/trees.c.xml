<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/zlib/trees.c"><comment type="block">/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2005 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</comment>

<comment type="block">/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */</comment>

<comment type="block">/* @(#) $Id$ */</comment>

<comment type="block">/* #define GEN_TREES_H */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deflate.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Constants
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BL_BITS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<comment type="block">/* Bit length codes must not exceed MAX_BL_BITS bits */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_BLOCK</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<comment type="block">/* end of block literal code */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REP_3_6</name></cpp:macro>      <cpp:value>16</cpp:value></cpp:define>
<comment type="block">/* repeat previous bit length 3-6 times (2 bits of repeat count) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPZ_3_10</name></cpp:macro>    <cpp:value>17</cpp:value></cpp:define>
<comment type="block">/* repeat a zero length 3-10 times  (3 bits of repeat count) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPZ_11_138</name></cpp:macro>  <cpp:value>18</cpp:value></cpp:define>
<comment type="block">/* repeat a zero length 11-138 times  (7 bits of repeat count) */</comment>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_lbits</name><index>[<expr><name>LENGTH_CODES</name></expr>]</index></name> <comment type="block">/* extra bits for each length code */</comment>
   <init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>1</expr>,<expr>1</expr>,<expr>1</expr>,<expr>1</expr>,<expr>2</expr>,<expr>2</expr>,<expr>2</expr>,<expr>2</expr>,<expr>3</expr>,<expr>3</expr>,<expr>3</expr>,<expr>3</expr>,<expr>4</expr>,<expr>4</expr>,<expr>4</expr>,<expr>4</expr>,<expr>5</expr>,<expr>5</expr>,<expr>5</expr>,<expr>5</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_dbits</name><index>[<expr><name>D_CODES</name></expr>]</index></name> <comment type="block">/* extra bits for each distance code */</comment>
   <init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>1</expr>,<expr>1</expr>,<expr>2</expr>,<expr>2</expr>,<expr>3</expr>,<expr>3</expr>,<expr>4</expr>,<expr>4</expr>,<expr>5</expr>,<expr>5</expr>,<expr>6</expr>,<expr>6</expr>,<expr>7</expr>,<expr>7</expr>,<expr>8</expr>,<expr>8</expr>,<expr>9</expr>,<expr>9</expr>,<expr>10</expr>,<expr>10</expr>,<expr>11</expr>,<expr>11</expr>,<expr>12</expr>,<expr>12</expr>,<expr>13</expr>,<expr>13</expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>int</name></type> <name><name>extra_blbits</name><index>[<expr><name>BL_CODES</name></expr>]</index></name><comment type="block">/* extra bits for each bit length code */</comment>
   <init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>2</expr>,<expr>3</expr>,<expr>7</expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>uch</name></type> <name><name>bl_order</name><index>[<expr><name>BL_CODES</name></expr>]</index></name>
   <init>= <expr><block>{<expr>16</expr>,<expr>17</expr>,<expr>18</expr>,<expr>0</expr>,<expr>8</expr>,<expr>7</expr>,<expr>9</expr>,<expr>6</expr>,<expr>10</expr>,<expr>5</expr>,<expr>11</expr>,<expr>4</expr>,<expr>12</expr>,<expr>3</expr>,<expr>13</expr>,<expr>2</expr>,<expr>14</expr>,<expr>1</expr>,<expr>15</expr>}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Buf_size</name></cpp:macro> <cpp:value>(8 * 2*sizeof(char))</cpp:value></cpp:define>
<comment type="block">/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */</comment>

<comment type="block">/* ===========================================================================
 * Local data. These are initialized only once.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIST_CODE_LEN</name></cpp:macro>  <cpp:value>512</cpp:value></cpp:define> <comment type="block">/* see definition of array dist_code below */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* non ANSI compilers may not accept trees.h */</comment>

<decl_stmt><decl><type><name>local</name> <name>ct_data</name></type> <name><name>static_ltree</name><index>[<expr><name>L_CODES</name>+2</expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */</comment>

<decl_stmt><decl><type><name>local</name> <name>ct_data</name></type> <name><name>static_dtree</name><index>[<expr><name>D_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */</comment>

<decl_stmt><decl><type><name>uch</name></type> <name><name>_dist_code</name><index>[<expr><name>DIST_CODE_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */</comment>

<decl_stmt><decl><type><name>uch</name></type> <name><name>_length_code</name><index>[<expr><name>MAX_MATCH</name>-<name>MIN_MATCH</name>+1</expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* length code for each normalized match length (0 == MIN_MATCH) */</comment>

<decl_stmt><decl><type><name>local</name> <name>int</name></type> <name><name>base_length</name><index>[<expr><name>LENGTH_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* First normalized length for each code (0 = MIN_MATCH) */</comment>

<decl_stmt><decl><type><name>local</name> <name>int</name></type> <name><name>base_dist</name><index>[<expr><name>D_CODES</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* First normalized distance for each code (0 = distance of 1) */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"trees.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* GEN_TREES_H */</comment>

<struct>struct <name>static_tree_desc_s</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> *</type><name>static_tree</name></decl>;</decl_stmt>  <comment type="block">/* static tree or NULL */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>intf</name> *</type><name>extra_bits</name></decl>;</decl_stmt>      <comment type="block">/* extra bits for each code or NULL */</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>extra_base</name></decl>;</decl_stmt>          <comment type="block">/* base index for extra_bits */</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>elems</name></decl>;</decl_stmt>               <comment type="block">/* max number of elements in the tree */</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>max_length</name></decl>;</decl_stmt>          <comment type="block">/* max bit length for the codes */</comment>
}</block>;</struct>

<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type>  <name>static_l_desc</name> <init>=
<expr><block>{<expr><name>static_ltree</name></expr>, <expr><name>extra_lbits</name></expr>, <expr><name>LITERALS</name>+1</expr>, <expr><name>L_CODES</name></expr>, <expr><name>MAX_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type>  <name>static_d_desc</name> <init>=
<expr><block>{<expr><name>static_dtree</name></expr>, <expr><name>extra_dbits</name></expr>, <expr>0</expr>,          <expr><name>D_CODES</name></expr>, <expr><name>MAX_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>static_tree_desc</name></type>  <name>static_bl_desc</name> <init>=
<expr><block>{<expr>(const <name>ct_data</name> *)0</expr>, <expr><name>extra_blbits</name></expr>, <expr>0</expr>,   <expr><name>BL_CODES</name></expr>, <expr><name>MAX_BL_BITS</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ===========================================================================
 * Local (static) routines in this file.
 */</comment>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>tr_static_init</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>init_block</name></type>     <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>pqdownheap</name></type>     <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>ct_data</name> *<name>tree</name>, <name>int</name> <name>k</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_bitlen</name></type>     <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>tree_desc</name> *<name>desc</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_codes</name></type>      <name>OF</name><argument_list>(<argument><expr>(<name>ct_data</name> *<name>tree</name>, <name>int</name> <name>max_code</name>, <name>ushf</name> *<name>bl_count</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>build_tree</name></type>     <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>tree_desc</name> *<name>desc</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>scan_tree</name></type>      <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>ct_data</name> *<name>tree</name>, <name>int</name> <name>max_code</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_tree</name></type>      <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>ct_data</name> *<name>tree</name>, <name>int</name> <name>max_code</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name>  <name>build_bl_tree</name></type>  <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_all_trees</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>lcodes</name>, <name>int</name> <name>dcodes</name>,
                              <name>int</name> <name>blcodes</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>compress_block</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>ct_data</name> *<name>ltree</name>,
                              <name>ct_data</name> *<name>dtree</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>set_data_type</name></type>  <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>unsigned</name> <name>bi_reverse</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>value</name>, <name>int</name> <name>length</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>bi_windup</name></type>      <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>bi_flush</name></type>       <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>copy_block</name></type>     <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>charf</name> *<name>buf</name>, <name>unsigned</name> <name>len</name>,
                              <name>int</name> <name>header</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEN_TREES_H</name></cpp:ifdef>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gen_trees_header</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>send_code</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>, <param><type><name>tree</name></type></param>)</parameter_list></cpp:macro> <cpp:value>send_bits(s, tree[c].Code, tree[c].Len)</cpp:value></cpp:define>
   <comment type="block">/* Send a code of the given tree. c and tree must not have side effects */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* DEBUG */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>send_code</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>c</name></type></param>, <param><type><name>tree</name></type></param>)</parameter_list></cpp:macro> \
     <cpp:value>{ if (z_verbose&gt;2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>put_short</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>w</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ \
    put_byte(s, (uch)((w) &amp; 0xff)); \
    put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); \
}</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length &lt;= 16 and value fits in length bits.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>send_bits</name></type>      <name>OF</name><argument_list>(<argument><expr>(<name>deflate_state</name> *<name>s</name>, <name>int</name> <name>value</name>, <name>int</name> <name>length</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>local</name> <name>void</name></type> <name>send_bits</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>value</name></type></decl></param>, <param><decl><type><name>length</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>  <comment type="block">/* value to send */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt> <comment type="block">/* number of bits */</comment>
<block>{
    <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>," l %2d v %4x ", <name>length</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>length</name> &gt; 0 &amp;&amp; <name>length</name> &lt;= 15</expr></argument>, <argument><expr>"invalid length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> += (<name>ulg</name>)<name>length</name></expr>;</expr_stmt>

    <comment type="block">/* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> &gt; (<name>int</name>)<name>Buf_size</name> - <name>length</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> |= (<name>value</name> &lt;&lt; <name><name>s</name>-&gt;<name>bi_valid</name></name>)</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> = (<name>ush</name>)<name>value</name> &gt;&gt; (<name>Buf_size</name> - <name><name>s</name>-&gt;<name>bi_valid</name></name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> += <name>length</name> - <name>Buf_size</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> |= <name>value</name> &lt;&lt; <name><name>s</name>-&gt;<name>bi_valid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> += <name>length</name></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !DEBUG */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>send_bits</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>value</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>{ int len = length;\
  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {\
    int val = value;\
    s-&gt;bi_buf |= (val &lt;&lt; s-&gt;bi_valid);\
    put_short(s, s-&gt;bi_buf);\
    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);\
    s-&gt;bi_valid += len - Buf_size;\
  } else {\
    s-&gt;bi_buf |= (value) &lt;&lt; s-&gt;bi_valid;\
    s-&gt;bi_valid += len;\
  }\
}</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>


<comment type="block">/* the arguments must not have side effects */</comment>

<comment type="block">/* ===========================================================================
 * Initialize the various 'constant' tables.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>tr_static_init</name><parameter_list>()</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GEN_TREES_H</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>STDC</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>static_init_done</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>        <comment type="block">/* iterates over tree elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>     <comment type="block">/* bit counter */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>   <comment type="block">/* length value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>     <comment type="block">/* code value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dist</name></decl>;</decl_stmt>     <comment type="block">/* distance index */</comment>
    <decl_stmt><decl><type><name>ush</name></type> <name><name>bl_count</name><index>[<expr><name>MAX_BITS</name>+1</expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* number of codes at each bit length for an optimal tree */</comment>

    <if>if <condition>(<expr><name>static_init_done</name></expr>)</condition><then> <return>return;</return></then></if>

    <comment type="block">/* For some embedded targets, global variables are not initialized: */</comment>
    <expr_stmt><expr><name><name>static_l_desc</name>.<name>static_tree</name></name> = <name>static_ltree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>static_l_desc</name>.<name>extra_bits</name></name> = <name>extra_lbits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>static_d_desc</name>.<name>static_tree</name></name> = <name>static_dtree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>static_d_desc</name>.<name>extra_bits</name></name> = <name>extra_dbits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>static_bl_desc</name>.<name>extra_bits</name></name> = <name>extra_blbits</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize the mapping length (0..255) -&gt; length code (0..28) */</comment>
    <expr_stmt><expr><name>length</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>code</name> = 0</expr>;</init> <condition><expr><name>code</name> &lt; <name>LENGTH_CODES</name>-1</expr>;</condition> <incr><expr><name>code</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>base_length</name><index>[<expr><name>code</name></expr>]</index></name> = <name>length</name></expr>;</expr_stmt>
        <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (1&lt;&lt;<name><name>extra_lbits</name><index>[<expr><name>code</name></expr>]</index></name>)</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>_length_code</name><index>[<expr><name>length</name>++</expr>]</index></name> = (<name>uch</name>)<name>code</name></expr>;</expr_stmt>
        }</block></for>
    }</block></for>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>length</name> == 256</expr></argument>, <argument><expr>"tr_static_init: length != 256"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */</comment>
    <expr_stmt><expr><name><name>_length_code</name><index>[<expr><name>length</name>-1</expr>]</index></name> = (<name>uch</name>)<name>code</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */</comment>
    <expr_stmt><expr><name>dist</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>code</name> = 0</expr> ;</init> <condition><expr><name>code</name> &lt; 16</expr>;</condition> <incr><expr><name>code</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name> = <name>dist</name></expr>;</expr_stmt>
        <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (1&lt;&lt;<name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name>)</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>_dist_code</name><index>[<expr><name>dist</name>++</expr>]</index></name> = (<name>uch</name>)<name>code</name></expr>;</expr_stmt>
        }</block></for>
    }</block></for>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>dist</name> == 256</expr></argument>, <argument><expr>"tr_static_init: dist != 256"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dist</name> &gt;&gt;= 7</expr>;</expr_stmt> <comment type="block">/* from now on, all distances are divided by 128 */</comment>
    <for>for ( <init>;</init> <condition><expr><name>code</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>code</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name> = <name>dist</name> &lt;&lt; 7</expr>;</expr_stmt>
        <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (1&lt;&lt;(<name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name>-7))</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>_dist_code</name><index>[<expr>256 + <name>dist</name>++</expr>]</index></name> = (<name>uch</name>)<name>code</name></expr>;</expr_stmt>
        }</block></for>
    }</block></for>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>dist</name> == 256</expr></argument>, <argument><expr>"tr_static_init: 256+dist != 512"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Construct the codes of the static literal tree */</comment>
    <for>for (<init><expr><name>bits</name> = 0</expr>;</init> <condition><expr><name>bits</name> &lt;= <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name>++</expr></incr>) <expr_stmt><expr><name><name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
    <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
    <while>while <condition>(<expr><name>n</name> &lt;= 143</expr>)</condition> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name>++</expr>]</index></name>.<name>Len</name> = 8</expr>, <expr><name><name>bl_count</name><index>[<expr>8</expr>]</index></name>++</expr>;</expr_stmt></while>
    <while>while <condition>(<expr><name>n</name> &lt;= 255</expr>)</condition> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name>++</expr>]</index></name>.<name>Len</name> = 9</expr>, <expr><name><name>bl_count</name><index>[<expr>9</expr>]</index></name>++</expr>;</expr_stmt></while>
    <while>while <condition>(<expr><name>n</name> &lt;= 279</expr>)</condition> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name>++</expr>]</index></name>.<name>Len</name> = 7</expr>, <expr><name><name>bl_count</name><index>[<expr>7</expr>]</index></name>++</expr>;</expr_stmt></while>
    <while>while <condition>(<expr><name>n</name> &lt;= 287</expr>)</condition> <expr_stmt><expr><name><name>static_ltree</name><index>[<expr><name>n</name>++</expr>]</index></name>.<name>Len</name> = 8</expr>, <expr><name><name>bl_count</name><index>[<expr>8</expr>]</index></name>++</expr>;</expr_stmt></while>
    <comment type="block">/* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */</comment>
    <expr_stmt><expr><call><name>gen_codes</name><argument_list>(<argument><expr>(<name>ct_data</name> *)<name>static_ltree</name></expr></argument>, <argument><expr><name>L_CODES</name>+1</expr></argument>, <argument><expr><name>bl_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The static distance tree is trivial: */</comment>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>static_dtree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name> = 5</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>static_dtree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Code</name> = <call><name>bi_reverse</name><argument_list>(<argument><expr>(<name>unsigned</name>)<name>n</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>static_init_done</name> = 1</expr>;</expr_stmt>

<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>GEN_TREES_H</name></cpp:ifdef>
    <expr_stmt><expr><call><name>gen_trees_header</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(GEN_TREES_H) || !defined(STDC) */</comment>
}</block></function>

<comment type="block">/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GEN_TREES_H</name></cpp:ifdef>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>DEBUG</name></cpp:ifndef>
<cpp:include>#    <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SEPARATOR</name><parameter_list>(<param><type><name>i</name></type></param>, <param><type><name>last</name></type></param>, <param><type><name>width</name></type></param>)</parameter_list></cpp:macro> \
      <cpp:value>((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>gen_trees_header</name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>FILE</name> *</type><name>header</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr>"trees.h"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>header</name> != <name>NULL</name></expr></argument>, <argument><expr>"Can't open trees.h"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
            <argument><expr>"/* header created automatically with -DGEN_TREES_H */\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"local const ct_data static_ltree[L_CODES+2] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>L_CODES</name>+2</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"{{%3u},{%3u}}%s"</expr></argument>, <argument><expr><name><name>static_ltree</name><index>[<expr><name>i</name></expr>]</index></name>.<name>Code</name></expr></argument>,
                <argument><expr><name><name>static_ltree</name><index>[<expr><name>i</name></expr>]</index></name>.<name>Len</name></expr></argument>, <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>L_CODES</name>+1</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"local const ct_data static_dtree[D_CODES] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"{{%2u},{%2u}}%s"</expr></argument>, <argument><expr><name><name>static_dtree</name><index>[<expr><name>i</name></expr>]</index></name>.<name>Code</name></expr></argument>,
                <argument><expr><name><name>static_dtree</name><index>[<expr><name>i</name></expr>]</index></name>.<name>Len</name></expr></argument>, <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>D_CODES</name>-1</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"const uch _dist_code[DIST_CODE_LEN] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>DIST_CODE_LEN</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"%2u%s"</expr></argument>, <argument><expr><name><name>_dist_code</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>DIST_CODE_LEN</name>-1</expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_MATCH</name>-<name>MIN_MATCH</name>+1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"%2u%s"</expr></argument>, <argument><expr><name><name>_length_code</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>MAX_MATCH</name>-<name>MIN_MATCH</name></expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"local const int base_length[LENGTH_CODES] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>LENGTH_CODES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"%1u%s"</expr></argument>, <argument><expr><name><name>base_length</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>LENGTH_CODES</name>-1</expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"local const int base_dist[D_CODES] = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"%5u%s"</expr></argument>, <argument><expr><name><name>base_dist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><call><name>SEPARATOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>D_CODES</name>-1</expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* GEN_TREES_H */</comment>

<comment type="block">/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */</comment>
<function><type><name>void</name></type> <name>_tr_init</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <expr_stmt><expr><call><name>tr_static_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>l_desc</name>.<name>dyn_tree</name></name> = <name><name>s</name>-&gt;<name>dyn_ltree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>l_desc</name>.<name>stat_desc</name></name> = &amp;<name>static_l_desc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>d_desc</name>.<name>dyn_tree</name></name> = <name><name>s</name>-&gt;<name>dyn_dtree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>d_desc</name>.<name>stat_desc</name></name> = &amp;<name>static_d_desc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_desc</name>.<name>dyn_tree</name></name> = <name><name>s</name>-&gt;<name>bl_tree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_desc</name>.<name>stat_desc</name></name> = &amp;<name>static_bl_desc</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>last_eob_len</name></name> = 8</expr>;</expr_stmt> <comment type="block">/* enough lookahead for inflate */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> = 0L</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Initialize the first block of the first file: */</comment>
    <expr_stmt><expr><call><name>init_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ===========================================================================
 * Initialize a new block.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>init_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt> <comment type="block">/* iterates over tree elements */</comment>

    <comment type="block">/* Initialize the trees. */</comment>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>L_CODES</name></expr>;</condition>  <incr><expr><name>n</name>++</expr></incr>) <expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> = 0</expr>;</expr_stmt></for>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>D_CODES</name></expr>;</condition>  <incr><expr><name>n</name>++</expr></incr>) <expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_dtree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> = 0</expr>;</expr_stmt></for>
    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>BL_CODES</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> = 0</expr>;</expr_stmt></for>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>END_BLOCK</name></expr>]</index></name>.<name>Freq</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name> = <name><name>s</name>-&gt;<name>static_len</name></name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>last_lit</name></name> = <name><name>s</name>-&gt;<name>matches</name></name> = 0</expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLEST</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/* Index within the heap array of least frequent node in the Huffman tree */</comment>


<comment type="block">/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pqremove</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>tree</name></type></param>, <param><type><name>top</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>{\
    top = s-&gt;heap[SMALLEST]; \
    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>smaller</name><parameter_list>(<param><type><name>tree</name></type></param>, <param><type><name>n</name></type></param>, <param><type><name>m</name></type></param>, <param><type><name>depth</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>(tree[n].Freq &lt; tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))</cpp:value></cpp:define>

<comment type="block">/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>pqdownheap</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>tree</name></type></decl></param>, <param><decl><type><name>k</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name></decl>;</decl_stmt>  <comment type="block">/* the tree to restore */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>               <comment type="block">/* node to move down */</comment>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>k</name> &lt;&lt; 1</expr></init></decl>;</decl_stmt>  <comment type="block">/* left son of k */</comment>
    <while>while <condition>(<expr><name>j</name> &lt;= <name><name>s</name>-&gt;<name>heap_len</name></name></expr>)</condition> <block>{
        <comment type="block">/* Set j to the smallest of the two sons: */</comment>
        <if>if <condition>(<expr><name>j</name> &lt; <name><name>s</name>-&gt;<name>heap_len</name></name> &amp;&amp;
            <call><name>smaller</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>j</name>+1</expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>depth</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/* Exit if v is smaller than both sons */</comment>
        <if>if <condition>(<expr><call><name>smaller</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>depth</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if>

        <comment type="block">/* Exchange v with the smallest son */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>k</name></expr>]</index></name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>  <expr_stmt><expr><name>k</name> = <name>j</name></expr>;</expr_stmt>

        <comment type="block">/* And continue down the tree, setting j to the left son of k */</comment>
        <expr_stmt><expr><name>j</name> &lt;&lt;= 1</expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>k</name></expr>]</index></name> = <name>v</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>gen_bitlen</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>desc</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tree_desc</name> *</type><name>desc</name></decl>;</decl_stmt>    <comment type="block">/* the tree descriptor */</comment>
<block>{
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name>        <init>= <expr><name><name>desc</name>-&gt;<name>dyn_tree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name>         <init>= <expr><name><name>desc</name>-&gt;<name>max_code</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> *</type><name>stree</name> <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>static_tree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>intf</name> *</type><name>extra</name>    <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>extra_bits</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>base</name>             <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>extra_base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_length</name>       <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>max_length</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>              <comment type="block">/* heap index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>           <comment type="block">/* iterate over the tree elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>           <comment type="block">/* bit length */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>xbits</name></decl>;</decl_stmt>          <comment type="block">/* extra bits */</comment>
    <decl_stmt><decl><type><name>ush</name></type> <name>f</name></decl>;</decl_stmt>              <comment type="block">/* frequency */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>overflow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* number of elements with bit length too large */</comment>

    <for>for (<init><expr><name>bits</name> = 0</expr>;</init> <condition><expr><name>bits</name> &lt;= <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name>++</expr></incr>) <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>

    <comment type="block">/* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */</comment>
    <expr_stmt><expr><name><name>tree</name><index>[<expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name><name>s</name>-&gt;<name>heap_max</name></name></expr>]</index></name></expr>]</index></name>.<name>Len</name> = 0</expr>;</expr_stmt> <comment type="block">/* root of the heap */</comment>

    <for>for (<init><expr><name>h</name> = <name><name>s</name>-&gt;<name>heap_max</name></name>+1</expr>;</init> <condition><expr><name>h</name> &lt; <name>HEAP_SIZE</name></expr>;</condition> <incr><expr><name>h</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = <name><name>tree</name><index>[<expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Dad</name></expr>]</index></name>.<name>Len</name> + 1</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>bits</name> &gt; <name>max_length</name></expr>)</condition><then> <expr_stmt><expr><name>bits</name> = <name>max_length</name></expr>, <expr><name>overflow</name>++</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name> = (<name>ush</name>)<name>bits</name></expr>;</expr_stmt>
        <comment type="block">/* We overwrite tree[n].Dad which is no longer needed */</comment>

        <if>if <condition>(<expr><name>n</name> &gt; <name>max_code</name></expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="block">/* not a leaf node */</comment>

        <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>xbits</name> = 0</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>n</name> &gt;= <name>base</name></expr>)</condition><then> <expr_stmt><expr><name>xbits</name> = <name><name>extra</name><index>[<expr><name>n</name>-<name>base</name></expr>]</index></name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>f</name> = <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name> += (<name>ulg</name>)<call><name>f</name> * <argument_list>(<argument><expr><name>bits</name> + <name>xbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>stree</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>static_len</name></name> += (<name>ulg</name>)<call><name>f</name> * <argument_list>(<argument><expr><name><name>stree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name> + <name>xbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>overflow</name> == 0</expr>)</condition><then> <return>return;</return></then></if>

    <expr_stmt><expr><call><name>Trace</name><argument_list>(<argument><expr>(<name>stderr</name>,"\nbit length overflow\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* This happens for example on obj2 and pic of the Calgary corpus */</comment>

    <comment type="block">/* Find the first bit length which could increase: */</comment>
    <do>do <block>{
        <expr_stmt><expr><name>bits</name> = <name>max_length</name>-1</expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name> == 0</expr>)</condition> <expr_stmt><expr><name>bits</name>--</expr>;</expr_stmt></while>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name>--</expr>;</expr_stmt>      <comment type="block">/* move one leaf down the tree */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name>+1</expr>]</index></name> += 2</expr>;</expr_stmt> <comment type="block">/* move one overflow item as its brother */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>max_length</name></expr>]</index></name>--</expr>;</expr_stmt>
        <comment type="block">/* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */</comment>
        <expr_stmt><expr><name>overflow</name> -= 2</expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>overflow</name> &gt; 0</expr>)</condition>;</do>

    <comment type="block">/* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */</comment>
    <for>for (<init><expr><name>bits</name> = <name>max_length</name></expr>;</init> <condition><expr><name>bits</name> != 0</expr>;</condition> <incr><expr><name>bits</name>--</expr></incr>) <block>{
        <expr_stmt><expr><name>n</name> = <name><name>s</name>-&gt;<name>bl_count</name><index>[<expr><name>bits</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>n</name> != 0</expr>)</condition> <block>{
            <expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr>--<name>h</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>m</name> &gt; <name>max_code</name></expr>)</condition><then> <continue>continue;</continue></then></if>
            <if>if <condition>(<expr>(<name>unsigned</name>) <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Len</name> != (<name>unsigned</name>) <name>bits</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Trace</name><argument_list>(<argument><expr>(<name>stderr</name>,"code %d bits %d-&gt;%d\n", <name>m</name>, <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Len</name>, <name>bits</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name> += ((<name>long</name>)<name>bits</name> - (<name>long</name>)<name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Len</name>)
                              *(<name>long</name>)<name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Freq</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Len</name> = (<name>ush</name>)<name>bits</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
        }</block></while>
    }</block></for>
}</block></function>

<comment type="block">/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>gen_codes</name> <parameter_list>(<param><decl><type><name>tree</name></type></decl></param>, <param><decl><type><name>max_code</name></type></decl></param>, <param><decl><type><name>bl_count</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name></decl>;</decl_stmt>             <comment type="block">/* the tree to decorate */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>              <comment type="block">/* largest code with non zero frequency */</comment>
    <decl_stmt><decl><type><name>ushf</name> *</type><name>bl_count</name></decl>;</decl_stmt>            <comment type="block">/* number of codes at each bit length */</comment>
<block>{
    <decl_stmt><decl><type><name>ush</name></type> <name><name>next_code</name><index>[<expr><name>MAX_BITS</name>+1</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* next code value for each bit length */</comment>
    <decl_stmt><decl><type><name>ush</name></type> <name>code</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>              <comment type="block">/* running code value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>                  <comment type="block">/* bit index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                     <comment type="block">/* code index */</comment>

    <comment type="block">/* The distribution counts are first used to generate the code values
     * without bit reversal.
     */</comment>
    <for>for (<init><expr><name>bits</name> = 1</expr>;</init> <condition><expr><name>bits</name> &lt;= <name>MAX_BITS</name></expr>;</condition> <incr><expr><name>bits</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>next_code</name><index>[<expr><name>bits</name></expr>]</index></name> = <name>code</name> = (<name>code</name> + <name><name>bl_count</name><index>[<expr><name>bits</name>-1</expr>]</index></name>) &lt;&lt; 1</expr>;</expr_stmt>
    }</block></for>
    <comment type="block">/* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>code</name> + <name><name>bl_count</name><index>[<expr><name>MAX_BITS</name></expr>]</index></name>-1 == (1&lt;&lt;<name>MAX_BITS</name>)-1</expr></argument>,
            <argument><expr>"inconsistent bit counts"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>,"\ngen_codes: max_code %d ", <name>max_code</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init>  <condition><expr><name>n</name> &lt;= <name>max_code</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <continue>continue;</continue></then></if>
        <comment type="block">/* Now reverse the bits */</comment>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Code</name> = <call><name>bi_reverse</name><argument_list>(<argument><expr><name><name>next_code</name><index>[<expr><name>len</name></expr>]</index></name>++</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Tracecv</name><argument_list>(<argument><expr><name>tree</name> != <name>static_ltree</name></expr></argument>, <argument><expr>(<name>stderr</name>,"\nn %3d %c l %2d c %4x (%x) ",
             <name>n</name>, (<call><name>isgraph</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> ? <name>n</name> : ' '), <name>len</name>, <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Code</name>, <name><name>next_code</name><index>[<expr><name>len</name></expr>]</index></name>-1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<comment type="block">/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>build_tree</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>desc</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tree_desc</name> *</type><name>desc</name></decl>;</decl_stmt> <comment type="block">/* the tree descriptor */</comment>
<block>{
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name>         <init>= <expr><name><name>desc</name>-&gt;<name>dyn_tree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ct_data</name> *</type><name>stree</name>  <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>static_tree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>elems</name>             <init>= <expr><name><name>desc</name>-&gt;<name>stat_desc</name>-&gt;<name>elems</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>          <comment type="block">/* iterate over heap elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt> <comment type="block">/* largest code with non zero frequency */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>node</name></decl>;</decl_stmt>          <comment type="block">/* new node being created */</comment>

    <comment type="block">/* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */</comment>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>heap_len</name></name> = 0</expr>, <expr><name><name>s</name>-&gt;<name>heap_max</name></name> = <name>HEAP_SIZE</name></expr>;</expr_stmt>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name>elems</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> != 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr>++(<name><name>s</name>-&gt;<name>heap_len</name></name>)</expr>]</index></name> = <name>max_code</name> = <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Len</name> = 0</expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>

    <comment type="block">/* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */</comment>
    <while>while <condition>(<expr><name><name>s</name>-&gt;<name>heap_len</name></name> &lt; 2</expr>)</condition> <block>{
        <expr_stmt><expr><name>node</name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr>++(<name><name>s</name>-&gt;<name>heap_len</name></name>)</expr>]</index></name> = (<name>max_code</name> &lt; 2 ? ++<name>max_code</name> : 0)</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name>.<name>Freq</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>node</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name>--</expr>;</expr_stmt> <if>if <condition>(<expr><name>stree</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>static_len</name></name> -= <name><name>stree</name><index>[<expr><name>node</name></expr>]</index></name>.<name>Len</name></expr>;</expr_stmt></then></if>
        <comment type="block">/* node is 0 or 1 so it does not have extra bits */</comment>
    }</block></while>
    <expr_stmt><expr><name><name>desc</name>-&gt;<name>max_code</name></name> = <name>max_code</name></expr>;</expr_stmt>

    <comment type="block">/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */</comment>
    <for>for (<init><expr><name>n</name> = <name><name>s</name>-&gt;<name>heap_len</name></name>/2</expr>;</init> <condition><expr><name>n</name> &gt;= 1</expr>;</condition> <incr><expr><name>n</name>--</expr></incr>) <expr_stmt><expr><call><name>pqdownheap</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

    <comment type="block">/* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */</comment>
    <expr_stmt><expr><name>node</name> = <name>elems</name></expr>;</expr_stmt>              <comment type="block">/* next internal node of the tree */</comment>
    <do>do <block>{
        <expr_stmt><expr><call><name>pqremove</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* n = node of least frequency */</comment>
        <expr_stmt><expr><name>m</name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* m = node of next least frequency */</comment>

        <expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr>--(<name><name>s</name>-&gt;<name>heap_max</name></name>)</expr>]</index></name> = <name>n</name></expr>;</expr_stmt> <comment type="block">/* keep the nodes sorted by frequency */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr>--(<name><name>s</name>-&gt;<name>heap_max</name></name>)</expr>]</index></name> = <name>m</name></expr>;</expr_stmt>

        <comment type="block">/* Create a new node father of n and m */</comment>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name>.<name>Freq</name> = <name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> + <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Freq</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>node</name></expr>]</index></name> = <call>(<name>uch</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>n</name></expr>]</index></name> &gt;= <name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>m</name></expr>]</index></name> ?
                                <name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>n</name></expr>]</index></name> : <name><name>s</name>-&gt;<name>depth</name><index>[<expr><name>m</name></expr>]</index></name>) + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Dad</name> = <name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Dad</name> = (<name>ush</name>)<name>node</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUMP_BL_TREE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>tree</name> == <name><name>s</name>-&gt;<name>bl_tree</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"\nnode %d(%d), sons %d(%d) %d(%d)"</expr></argument>,
                    <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>node</name></expr>]</index></name>.<name>Freq</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>m</name></expr>]</index></name>.<name>Freq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* and insert the new node in the heap */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name> = <name>node</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pqdownheap</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>SMALLEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block> while <condition>(<expr><name><name>s</name>-&gt;<name>heap_len</name></name> &gt;= 2</expr>)</condition>;</do>

    <expr_stmt><expr><name><name>s</name>-&gt;<name>heap</name><index>[<expr>--(<name><name>s</name>-&gt;<name>heap_max</name></name>)</expr>]</index></name> = <name><name>s</name>-&gt;<name>heap</name><index>[<expr><name>SMALLEST</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */</comment>
    <expr_stmt><expr><call><name>gen_bitlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>tree_desc</name> *)<name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The field len is now set, we can generate the bit codes */</comment>
    <expr_stmt><expr><call><name>gen_codes</name> <argument_list>(<argument><expr>(<name>ct_data</name> *)<name>tree</name></expr></argument>, <argument><expr><name>max_code</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>scan_tree</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>tree</name></type></decl></param>, <param><decl><type><name>max_code</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name></decl>;</decl_stmt>   <comment type="block">/* the tree to be scanned */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>    <comment type="block">/* and its largest code of non zero frequency */</comment>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                     <comment type="block">/* iterates over all tree elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>prevlen</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>          <comment type="block">/* last emitted length */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>curlen</name></decl>;</decl_stmt>                <comment type="block">/* length of current code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nextlen</name> <init>= <expr><name><name>tree</name><index>[<expr>0</expr>]</index></name>.<name>Len</name></expr></init></decl>;</decl_stmt> <comment type="block">/* length of next code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* repeat count of the current code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_count</name> <init>= <expr>7</expr></init></decl>;</decl_stmt>         <comment type="block">/* max repeat count */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>min_count</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>         <comment type="block">/* min repeat count */</comment>

    <if>if <condition>(<expr><name>nextlen</name> == 0</expr>)</condition><then> <expr_stmt><expr><name>max_count</name> = 138</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>tree</name><index>[<expr><name>max_code</name>+1</expr>]</index></name>.<name>Len</name> = (<name>ush</name>)0xffff</expr>;</expr_stmt> <comment type="block">/* guard */</comment>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt;= <name>max_code</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>curlen</name> = <name>nextlen</name></expr>;</expr_stmt> <expr_stmt><expr><name>nextlen</name> = <name><name>tree</name><index>[<expr><name>n</name>+1</expr>]</index></name>.<name>Len</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>++<name>count</name> &lt; <name>max_count</name> &amp;&amp; <name>curlen</name> == <name>nextlen</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt; <name>min_count</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>curlen</name></expr>]</index></name>.<name>Freq</name> += <name>count</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>curlen</name> != 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>curlen</name> != <name>prevlen</name></expr>)</condition><then> <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>curlen</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>REP_3_6</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt;= 10</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>REPZ_3_10</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name>REPZ_11_138</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
        }</block></else></if></else></if></else></if></else></if>
        <expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt> <expr_stmt><expr><name>prevlen</name> = <name>curlen</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nextlen</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>max_count</name> = 138</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>curlen</name> == <name>nextlen</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>max_count</name> = 6</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>max_count</name> = 7</expr>, <expr><name>min_count</name> = 4</expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></for>
}</block></function>

<comment type="block">/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>send_tree</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>tree</name></type></decl></param>, <param><decl><type><name>max_code</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>tree</name></decl>;</decl_stmt> <comment type="block">/* the tree to be scanned */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_code</name></decl>;</decl_stmt>       <comment type="block">/* and its largest code of non zero frequency */</comment>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                     <comment type="block">/* iterates over all tree elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>prevlen</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>          <comment type="block">/* last emitted length */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>curlen</name></decl>;</decl_stmt>                <comment type="block">/* length of current code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nextlen</name> <init>= <expr><name><name>tree</name><index>[<expr>0</expr>]</index></name>.<name>Len</name></expr></init></decl>;</decl_stmt> <comment type="block">/* length of next code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* repeat count of the current code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_count</name> <init>= <expr>7</expr></init></decl>;</decl_stmt>         <comment type="block">/* max repeat count */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>min_count</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>         <comment type="block">/* min repeat count */</comment>

    <comment type="block">/* tree[max_code+1].Len = -1; */</comment>  <comment type="block">/* guard already set */</comment>
    <if>if <condition>(<expr><name>nextlen</name> == 0</expr>)</condition><then> <expr_stmt><expr><name>max_count</name> = 138</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt></then></if>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt;= <name>max_code</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>curlen</name> = <name>nextlen</name></expr>;</expr_stmt> <expr_stmt><expr><name>nextlen</name> = <name><name>tree</name><index>[<expr><name>n</name>+1</expr>]</index></name>.<name>Len</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>++<name>count</name> &lt; <name>max_count</name> &amp;&amp; <name>curlen</name> == <name>nextlen</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt; <name>min_count</name></expr>)</condition><then> <block>{
            <do>do <block>{ <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curlen</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block> while <condition>(<expr>--<name>count</name> != 0</expr>)</condition>;</do>

        }</block></then> <else>else <if>if <condition>(<expr><name>curlen</name> != 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>curlen</name> != <name>prevlen</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curlen</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>count</name>--</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> &gt;= 3 &amp;&amp; <name>count</name> &lt;= 6</expr></argument>, <argument><expr>" 3_6?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REP_3_6</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name>-3</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt;= 10</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REPZ_3_10</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name>-3</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>REPZ_11_138</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>count</name>-11</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if></else></if>
        <expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt> <expr_stmt><expr><name>prevlen</name> = <name>curlen</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nextlen</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>max_count</name> = 138</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>curlen</name> == <name>nextlen</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>max_count</name> = 6</expr>, <expr><name>min_count</name> = 3</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>max_count</name> = 7</expr>, <expr><name>min_count</name> = 4</expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></for>
}</block></function>

<comment type="block">/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */</comment>
<function><type><name>local</name> <name>int</name></type> <name>build_bl_tree</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>max_blindex</name></decl>;</decl_stmt>  <comment type="block">/* index of last bit length code of non zero freq */</comment>

    <comment type="block">/* Determine the bit length frequencies for literal and distance trees */</comment>
    <expr_stmt><expr><call><name>scan_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_ltree</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>l_desc</name>.<name>max_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>scan_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_dtree</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>d_desc</name>.<name>max_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build the bit length tree: */</comment>
    <expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>tree_desc</name> *)<argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>bl_desc</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */</comment>

    <comment type="block">/* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */</comment>
    <for>for (<init><expr><name>max_blindex</name> = <name>BL_CODES</name>-1</expr>;</init> <condition><expr><name>max_blindex</name> &gt;= 3</expr>;</condition> <incr><expr><name>max_blindex</name>--</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name><name>bl_order</name><index>[<expr><name>max_blindex</name></expr>]</index></name></expr>]</index></name>.<name>Len</name> != 0</expr>)</condition><then> <break>break;</break></then></if>
    }</block></for>
    <comment type="block">/* Update opt_len to include the bit length tree and counts */</comment>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>opt_len</name></name> += 3*(<name>max_blindex</name>+1) + 5+5+4</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\ndyn trees: dyn %ld, stat %ld",
            <name><name>s</name>-&gt;<name>opt_len</name></name>, <name><name>s</name>-&gt;<name>static_len</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>max_blindex</name></expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>send_all_trees</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>lcodes</name></type></decl></param>, <param><decl><type><name>dcodes</name></type></decl></param>, <param><decl><type><name>blcodes</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lcodes</name></decl>, <decl><type ref="prev"/><name>dcodes</name></decl>, <decl><type ref="prev"/><name>blcodes</name></decl>;</decl_stmt> <comment type="block">/* number of codes for each tree */</comment>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rank</name></decl>;</decl_stmt>                    <comment type="block">/* index in bl_order */</comment>

    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>lcodes</name> &gt;= 257 &amp;&amp; <name>dcodes</name> &gt;= 1 &amp;&amp; <name>blcodes</name> &gt;= 4</expr></argument>, <argument><expr>"not enough codes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>lcodes</name> &lt;= <name>L_CODES</name> &amp;&amp; <name>dcodes</name> &lt;= <name>D_CODES</name> &amp;&amp; <name>blcodes</name> &lt;= <name>BL_CODES</name></expr></argument>,
            <argument><expr>"too many codes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nbl counts: ")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lcodes</name>-257</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not +255 as stated in appnote.txt */</comment>
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dcodes</name>-1</expr></argument>,   <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>blcodes</name>-4</expr></argument>,  <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not -3 as stated in appnote.txt */</comment>
    <for>for (<init><expr><name>rank</name> = 0</expr>;</init> <condition><expr><name>rank</name> &lt; <name>blcodes</name></expr>;</condition> <incr><expr><name>rank</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nbl code %2d ", <name><name>bl_order</name><index>[<expr><name>rank</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bl_tree</name><index>[<expr><name><name>bl_order</name><index>[<expr><name>rank</name></expr>]</index></name></expr>]</index></name>.<name>Len</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nbl tree: sent %ld", <name><name>s</name>-&gt;<name>bits_sent</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>send_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_ltree</name></name></expr></argument>, <argument><expr><name>lcodes</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* literal tree */</comment>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nlit tree: sent %ld", <name><name>s</name>-&gt;<name>bits_sent</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>send_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_dtree</name></name></expr></argument>, <argument><expr><name>dcodes</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* distance tree */</comment>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\ndist tree: sent %ld", <name><name>s</name>-&gt;<name>bits_sent</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ===========================================================================
 * Send a stored block
 */</comment>
<function><type><name>void</name></type> <name>_tr_stored_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>stored_len</name></type></decl></param>, <param><decl><type><name>eof</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charf</name> *</type><name>buf</name></decl>;</decl_stmt>       <comment type="block">/* input block */</comment>
    <decl_stmt><decl><type><name>ulg</name></type> <name>stored_len</name></decl>;</decl_stmt>   <comment type="block">/* length of input block */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eof</name></decl>;</decl_stmt>          <comment type="block">/* true if this is the last block for a file */</comment>
<block>{
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>STORED_BLOCK</name>&lt;&lt;1)+<name>eof</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* send block type */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> = (<name><name>s</name>-&gt;<name>compressed_len</name></name> + 3 + 7) &amp; (<name>ulg</name>)~7L</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += (<name>stored_len</name> + 4) &lt;&lt; 3</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>copy_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>unsigned</name>)<name>stored_len</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* with header */</comment>
}</block></function>

<comment type="block">/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */</comment>
<function><type><name>void</name></type> <name>_tr_align</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>STATIC_TREES</name>&lt;&lt;1</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>END_BLOCK</name></expr></argument>, <argument><expr><name>static_ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 10L</expr>;</expr_stmt> <comment type="block">/* 3 for block type, 7 for EOB */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>bi_flush</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */</comment>
    <if>if <condition>(<expr>1 + <name><name>s</name>-&gt;<name>last_eob_len</name></name> + 10 - <name><name>s</name>-&gt;<name>bi_valid</name></name> &lt; 9</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>STATIC_TREES</name>&lt;&lt;1</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>END_BLOCK</name></expr></argument>, <argument><expr><name>static_ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 10L</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>bi_flush</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>last_eob_len</name></name> = 7</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */</comment>
<function><type><name>void</name></type> <name>_tr_flush_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>stored_len</name></type></decl></param>, <param><decl><type><name>eof</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charf</name> *</type><name>buf</name></decl>;</decl_stmt>       <comment type="block">/* input block, or NULL if too old */</comment>
    <decl_stmt><decl><type><name>ulg</name></type> <name>stored_len</name></decl>;</decl_stmt>   <comment type="block">/* length of input block */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eof</name></decl>;</decl_stmt>          <comment type="block">/* true if this is the last block for a file */</comment>
<block>{
    <decl_stmt><decl><type><name>ulg</name></type> <name>opt_lenb</name></decl>, <decl><type ref="prev"/><name>static_lenb</name></decl>;</decl_stmt> <comment type="block">/* opt_len and static_len in bytes */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_blindex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* index of last bit length code of non zero freq */</comment>

    <comment type="block">/* Build the Huffman trees unless a stored block is forced */</comment>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>level</name></name> &gt; 0</expr>)</condition><then> <block>{

        <comment type="block">/* Check if the file is binary or text */</comment>
        <if>if <condition>(<expr><name>stored_len</name> &gt; 0 &amp;&amp; <name><name>s</name>-&gt;<name>strm</name>-&gt;<name>data_type</name></name> == <name>Z_UNKNOWN</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>set_data_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/* Construct the literal and distance trees */</comment>
        <expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>tree_desc</name> *)<argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>l_desc</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nlit data: dyn %ld, stat %ld", <name><name>s</name>-&gt;<name>opt_len</name></name>,
                <name><name>s</name>-&gt;<name>static_len</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>build_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call>(<name>tree_desc</name> *)<argument_list>(<argument><expr>&amp;(<name><name>s</name>-&gt;<name>d_desc</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\ndist data: dyn %ld, stat %ld", <name><name>s</name>-&gt;<name>opt_len</name></name>,
                <name><name>s</name>-&gt;<name>static_len</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */</comment>

        <comment type="block">/* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */</comment>
        <expr_stmt><expr><name>max_blindex</name> = <call><name>build_bl_tree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Determine the best encoding. Compute the block lengths in bytes. */</comment>
        <expr_stmt><expr><name>opt_lenb</name> = (<name><name>s</name>-&gt;<name>opt_len</name></name>+3+7)&gt;&gt;3</expr>;</expr_stmt>
        <expr_stmt><expr><name>static_lenb</name> = (<name><name>s</name>-&gt;<name>static_len</name></name>+3+7)&gt;&gt;3</expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                <name>opt_lenb</name>, <name><name>s</name>-&gt;<name>opt_len</name></name>, <name>static_lenb</name>, <name><name>s</name>-&gt;<name>static_len</name></name>, <name>stored_len</name>,
                <name><name>s</name>-&gt;<name>last_lit</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>static_lenb</name> &lt;= <name>opt_lenb</name></expr>)</condition><then> <expr_stmt><expr><name>opt_lenb</name> = <name>static_lenb</name></expr>;</expr_stmt></then></if>

    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf</name> != (<name>char</name>*)0</expr></argument>, <argument><expr>"lost buf"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opt_lenb</name> = <name>static_lenb</name> = <name>stored_len</name> + 5</expr>;</expr_stmt> <comment type="block">/* force a stored block */</comment>
    }</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FORCE_STORED</name></cpp:ifdef>
    <if>if <condition>(<expr><name>buf</name> != (<name>char</name>*)0</expr>)</condition><then> <block>{ <comment type="block">/* force stored block */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><name>stored_len</name>+4 &lt;= <name>opt_lenb</name> &amp;&amp; <name>buf</name> != (<name>char</name>*)0</expr>)</condition><then> <block>{
                       <comment type="block">/* 4: two words for the lengths */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
         * transform a block into a stored block.
         */</comment>
        <expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stored_len</name></expr></argument>, <argument><expr><name>eof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FORCE_STATIC</name></cpp:ifdef>
    }</block></then> <else>else <if>if <condition>(<expr><name>static_lenb</name> &gt;= 0</expr>)</condition><then> <block>{ <comment type="block">/* force static trees */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    }</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>strategy</name></name> == <name>Z_FIXED</name> || <name>static_lenb</name> == <name>opt_lenb</name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>STATIC_TREES</name>&lt;&lt;1)+<name>eof</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>compress_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name>static_ltree</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name>static_dtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 3 + <name><name>s</name>-&gt;<name>static_len</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>DYN_TREES</name>&lt;&lt;1)+<name>eof</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>send_all_trees</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>l_desc</name>.<name>max_code</name></name>+1</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>d_desc</name>.<name>max_code</name></name>+1</expr></argument>,
                       <argument><expr><name>max_blindex</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>compress_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_ltree</name></name></expr></argument>, <argument><expr>(<name>ct_data</name> *)<name><name>s</name>-&gt;<name>dyn_dtree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 3 + <name><name>s</name>-&gt;<name>opt_len</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> == <name><name>s</name>-&gt;<name>bits_sent</name></name></expr></argument>, <argument><expr>"bad compressed size"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */</comment>
    <expr_stmt><expr><call><name>init_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>eof</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>bi_windup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>compressed_len</name></name> += 7</expr>;</expr_stmt>  <comment type="block">/* align on byte boundary */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>,"\ncomprlen %lu(%lu) ", <name><name>s</name>-&gt;<name>compressed_len</name></name>&gt;&gt;3,
           <name><name>s</name>-&gt;<name>compressed_len</name></name>-7*<name>eof</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>

<comment type="block">/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */</comment>
<function><type><name>int</name></type> <name>_tr_tally</name> <parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>dist</name></type></decl></param>, <param><decl><type><name>lc</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>dist</name></decl>;</decl_stmt>  <comment type="block">/* distance of matched string */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>lc</name></decl>;</decl_stmt>    <comment type="block">/* match length-MIN_MATCH or unmatched char (if dist==0) */</comment>
<block>{
    <expr_stmt><expr><name><name>s</name>-&gt;<name>d_buf</name><index>[<expr><name><name>s</name>-&gt;<name>last_lit</name></name></expr>]</index></name> = (<name>ush</name>)<name>dist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>l_buf</name><index>[<expr><name><name>s</name>-&gt;<name>last_lit</name></name>++</expr>]</index></name> = (<name>uch</name>)<name>lc</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>dist</name> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* lc is the unmatched char */</comment>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>lc</name></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>matches</name></name>++</expr>;</expr_stmt>
        <comment type="block">/* Here, lc is the match length - MIN_MATCH */</comment>
        <expr_stmt><expr><name>dist</name>--</expr>;</expr_stmt>             <comment type="block">/* dist = match distance - 1 */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr>(<name>ush</name>)<name>dist</name> &lt; (<name>ush</name>)<call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &amp;&amp;
               (<name>ush</name>)<name>lc</name> &lt;= <call>(<name>ush</name>)<argument_list>(<argument><expr><name>MAX_MATCH</name>-<name>MIN_MATCH</name></expr></argument>)</argument_list></call> &amp;&amp;
               (<name>ush</name>)<call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call> &lt; (<name>ush</name>)<name>D_CODES</name></expr></argument>,  <argument><expr>"_tr_tally: bad match"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name><name>_length_code</name><index>[<expr><name>lc</name></expr>]</index></name>+<name>LITERALS</name>+1</expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>dyn_dtree</name><index>[<expr><call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>]</index></name>.<name>Freq</name>++</expr>;</expr_stmt>
    }</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRUNCATE_BLOCK</name></cpp:ifdef>
    <comment type="block">/* Try to guess if it is profitable to stop the current block here */</comment>
    <if>if <condition>(<expr>(<name><name>s</name>-&gt;<name>last_lit</name></name> &amp; 0x1fff) == 0 &amp;&amp; <name><name>s</name>-&gt;<name>level</name></name> &gt; 2</expr>)</condition><then> <block>{
        <comment type="block">/* Compute an upper bound for the compressed length */</comment>
        <decl_stmt><decl><type><name>ulg</name></type> <name>out_length</name> <init>= <expr>(<name>ulg</name>)<name><name>s</name>-&gt;<name>last_lit</name></name>*8L</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ulg</name></type> <name>in_length</name> <init>= <expr><call>(<name>ulg</name>)<argument_list>(<argument><expr>(<name>long</name>)<name><name>s</name>-&gt;<name>strstart</name></name> - <name><name>s</name>-&gt;<name>block_start</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>dcode</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>dcode</name> = 0</expr>;</init> <condition><expr><name>dcode</name> &lt; <name>D_CODES</name></expr>;</condition> <incr><expr><name>dcode</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>out_length</name> += (<name>ulg</name>)<name><name>s</name>-&gt;<name>dyn_dtree</name><index>[<expr><name>dcode</name></expr>]</index></name>.<call><name>Freq</name> *
                <argument_list>(<argument><expr>5L+<name><name>extra_dbits</name><index>[<expr><name>dcode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>out_length</name> &gt;&gt;= 3</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               <name><name>s</name>-&gt;<name>last_lit</name></name>, <name>in_length</name>, <name>out_length</name>,
               100L - <name>out_length</name>*100L/<name>in_length</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>matches</name></name> &lt; <name><name>s</name>-&gt;<name>last_lit</name></name>/2 &amp;&amp; <name>out_length</name> &lt; <name>in_length</name>/2</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>(<name><name>s</name>-&gt;<name>last_lit</name></name> == <name><name>s</name>-&gt;<name>lit_bufsize</name></name>-1)</expr>;</return>
    <comment type="block">/* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */</comment>
}</block></function>

<comment type="block">/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>compress_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>ltree</name></type></decl></param>, <param><decl><type><name>dtree</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>ltree</name></decl>;</decl_stmt> <comment type="block">/* literal tree */</comment>
    <decl_stmt><decl><type><name>ct_data</name> *</type><name>dtree</name></decl>;</decl_stmt> <comment type="block">/* distance tree */</comment>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>dist</name></decl>;</decl_stmt>      <comment type="block">/* distance of matched string */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lc</name></decl>;</decl_stmt>             <comment type="block">/* match length or unmatched char (if dist == 0) */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>lx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* running index in l_buf */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>code</name></decl>;</decl_stmt>      <comment type="block">/* the code to send */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>extra</name></decl>;</decl_stmt>          <comment type="block">/* number of extra bits to send */</comment>

    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>last_lit</name></name> != 0</expr>)</condition><then> <do>do <block>{
        <expr_stmt><expr><name>dist</name> = <name><name>s</name>-&gt;<name>d_buf</name><index>[<expr><name>lx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lc</name> = <name><name>s</name>-&gt;<name>l_buf</name><index>[<expr><name>lx</name>++</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>dist</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* send a literal byte */</comment>
            <expr_stmt><expr><call><name>Tracecv</name><argument_list>(<argument><expr><call><name>isgraph</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>stderr</name>," '%c' ", <name>lc</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/* Here, lc is the match length - MIN_MATCH */</comment>
            <expr_stmt><expr><name>code</name> = <name><name>_length_code</name><index>[<expr><name>lc</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>code</name>+<name>LITERALS</name>+1</expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* send the length code */</comment>
            <expr_stmt><expr><name>extra</name> = <name><name>extra_lbits</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>extra</name> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>lc</name> -= <name><name>base_length</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* send the extra length bits */</comment>
            }</block></then></if>
            <expr_stmt><expr><name>dist</name>--</expr>;</expr_stmt> <comment type="block">/* dist is now the match distance - 1 */</comment>
            <expr_stmt><expr><name>code</name> = <call><name>d_code</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>code</name> &lt; <name>D_CODES</name></expr></argument>, <argument><expr>"bad d_code"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>dtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* send the distance code */</comment>
            <expr_stmt><expr><name>extra</name> = <name><name>extra_dbits</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>extra</name> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>dist</name> -= <name><name>base_dist</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>send_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* send the extra distance bits */</comment>
            }</block></then></if>
        }</block></else></if> <comment type="block">/* literal or match pair ? */</comment>

        <comment type="block">/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call>(<name>uInt</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>pending</name></name></expr></argument>)</argument_list></call> &lt; <name><name>s</name>-&gt;<name>lit_bufsize</name></name> + 2*<name>lx</name></expr></argument>,
               <argument><expr>"pendingBuf overflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block> while <condition>(<expr><name>lx</name> &lt; <name><name>s</name>-&gt;<name>last_lit</name></name></expr>)</condition>;</do></then></if>

    <expr_stmt><expr><call><name>send_code</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>END_BLOCK</name></expr></argument>, <argument><expr><name>ltree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>last_eob_len</name></name> = <name><name>ltree</name><index>[<expr><name>END_BLOCK</name></expr>]</index></name>.<name>Len</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ===========================================================================
 * Set the data type to BINARY or TEXT, using a crude approximation:
 * set it to Z_TEXT if all symbols are either printable characters (33 to 255)
 * or white spaces (9 to 13, or 32); or set it to Z_BINARY otherwise.
 * IN assertion: the fields Freq of dyn_ltree are set.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>set_data_type</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; 9</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> != 0</expr>)</condition><then>
            <break>break;</break></then></if></for>
    <if>if <condition>(<expr><name>n</name> == 9</expr>)</condition><then>
        <for>for (<init><expr><name>n</name> = 14</expr>;</init> <condition><expr><name>n</name> &lt; 32</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
            <if>if <condition>(<expr><name><name>s</name>-&gt;<name>dyn_ltree</name><index>[<expr><name>n</name></expr>]</index></name>.<name>Freq</name> != 0</expr>)</condition><then>
                <break>break;</break></then></if></for></then></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>strm</name>-&gt;<name>data_type</name></name> = (<name>n</name> == 32) ? <name>Z_TEXT</name> : <name>Z_BINARY</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 &lt;= len &lt;= 15
 */</comment>
<function><type><name>local</name> <name>unsigned</name></type> <name>bi_reverse</name><parameter_list>(<param><decl><type><name>code</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>code</name></decl>;</decl_stmt> <comment type="block">/* the value to invert */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>       <comment type="block">/* its bit length */</comment>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>unsigned</name></type> <name>res</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <do>do <block>{
        <expr_stmt><expr><name>res</name> |= <name>code</name> &amp; 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>code</name> &gt;&gt;= 1</expr>, <expr><name>res</name> &lt;&lt;= 1</expr>;</expr_stmt>
    }</block> while <condition>(<expr>--<name>len</name> &gt; 0</expr>)</condition>;</do>
    <return>return <expr><name>res</name> &gt;&gt; 1</expr>;</return>
}</block></function>

<comment type="block">/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>bi_flush</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> == 16</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> &gt;= 8</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>Byte</name>)<name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> &gt;&gt;= 8</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> -= 8</expr>;</expr_stmt>
    }</block></then></if></else></if>
}</block></function>

<comment type="block">/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>bi_windup</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
<block>{
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> &gt; 8</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name><name>s</name>-&gt;<name>bi_valid</name></name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>Byte</name>)<name><name>s</name>-&gt;<name>bi_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_buf</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>bi_valid</name></name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> = (<name><name>s</name>-&gt;<name>bits_sent</name></name>+7) &amp; ~7</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>copy_block</name><parameter_list>(<param><decl><type><name>s</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>, <param><decl><type><name>header</name></type></decl></param>)</parameter_list>
    <decl_stmt><decl><type><name>deflate_state</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charf</name>    *</type><name>buf</name></decl>;</decl_stmt>    <comment type="block">/* the input data */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>     <comment type="block">/* its length */</comment>
    <decl_stmt><decl><type><name>int</name></type>      <name>header</name></decl>;</decl_stmt>  <comment type="block">/* true if block header must be written */</comment>
<block>{
    <expr_stmt><expr><call><name>bi_windup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* align on byte boundary */</comment>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>last_eob_len</name></name> = 8</expr>;</expr_stmt> <comment type="block">/* enough lookahead for inflate */</comment>

    <if>if <condition>(<expr><name>header</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ush</name>)<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put_short</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>ush</name>)~<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> += 2*16</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>s</name>-&gt;<name>bits_sent</name></name> += (<name>ulg</name>)<name>len</name>&lt;&lt;3</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while <condition>(<expr><name>len</name>--</expr>)</condition> <block>{
        <expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>*<name>buf</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}</block></function></block></function>
</unit>
