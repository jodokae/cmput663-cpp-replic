<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/zlib/inflate.c"><comment type="block">/* inflate.c -- zlib decompression
 * Copyright (C) 1995-2005 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */</comment>

<comment type="block">/*
 * Change history:
 *
 * 1.2.beta0    24 Nov 2002
 * - First version -- complete rewrite of inflate to simplify code, avoid
 *   creation of window when not needed, minimize use of window when it is
 *   needed, make inffast.c even faster, implement gzip decoding, and to
 *   improve code readability and style over the previous zlib inflate code
 *
 * 1.2.beta1    25 Nov 2002
 * - Use pointers for available input and output checking in inffast.c
 * - Remove input and output counters in inffast.c
 * - Change inffast.c entry and loop from avail_in &gt;= 7 to &gt;= 6
 * - Remove unnecessary second byte pull from length extra in inffast.c
 * - Unroll direct copy to three copies per loop in inffast.c
 *
 * 1.2.beta2    4 Dec 2002
 * - Change external routine names to reduce potential conflicts
 * - Correct filename to inffixed.h for fixed tables in inflate.c
 * - Make hbuf[] unsigned char to match parameter type in inflate.c
 * - Change strm-&gt;next_out[-state-&gt;offset] to *(strm-&gt;next_out - state-&gt;offset)
 *   to avoid negation problem on Alphas (64 bit) in inflate.c
 *
 * 1.2.beta3    22 Dec 2002
 * - Add comments on state-&gt;bits assertion in inffast.c
 * - Add comments on op field in inftrees.h
 * - Fix bug in reuse of allocated window after inflateReset()
 * - Remove bit fields--back to byte structure for speed
 * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
 * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
 * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
 * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
 * - Use local copies of stream next and avail values, as well as local bit
 *   buffer and bit count in inflate()--for speed when inflate_fast() not used
 *
 * 1.2.beta4    1 Jan 2003
 * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
 * - Move a comment on output buffer sizes from inffast.c to inflate.c
 * - Add comments in inffast.c to introduce the inflate_fast() routine
 * - Rearrange window copies in inflate_fast() for speed and simplification
 * - Unroll last copy for window match in inflate_fast()
 * - Use local copies of window variables in inflate_fast() for speed
 * - Pull out common write == 0 case for speed in inflate_fast()
 * - Make op and len in inflate_fast() unsigned for consistency
 * - Add FAR to lcode and dcode declarations in inflate_fast()
 * - Simplified bad distance check in inflate_fast()
 * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
 *   source file infback.c to provide a call-back interface to inflate for
 *   programs like gzip and unzip -- uses window as output buffer to avoid
 *   window copying
 *
 * 1.2.beta5    1 Jan 2003
 * - Improved inflateBack() interface to allow the caller to provide initial
 *   input in strm.
 * - Fixed stored blocks bug in inflateBack()
 *
 * 1.2.beta6    4 Jan 2003
 * - Added comments in inffast.c on effectiveness of POSTINC
 * - Typecasting all around to reduce compiler warnings
 * - Changed loops from while (1) or do {} while (1) to for (;;), again to
 *   make compilers happy
 * - Changed type of window in inflateBackInit() to unsigned char *
 *
 * 1.2.beta7    27 Jan 2003
 * - Changed many types to unsigned or unsigned short to avoid warnings
 * - Added inflateCopy() function
 *
 * 1.2.0        9 Mar 2003
 * - Changed inflateBack() interface to provide separate opaque descriptors
 *   for the in() and out() functions
 * - Changed inflateBack() argument and in_func typedef to swap the length
 *   and buffer address return values for the input function
 * - Check next_in and next_out for Z_NULL on entry to inflate()
 *
 * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inftrees.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inflate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inffast.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAKEFIXED</name></cpp:ifdef>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>BUILDFIXED</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>BUILDFIXED</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* function prototypes */</comment>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>fixedtables</name></type> <name>OF</name><argument_list>(<argument><expr>(struct <name>inflate_state</name> <name>FAR</name> *<name>state</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>updatewindow</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>unsigned</name> <name>out</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BUILDFIXED</name></cpp:ifdef>
   <decl_stmt><decl><type><name>void</name> <name>makefixed</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>local</name> <name>unsigned</name> <name>syncsearch</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>FAR</name> *<name>have</name>, <name>unsigned</name> <name>char</name> <name>FAR</name> *<name>buf</name>,
                              <name>unsigned</name> <name>len</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateReset</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_in</name></name> = <name><name>strm</name>-&gt;<name>total_out</name></name> = <name><name>state</name>-&gt;<name>total</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = 1</expr>;</expr_stmt>        <comment type="block">/* to support ill-conceived Java test suite */</comment>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>HEAD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>last</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>havedict</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>dmax</name></name> = 32768U</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>wsize</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>whave</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>write</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>hold</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>bits</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>lencode</name></name> = <name><name>state</name>-&gt;<name>distcode</name></name> = <name><name>state</name>-&gt;<name>next</name></name> = <name><name>state</name>-&gt;<name>codes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate: reset\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflatePrime</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>bits</name></type></decl></param>, <param><decl><type><name>value</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>bits</name> &gt; 16 || <name><name>state</name>-&gt;<name>bits</name></name> + <name>bits</name> &gt; 32</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>value</name> &amp;= (1L &lt;&lt; <name>bits</name>) - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>hold</name></name> += <name>value</name> &lt;&lt; <name><name>state</name>-&gt;<name>bits</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>bits</name></name> += <name>bits</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateInit2_</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>windowBits</name></type></decl></param>, <param><decl><type><name>version</name></type></decl></param>, <param><decl><type><name>stream_size</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>windowBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>version</name> == <name>Z_NULL</name> || <name><name>version</name><index>[<expr>0</expr>]</index></name> != <name><name>ZLIB_VERSION</name><index>[<expr>0</expr>]</index></name> ||
        <name>stream_size</name> != <call>(<name>int</name>)<argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>Z_VERSION_ERROR</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>                 <comment type="block">/* in case we return an error */</comment>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>zalloc</name></name> == (<name>alloc_func</name>)0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>zalloc</name></name> = <name>zcalloc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>opaque</name></name> = (<name>voidpf</name>)0</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>zfree</name></name> == (<name>free_func</name>)0</expr>)</condition><then> <expr_stmt><expr><name><name>strm</name>-&gt;<name>zfree</name></name> = <name>zcfree</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)
            <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>inflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>state</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate: allocated\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name></name> = (struct <name>internal_state</name> <name>FAR</name> *)<name>state</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>windowBits</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>wrap</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>windowBits</name> = -<name>windowBits</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>wrap</name></name> = (<name>windowBits</name> &gt;&gt; 4) + 1</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
        <if>if <condition>(<expr><name>windowBits</name> &lt; 48</expr>)</condition><then> <expr_stmt><expr><name>windowBits</name> &amp;= 15</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
    <if>if <condition>(<expr><name>windowBits</name> &lt; 8 || <name>windowBits</name> &gt; 15</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>wbits</name></name> = (<name>unsigned</name>)<name>windowBits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>window</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <return>return <expr><call><name>inflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateInit_</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>version</name></type></decl></param>, <param><decl><type><name>stream_size</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
<block>{
    <return>return <expr><call><name>inflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>DEF_WBITS</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */</comment>
<function><type><name>local</name> <name>void</name></type> <name>fixedtables</name><parameter_list>(<param><decl><type><name>state</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BUILDFIXED</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>virgin</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>code</name> *</type><name>lenfix</name></decl>, *<decl><type ref="prev"/><name>distfix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>code</name></type> <name><name>fixed</name><index>[<expr>544</expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* build fixed huffman tables if first call (may not be thread safe) */</comment>
    <if>if <condition>(<expr><name>virgin</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>sym</name></decl>, <decl><type ref="prev"/><name>bits</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>static</specifier> <name>code</name> *</type><name>next</name></decl>;</decl_stmt>

        <comment type="block">/* literal/length table */</comment>
        <expr_stmt><expr><name>sym</name> = 0</expr>;</expr_stmt>
        <while>while <condition>(<expr><name>sym</name> &lt; 144</expr>)</condition> <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name>sym</name>++</expr>]</index></name> = 8</expr>;</expr_stmt></while>
        <while>while <condition>(<expr><name>sym</name> &lt; 256</expr>)</condition> <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name>sym</name>++</expr>]</index></name> = 9</expr>;</expr_stmt></while>
        <while>while <condition>(<expr><name>sym</name> &lt; 280</expr>)</condition> <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name>sym</name>++</expr>]</index></name> = 7</expr>;</expr_stmt></while>
        <while>while <condition>(<expr><name>sym</name> &lt; 288</expr>)</condition> <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name>sym</name>++</expr>]</index></name> = 8</expr>;</expr_stmt></while>
        <expr_stmt><expr><name>next</name> = <name>fixed</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lenfix</name> = <name>next</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = 9</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>inflate_table</name><argument_list>(<argument><expr><name>LENS</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>lens</name></name></expr></argument>, <argument><expr>288</expr></argument>, <argument><expr>&amp;(<name>next</name>)</expr></argument>, <argument><expr>&amp;(<name>bits</name>)</expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* distance table */</comment>
        <expr_stmt><expr><name>sym</name> = 0</expr>;</expr_stmt>
        <while>while <condition>(<expr><name>sym</name> &lt; 32</expr>)</condition> <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name>sym</name>++</expr>]</index></name> = 5</expr>;</expr_stmt></while>
        <expr_stmt><expr><name>distfix</name> = <name>next</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bits</name> = 5</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>inflate_table</name><argument_list>(<argument><expr><name>DISTS</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>lens</name></name></expr></argument>, <argument><expr>32</expr></argument>, <argument><expr>&amp;(<name>next</name>)</expr></argument>, <argument><expr>&amp;(<name>bits</name>)</expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* do this just once */</comment>
        <expr_stmt><expr><name>virgin</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !BUILDFIXED */</comment>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>"inffixed.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* BUILDFIXED */</comment>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>lencode</name></name> = <name>lenfix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>lenbits</name></name> = 9</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>distcode</name></name> = <name>distfix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>distbits</name></name> = 5</expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAKEFIXED</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
   those tables to stdout, which would be piped to inffixed.h.  A small program
   can simply call makefixed to do this:

    void makefixed(void);

    int main(void)
    {
        makefixed();
        return 0;
    }

   Then that can be linked with zlib built with MAKEFIXED defined and run:

    a.out &gt; inffixed.h
 */</comment>
<function><type><name>void</name></type> <name>makefixed</name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>low</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>inflate_state</name></type> <name>state</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fixedtables</name><argument_list>(<argument><expr>&amp;<name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"    /* inffixed.h -- table for decoding fixed codes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"     * Generated automatically by makefixed()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"     */"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"    /* WARNING: this file should *not* be used by applications."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"       It is part of the implementation of this library and is"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"       subject to change. Applications should only use zlib.h."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"     */"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> = 1U &lt;&lt; 9</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"    static const code lenfix[%u] = {"</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>low</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <if>if <condition>(<expr>(<name>low</name> % 7) == 0</expr>)</condition><then> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n        "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"{%u,%u,%d}"</expr></argument>, <argument><expr><name><name>state</name>.<name>lencode</name><index>[<expr><name>low</name></expr>]</index></name>.<name>op</name></expr></argument>, <argument><expr><name><name>state</name>.<name>lencode</name><index>[<expr><name>low</name></expr>]</index></name>.<name>bits</name></expr></argument>,
               <argument><expr><name><name>state</name>.<name>lencode</name><index>[<expr><name>low</name></expr>]</index></name>.<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>++<name>low</name> == <name>size</name></expr>)</condition><then> <break>break;</break></then></if>
        <expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"\n    };"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> = 1U &lt;&lt; 5</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n    static const code distfix[%u] = {"</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>low</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <if>if <condition>(<expr>(<name>low</name> % 6) == 0</expr>)</condition><then> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n        "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"{%u,%u,%d}"</expr></argument>, <argument><expr><name><name>state</name>.<name>distcode</name><index>[<expr><name>low</name></expr>]</index></name>.<name>op</name></expr></argument>, <argument><expr><name><name>state</name>.<name>distcode</name><index>[<expr><name>low</name></expr>]</index></name>.<name>bits</name></expr></argument>,
               <argument><expr><name><name>state</name>.<name>distcode</name><index>[<expr><name>low</name></expr>]</index></name>.<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>++<name>low</name> == <name>size</name></expr>)</condition><then> <break>break;</break></then></if>
        <expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr>"\n    };"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MAKEFIXED */</comment>

<comment type="block">/*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
 */</comment>
<function><type><name>local</name> <name>int</name></type> <name>updatewindow</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>out</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>out</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>copy</name></decl>, <decl><type ref="prev"/><name>dist</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/* if it hasn't been done already, allocate space for the window */</comment>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>window</name></name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>window</name></name> = (<name>unsigned</name> <name>char</name> <name>FAR</name> *)
                        <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr>1U &lt;&lt; <name><name>state</name>-&gt;<name>wbits</name></name></expr></argument>,
                               <argument><expr>sizeof(<name>unsigned</name> <name>char</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>state</name>-&gt;<name>window</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
    }</block></then></if>

    <comment type="block">/* if window not in use yet, initialize */</comment>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>wsize</name></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>wsize</name></name> = 1U &lt;&lt; <name><name>state</name>-&gt;<name>wbits</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>write</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>whave</name></name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* copy state-&gt;wsize or less output bytes into the circular window */</comment>
    <expr_stmt><expr><name>copy</name> = <name>out</name> - <name><name>strm</name>-&gt;<name>avail_out</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>copy</name> &gt;= <name><name>state</name>-&gt;<name>wsize</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_out</name></name> - <name><name>state</name>-&gt;<name>wsize</name></name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>wsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>write</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>whave</name></name> = <name><name>state</name>-&gt;<name>wsize</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>dist</name> = <name><name>state</name>-&gt;<name>wsize</name></name> - <name><name>state</name>-&gt;<name>write</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>dist</name> &gt; <name>copy</name></expr>)</condition><then> <expr_stmt><expr><name>dist</name> = <name>copy</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>window</name></name> + <name><name>state</name>-&gt;<name>write</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_out</name></name> - <name>copy</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>copy</name> -= <name>dist</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>copy</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_out</name></name> - <name>copy</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>write</name></name> = <name>copy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>whave</name></name> = <name><name>state</name>-&gt;<name>wsize</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>state</name>-&gt;<name>write</name></name> += <name>dist</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>write</name></name> == <name><name>state</name>-&gt;<name>wsize</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>state</name>-&gt;<name>write</name></name> = 0</expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>whave</name></name> &lt; <name><name>state</name>-&gt;<name>wsize</name></name></expr>)</condition><then> <expr_stmt><expr><name><name>state</name>-&gt;<name>whave</name></name> += <name>dist</name></expr>;</expr_stmt></then></if>
        }</block></else></if>
    }</block></else></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Macros for inflate(): */</comment>

<comment type="block">/* check function to use adler32() for zlib or crc32() for gzip */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE</name><parameter_list>(<param><type><name>check</name></type></param>, <param><type><name>buf</name></type></param>, <param><type><name>len</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>(state-&gt;flags ? crc32(check, buf, len) : adler32(check, buf, len))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE</name><parameter_list>(<param><type><name>check</name></type></param>, <param><type><name>buf</name></type></param>, <param><type><name>len</name></type></param>)</parameter_list></cpp:macro> <cpp:value>adler32(check, buf, len)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* check macros for header crc */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CRC2</name><parameter_list>(<param><type><name>check</name></type></param>, <param><type><name>word</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) &gt;&gt; 8); \
        check = crc32(check, hbuf, 2); \
    } while (0)</cpp:value></cpp:define>

<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CRC4</name><parameter_list>(<param><type><name>check</name></type></param>, <param><type><name>word</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) &gt;&gt; 8); \
        hbuf[2] = (unsigned char)((word) &gt;&gt; 16); \
        hbuf[3] = (unsigned char)((word) &gt;&gt; 24); \
        check = crc32(check, hbuf, 4); \
    } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Load registers with state in inflate() for speed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        put = strm-&gt;next_out; \
        left = strm-&gt;avail_out; \
        next = strm-&gt;next_in; \
        have = strm-&gt;avail_in; \
        hold = state-&gt;hold; \
        bits = state-&gt;bits; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Restore state from registers in inflate() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        strm-&gt;next_out = put; \
        strm-&gt;avail_out = left; \
        strm-&gt;next_in = next; \
        strm-&gt;avail_in = have; \
        state-&gt;hold = hold; \
        state-&gt;bits = bits; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Clear the input bit accumulator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITBITS</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold = 0; \
        bits = 0; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Get a byte of input into the bit accumulator, or return from inflate()
   if there is no input available. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PULLBYTE</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        if (have == 0) goto inf_leave; \
        have--; \
        hold += (unsigned long)(*next++) &lt;&lt; bits; \
        bits += 8; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflate(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEEDBITS</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        while (bits &lt; (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Return the low n bits of the bit accumulator (n &lt; 16) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))</cpp:value></cpp:define>

<comment type="block">/* Remove n bits from the bit accumulator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DROPBITS</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold &gt;&gt;= (n); \
        bits -= (unsigned)(n); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Remove zero to seven bits as needed to go to a byte boundary */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEBITS</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        hold &gt;&gt;= bits &amp; 7; \
        bits -= bits &amp; 7; \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Reverse the bytes in a 32-bit value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REVERSE</name><parameter_list>(<param><type><name>q</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((((q) &gt;&gt; 24) &amp; 0xff) + (((q) &gt;&gt; 8) &amp; 0xff00) + \
     (((q) &amp; 0xff00) &lt;&lt; 8) + (((q) &amp; 0xff) &lt;&lt; 24))</cpp:value></cpp:define>

<comment type="block">/*
   inflate() uses a state machine to process as much input data and generate as
   much output data as possible before returning.  The state machine is
   structured roughly as follows:

    for (;;) switch (state) {
    ...
    case STATEn:
        if (not enough input data or output space to make progress)
            return;
        ... make progress ...
        state = STATEm;
        break;
    ...
    }

   so when inflate() is called again, the same case is attempted again, and
   if the appropriate resources are provided, the machine proceeds to the
   next state.  The NEEDBITS() macro is usually the way the state evaluates
   whether it can proceed or should return.  NEEDBITS() does the return if
   the requested bits are not available.  The typical use of the BITS macros
   is:

        NEEDBITS(n);
        ... do something with BITS(n) ...
        DROPBITS(n);

   where NEEDBITS(n) either returns from inflate() if there isn't enough
   input left to load n bits into the accumulator, or it continues.  BITS(n)
   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   the low n bits off the accumulator.  INITBITS() clears the accumulator
   and sets the number of available bits to zero.  BYTEBITS() discards just
   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.

   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   if there is no input available.  The decoding of variable length codes uses
   PULLBYTE() directly in order to pull just enough bytes to decode the next
   code, and no more.

   Some states loop until they get enough input, making sure that enough
   state information is maintained to continue the loop where it left off
   if NEEDBITS() returns in the loop.  For example, want, need, and keep
   would all have to actually be part of the saved state in case NEEDBITS()
   returns:

    case STATEw:
        while (want &lt; need) {
            NEEDBITS(n);
            keep[want++] = BITS(n);
            DROPBITS(n);
        }
        state = STATEx;
    case STATEx:

   As shown above, if the next state is also the next case, then the break
   is omitted.

   A state may also return if there is not enough output space available to
   complete that state.  Those states are copying stored data, writing a
   literal byte, and copying a matching string.

   When returning, a "goto inf_leave" is used to update the total counters,
   update the check value, and determine whether any progress has been made
   during that inflate() call in order to return the proper return code.
   Progress is defined as a change in either strm-&gt;avail_in or strm-&gt;avail_out.
   When there is a window, goto inf_leave will update the window with the last
   output written.  If a goto inf_leave occurs in the middle of decompression
   and there is no window currently, goto inf_leave will create one and copy
   output to the window for the next call of inflate().

   In this implementation, the flush parameter of inflate() only affects the
   return code (per zlib.h).  inflate() always writes as much as possible to
   strm-&gt;next_out, given the space available and the provided input--the effect
   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   the allocation of and copying into a sliding window until necessary, which
   provides the effect documented in zlib.h for Z_FINISH when the entire input
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */</comment>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflate</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>flush</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> *</type><name>next</name></decl>;</decl_stmt>    <comment type="block">/* next input */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> *</type><name>put</name></decl>;</decl_stmt>     <comment type="block">/* next output */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>have</name></decl>, <decl><type ref="prev"/><name>left</name></decl>;</decl_stmt>        <comment type="block">/* available input and output */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hold</name></decl>;</decl_stmt>         <comment type="block">/* bit buffer */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>bits</name></decl>;</decl_stmt>              <comment type="block">/* bits in bit buffer */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>           <comment type="block">/* save starting available input and output */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>copy</name></decl>;</decl_stmt>              <comment type="block">/* number of stored or match bytes to copy */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> *</type><name>from</name></decl>;</decl_stmt>    <comment type="block">/* where to copy match bytes from */</comment>
    <decl_stmt><decl><type><name>code</name></type> <name>this</name></decl>;</decl_stmt>                  <comment type="block">/* current decoding table entry */</comment>
    <decl_stmt><decl><type><name>code</name></type> <name>last</name></decl>;</decl_stmt>                  <comment type="block">/* parent table entry */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>               <comment type="block">/* length to copy for repeats, bits to drop */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>                    <comment type="block">/* return code */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hbuf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* buffer for gzip header crc calculation */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name><name>order</name><index>[<expr>19</expr>]</index></name> <init>= <comment type="block">/* permutation of code lengths */</comment>
        <expr><block>{<expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>0</expr>, <expr>8</expr>, <expr>7</expr>, <expr>9</expr>, <expr>6</expr>, <expr>10</expr>, <expr>5</expr>, <expr>11</expr>, <expr>4</expr>, <expr>12</expr>, <expr>3</expr>, <expr>13</expr>, <expr>2</expr>, <expr>14</expr>, <expr>1</expr>, <expr>15</expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>next_out</name></name> == <name>Z_NULL</name> ||
        (<name><name>strm</name>-&gt;<name>next_in</name></name> == <name>Z_NULL</name> &amp;&amp; <name><name>strm</name>-&gt;<name>avail_in</name></name> != 0)</expr>)</condition><then>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>mode</name></name> == <name>TYPE</name></expr>)</condition><then> <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TYPEDO</name></expr>;</expr_stmt></then></if>      <comment type="block">/* skip check */</comment>
    <expr_stmt><expr><call><name>LOAD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>in</name> = <name>have</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>out</name> = <name>left</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> = <name>Z_OK</name></expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>)
        <switch>switch <condition>(<expr><name><name>state</name>-&gt;<name>mode</name></name></expr>)</condition> <block>{
        <case>case <expr><name>HEAD</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>wrap</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TYPEDO</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
            <if>if <condition>(<expr>(<name><name>state</name>-&gt;<name>wrap</name></name> &amp; 2) &amp;&amp; <name>hold</name> == 0x8b1f</expr>)</condition><then> <block>{  <comment type="block">/* gzip header */</comment>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>check</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CRC2</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>FLAGS</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>flags</name></name> = 0</expr>;</expr_stmt>           <comment type="block">/* expect zlib header */</comment>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>done</name></name> = -1</expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr>!(<name><name>state</name>-&gt;<name>wrap</name></name> &amp; 1) ||</expr></condition></if>   <comment type="block">/* check if zlib header allowed */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if>if <condition>(
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr>((<call><name>BITS</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call> &lt;&lt; 8) + (<name>hold</name> &gt;&gt; 8)) % 31</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"incorrect header check"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call> != <name>Z_DEFLATED</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"unknown compression method"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> = <call><name>BITS</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call> + 8</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>len</name> &gt; <name><name>state</name>-&gt;<name>wbits</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid window size"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>dmax</name></name> = 1U &lt;&lt; <name>len</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:   zlib header ok\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <name><name>state</name>-&gt;<name>check</name></name> = <call><name>adler32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>hold</name> &amp; 0x200 ? <name>DICTID</name> : <name>TYPE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
        </case><case>case <expr><name>FLAGS</name></expr>:
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>flags</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name><name>state</name>-&gt;<name>flags</name></name> &amp; 0xff) != <name>Z_DEFLATED</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"unknown compression method"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0xe000</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"unknown header flags set"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>text</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr>(<name>hold</name> &gt;&gt; 8) &amp; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0200</expr>)</condition><then> <expr_stmt><expr><call><name>CRC2</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TIME</name></expr>;</expr_stmt>
        </case><case>case <expr><name>TIME</name></expr>:
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>time</name></name> = <name>hold</name></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0200</expr>)</condition><then> <expr_stmt><expr><call><name>CRC4</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>OS</name></expr>;</expr_stmt>
        </case><case>case <expr><name>OS</name></expr>:
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>xflags</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>hold</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>os</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>hold</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0200</expr>)</condition><then> <expr_stmt><expr><call><name>CRC2</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>EXLEN</name></expr>;</expr_stmt>
        </case><case>case <expr><name>EXLEN</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0400</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> = <call>(<name>unsigned</name>)<argument_list>(<argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>extra_len</name></name> = (<name>unsigned</name>)<name>hold</name></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0200</expr>)</condition><then> <expr_stmt><expr><call><name>CRC2</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>extra</name></name> = <name>Z_NULL</name></expr>;</expr_stmt></then></if></else></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>EXTRA</name></expr>;</expr_stmt>
        </case><case>case <expr><name>EXTRA</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0400</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>copy</name> = <name><name>state</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>copy</name> &gt; <name>have</name></expr>)</condition><then> <expr_stmt><expr><name>copy</name> = <name>have</name></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><name>copy</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name> &amp;&amp;
                        <name><name>state</name>-&gt;<name>head</name>-&gt;<name>extra</name></name> != <name>Z_NULL</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>len</name> = <name><name>state</name>-&gt;<name>head</name>-&gt;<name>extra_len</name></name> - <name><name>state</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>extra</name></name> + <name>len</name></expr></argument>, <argument><expr><name>next</name></expr></argument>,
                                <argument><expr><name>len</name> + <name>copy</name> &gt; <name><name>state</name>-&gt;<name>head</name>-&gt;<name>extra_max</name></name> ?
                                <name><name>state</name>-&gt;<name>head</name>-&gt;<name>extra_max</name></name> - <name>len</name> : <name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0200</expr>)</condition><then>
                        <expr_stmt><expr><name><name>state</name>-&gt;<name>check</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><name>have</name> -= <name>copy</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>next</name> += <name>copy</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> -= <name>copy</name></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>state</name>-&gt;<name>length</name></name></expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
            }</block></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>NAME</name></expr>;</expr_stmt>
        </case><case>case <expr><name>NAME</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0800</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>have</name> == 0</expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
                <expr_stmt><expr><name>copy</name> = 0</expr>;</expr_stmt>
                <do>do <block>{
                    <expr_stmt><expr><name>len</name> = <call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>next</name><index>[<expr><name>copy</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name> &amp;&amp;
                            <name><name>state</name>-&gt;<name>head</name>-&gt;<name>name</name></name> != <name>Z_NULL</name> &amp;&amp;
                            <name><name>state</name>-&gt;<name>length</name></name> &lt; <name><name>state</name>-&gt;<name>head</name>-&gt;<name>name_max</name></name></expr>)</condition><then>
                        <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>name</name><index>[<expr><name><name>state</name>-&gt;<name>length</name></name>++</expr>]</index></name> = <name>len</name></expr>;</expr_stmt></then></if>
                }</block> while <condition>(<expr><name>len</name> &amp;&amp; <name>copy</name> &lt; <name>have</name></expr>)</condition>;</do>
                <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0200</expr>)</condition><then>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>check</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>have</name> -= <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next</name> += <name>copy</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>len</name></expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>name</name></name> = <name>Z_NULL</name></expr>;</expr_stmt></then></if></else></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>COMMENT</name></expr>;</expr_stmt>
        </case><case>case <expr><name>COMMENT</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x1000</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>have</name> == 0</expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
                <expr_stmt><expr><name>copy</name> = 0</expr>;</expr_stmt>
                <do>do <block>{
                    <expr_stmt><expr><name>len</name> = <call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>next</name><index>[<expr><name>copy</name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name> &amp;&amp;
                            <name><name>state</name>-&gt;<name>head</name>-&gt;<name>comment</name></name> != <name>Z_NULL</name> &amp;&amp;
                            <name><name>state</name>-&gt;<name>length</name></name> &lt; <name><name>state</name>-&gt;<name>head</name>-&gt;<name>comm_max</name></name></expr>)</condition><then>
                        <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>comment</name><index>[<expr><name><name>state</name>-&gt;<name>length</name></name>++</expr>]</index></name> = <name>len</name></expr>;</expr_stmt></then></if>
                }</block> while <condition>(<expr><name>len</name> &amp;&amp; <name>copy</name> &lt; <name>have</name></expr>)</condition>;</do>
                <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0200</expr>)</condition><then>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>check</name></name> = <call><name>crc32</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>have</name> -= <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next</name> += <name>copy</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>len</name></expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>comment</name></name> = <name>Z_NULL</name></expr>;</expr_stmt></then></if></else></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>HCRC</name></expr>;</expr_stmt>
        </case><case>case <expr><name>HCRC</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; 0x0200</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>hold</name> != (<name><name>state</name>-&gt;<name>check</name></name> &amp; 0xffff)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"header crc mismatch"</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>head</name></name> != <name>Z_NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>hcrc</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr>(<name><name>state</name>-&gt;<name>flags</name></name> &gt;&gt; 9) &amp; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name>-&gt;<name>done</name></name> = 1</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <name><name>state</name>-&gt;<name>check</name></name> = <call><name>crc32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TYPE</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </case><case>case <expr><name>DICTID</name></expr>:
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <name><name>state</name>-&gt;<name>check</name></name> = <call><name>REVERSE</name><argument_list>(<argument><expr><name>hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>DICT</name></expr>;</expr_stmt>
        </case><case>case <expr><name>DICT</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>havedict</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>RESTORE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>Z_NEED_DICT</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <name><name>state</name>-&gt;<name>check</name></name> = <call><name>adler32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TYPE</name></expr>;</expr_stmt>
        </case><case>case <expr><name>TYPE</name></expr>:
            <if>if <condition>(<expr><name>flush</name> == <name>Z_BLOCK</name></expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
        </case><case>case <expr><name>TYPEDO</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>last</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>BYTEBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>CHECK</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>last</name></name> = <call><name>BITS</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <case>case <expr>0</expr>:                             <comment type="block">/* stored block */</comment>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:     stored block%s\n",
                        <name><name>state</name>-&gt;<name>last</name></name> ? " (last)" : "")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>STORED</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>1</expr>:                             <comment type="block">/* fixed block */</comment>
                <expr_stmt><expr><call><name>fixedtables</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:     fixed codes block%s\n",
                        <name><name>state</name>-&gt;<name>last</name></name> ? " (last)" : "")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>LEN</name></expr>;</expr_stmt>              <comment type="block">/* decode codes */</comment>
                <break>break;</break>
            </case><case>case <expr>2</expr>:                             <comment type="block">/* dynamic block */</comment>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:     dynamic codes block%s\n",
                        <name><name>state</name>-&gt;<name>last</name></name> ? " (last)" : "")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TABLE</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>3</expr>:
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid block type"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
            </case>}</block></switch>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>STORED</name></expr>:
            <expr_stmt><expr><call><name>BYTEBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>                         <comment type="block">/* go to byte boundary */</comment>
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>hold</name> &amp; 0xffff) != ((<name>hold</name> &gt;&gt; 16) ^ 0xffff)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid stored block lengths"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> = (<name>unsigned</name>)<name>hold</name> &amp; 0xffff</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:       stored length %u\n",
                    <name><name>state</name>-&gt;<name>length</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>COPY</name></expr>;</expr_stmt>
        </case><case>case <expr><name>COPY</name></expr>:
            <expr_stmt><expr><name>copy</name> = <name><name>state</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>copy</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>copy</name> &gt; <name>have</name></expr>)</condition><then> <expr_stmt><expr><name>copy</name> = <name>have</name></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><name>copy</name> &gt; <name>left</name></expr>)</condition><then> <expr_stmt><expr><name>copy</name> = <name>left</name></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><name>copy</name> == 0</expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
                <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>put</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>have</name> -= <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next</name> += <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>left</name> -= <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>put</name> += <name>copy</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> -= <name>copy</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:       stored end\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TYPE</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>TABLE</name></expr>:
            <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>14</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>nlen</name></name> = <call><name>BITS</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call> + 257</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>ndist</name></name> = <call><name>BITS</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>ncode</name></name> = <call><name>BITS</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call> + 4</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PKZIP_BUG_WORKAROUND</name></cpp:ifndef>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>nlen</name></name> &gt; 286 || <name><name>state</name>-&gt;<name>ndist</name></name> &gt; 30</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"too many length or distance symbols"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:       table sizes ok\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>have</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>LENLENS</name></expr>;</expr_stmt>
        </case><case>case <expr><name>LENLENS</name></expr>:
            <while>while <condition>(<expr><name><name>state</name>-&gt;<name>have</name></name> &lt; <name><name>state</name>-&gt;<name>ncode</name></name></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name><name>order</name><index>[<expr><name><name>state</name>-&gt;<name>have</name></name>++</expr>]</index></name></expr>]</index></name> = (<name>unsigned</name> <name>short</name>)<call><name>BITS</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <while>while <condition>(<expr><name><name>state</name>-&gt;<name>have</name></name> &lt; 19</expr>)</condition>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name><name>order</name><index>[<expr><name><name>state</name>-&gt;<name>have</name></name>++</expr>]</index></name></expr>]</index></name> = 0</expr>;</expr_stmt></while>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>next</name></name> = <name><name>state</name>-&gt;<name>codes</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>lencode</name></name> = (<name>code</name> const <name>FAR</name> *)(<name><name>state</name>-&gt;<name>next</name></name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>lenbits</name></name> = 7</expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> = <call><name>inflate_table</name><argument_list>(<argument><expr><name>CODES</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>lens</name></name></expr></argument>, <argument><expr>19</expr></argument>, <argument><expr>&amp;(<name><name>state</name>-&gt;<name>next</name></name>)</expr></argument>,
                                <argument><expr>&amp;(<name><name>state</name>-&gt;<name>lenbits</name></name>)</expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ret</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid code lengths set"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:       code lengths ok\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>have</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>CODELENS</name></expr>;</expr_stmt>
        </case><case>case <expr><name>CODELENS</name></expr>:
            <while>while <condition>(<expr><name><name>state</name>-&gt;<name>have</name></name> &lt; <name><name>state</name>-&gt;<name>nlen</name></name> + <name><name>state</name>-&gt;<name>ndist</name></name></expr>)</condition> <block>{
                <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                    <expr_stmt><expr><name>this</name> = <name><name>state</name>-&gt;<name>lencode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>lenbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call> &lt;= <name>bits</name></expr>)</condition><then> <break>break;</break></then></if>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <if>if <condition>(<expr><name><name>this</name>.<name>val</name></name> &lt; 16</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name><name>state</name>-&gt;<name>have</name></name>++</expr>]</index></name> = <name><name>this</name>.<name>val</name></name></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <if>if <condition>(<expr><name><name>this</name>.<name>val</name></name> == 16</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name><name>state</name>-&gt;<name>have</name></name> == 0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid bit length repeat"</expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                            <break>break;</break>
                        }</block></then></if>
                        <expr_stmt><expr><name>len</name> = <name><name>state</name>-&gt;<name>lens</name><index>[<expr><name><name>state</name>-&gt;<name>have</name></name> - 1</expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> = 3 + <call><name>BITS</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name><name>this</name>.<name>val</name></name> == 17</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name> + 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> = 3 + <call><name>BITS</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name> + 7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
                        <expr_stmt><expr><name>copy</name> = 11 + <call><name>BITS</name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if></else></if>
                    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>have</name></name> + <name>copy</name> &gt; <name><name>state</name>-&gt;<name>nlen</name></name> + <name><name>state</name>-&gt;<name>ndist</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid bit length repeat"</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <while>while <condition>(<expr><name>copy</name>--</expr>)</condition>
                        <expr_stmt><expr><name><name>state</name>-&gt;<name>lens</name><index>[<expr><name><name>state</name>-&gt;<name>have</name></name>++</expr>]</index></name> = (<name>unsigned</name> <name>short</name>)<name>len</name></expr>;</expr_stmt></while>
                }</block></else></if>
            }</block></while>

            <comment type="block">/* handle error breaks in while */</comment>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>mode</name></name> == <name>BAD</name></expr>)</condition><then> <break>break;</break></then></if>

            <comment type="block">/* build code tables */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>next</name></name> = <name><name>state</name>-&gt;<name>codes</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>lencode</name></name> = (<name>code</name> const <name>FAR</name> *)(<name><name>state</name>-&gt;<name>next</name></name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>lenbits</name></name> = 9</expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> = <call><name>inflate_table</name><argument_list>(<argument><expr><name>LENS</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>lens</name></name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>nlen</name></name></expr></argument>, <argument><expr>&amp;(<name><name>state</name>-&gt;<name>next</name></name>)</expr></argument>,
                                <argument><expr>&amp;(<name><name>state</name>-&gt;<name>lenbits</name></name>)</expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ret</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid literal/lengths set"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>distcode</name></name> = (<name>code</name> const <name>FAR</name> *)(<name><name>state</name>-&gt;<name>next</name></name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>distbits</name></name> = 6</expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> = <call><name>inflate_table</name><argument_list>(<argument><expr><name>DISTS</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>lens</name></name> + <name><name>state</name>-&gt;<name>nlen</name></name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>ndist</name></name></expr></argument>,
                            <argument><expr>&amp;(<name><name>state</name>-&gt;<name>next</name></name>)</expr></argument>, <argument><expr>&amp;(<name><name>state</name>-&gt;<name>distbits</name></name>)</expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>work</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ret</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid distances set"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:       codes ok\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>LEN</name></expr>;</expr_stmt>
        </case><case>case <expr><name>LEN</name></expr>:
            <if>if <condition>(<expr><name>have</name> &gt;= 6 &amp;&amp; <name>left</name> &gt;= 258</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>RESTORE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>inflate_fast</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOAD</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                <expr_stmt><expr><name>this</name> = <name><name>state</name>-&gt;<name>lencode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>lenbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call> &lt;= <name>bits</name></expr>)</condition><then> <break>break;</break></then></if>
                <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <if>if <condition>(<expr><name><name>this</name>.<name>op</name></name> &amp;&amp; (<name><name>this</name>.<name>op</name></name> &amp; 0xf0) == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>last</name> = <name>this</name></expr>;</expr_stmt>
                <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                    <expr_stmt><expr><name>this</name> = <name><name>state</name>-&gt;<name>lencode</name><index>[<expr><name><name>last</name>.<name>val</name></name> +
                            (<call><name>BITS</name><argument_list>(<argument><expr><name><name>last</name>.<name>bits</name></name> + <name><name>last</name>.<name>op</name></name></expr></argument>)</argument_list></call> &gt;&gt; <name><name>last</name>.<name>bits</name></name>)</expr>]</index></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>last</name>.<name>bits</name></name> + <name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call> &lt;= <name>bits</name></expr>)</condition><then> <break>break;</break></then></if>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>last</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> = (<name>unsigned</name>)<name><name>this</name>.<name>val</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>this</name>.<name>op</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>, <name><name>this</name>.<name>val</name></name> &gt;= 0x20 &amp;&amp; <name><name>this</name>.<name>val</name></name> &lt; 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", <name><name>this</name>.<name>val</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>LIT</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>this</name>.<name>op</name></name> &amp; 32</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:         end of block\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TYPE</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>this</name>.<name>op</name></name> &amp; 64</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid literal/length code"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>extra</name></name> = <call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>this</name>.<name>op</name></name></expr></argument>)</argument_list></call> &amp; 15</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>LENEXT</name></expr>;</expr_stmt>
        </case><case>case <expr><name>LENEXT</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>extra</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> += <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:         length %u\n", <name><name>state</name>-&gt;<name>length</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>DIST</name></expr>;</expr_stmt>
        </case><case>case <expr><name>DIST</name></expr>:
            <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                <expr_stmt><expr><name>this</name> = <name><name>state</name>-&gt;<name>distcode</name><index>[<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>distbits</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call> &lt;= <name>bits</name></expr>)</condition><then> <break>break;</break></then></if>
                <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <if>if <condition>(<expr>(<name><name>this</name>.<name>op</name></name> &amp; 0xf0) == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>last</name> = <name>this</name></expr>;</expr_stmt>
                <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                    <expr_stmt><expr><name>this</name> = <name><name>state</name>-&gt;<name>distcode</name><index>[<expr><name><name>last</name>.<name>val</name></name> +
                            (<call><name>BITS</name><argument_list>(<argument><expr><name><name>last</name>.<name>bits</name></name> + <name><name>last</name>.<name>op</name></name></expr></argument>)</argument_list></call> &gt;&gt; <name><name>last</name>.<name>bits</name></name>)</expr>]</index></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>last</name>.<name>bits</name></name> + <name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call> &lt;= <name>bits</name></expr>)</condition><then> <break>break;</break></then></if>
                    <expr_stmt><expr><call><name>PULLBYTE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>last</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>this</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>this</name>.<name>op</name></name> &amp; 64</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid distance code"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>offset</name></name> = (<name>unsigned</name>)<name><name>this</name>.<name>val</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>extra</name></name> = <call>(<name>unsigned</name>)<argument_list>(<argument><expr><name><name>this</name>.<name>op</name></name></expr></argument>)</argument_list></call> &amp; 15</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>DISTEXT</name></expr>;</expr_stmt>
        </case><case>case <expr><name>DISTEXT</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>extra</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>offset</name></name> += <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DROPBITS</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INFLATE_STRICT</name></cpp:ifdef>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>offset</name></name> &gt; <name><name>state</name>-&gt;<name>dmax</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid distance too far back"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>offset</name></name> &gt; <name><name>state</name>-&gt;<name>whave</name></name> + <name>out</name> - <name>left</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"invalid distance too far back"</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:         distance %u\n", <name><name>state</name>-&gt;<name>offset</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>MATCH</name></expr>;</expr_stmt>
        </case><case>case <expr><name>MATCH</name></expr>:
            <if>if <condition>(<expr><name>left</name> == 0</expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
            <expr_stmt><expr><name>copy</name> = <name>out</name> - <name>left</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>offset</name></name> &gt; <name>copy</name></expr>)</condition><then> <block>{         <comment type="block">/* copy from window */</comment>
                <expr_stmt><expr><name>copy</name> = <name><name>state</name>-&gt;<name>offset</name></name> - <name>copy</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>copy</name> &gt; <name><name>state</name>-&gt;<name>write</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>copy</name> -= <name><name>state</name>-&gt;<name>write</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>from</name> = <name><name>state</name>-&gt;<name>window</name></name> + (<name><name>state</name>-&gt;<name>wsize</name></name> - <name>copy</name>)</expr>;</expr_stmt>
                }</block></then>
                <else>else
                    <expr_stmt><expr><name>from</name> = <name><name>state</name>-&gt;<name>window</name></name> + (<name><name>state</name>-&gt;<name>write</name></name> - <name>copy</name>)</expr>;</expr_stmt></else></if>
                <if>if <condition>(<expr><name>copy</name> &gt; <name><name>state</name>-&gt;<name>length</name></name></expr>)</condition><then> <expr_stmt><expr><name>copy</name> = <name><name>state</name>-&gt;<name>length</name></name></expr>;</expr_stmt></then></if>
            }</block></then>
            <else>else <block>{                              <comment type="block">/* copy from output */</comment>
                <expr_stmt><expr><name>from</name> = <name>put</name> - <name><name>state</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>copy</name> = <name><name>state</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            }</block></else></if>
            <if>if <condition>(<expr><name>copy</name> &gt; <name>left</name></expr>)</condition><then> <expr_stmt><expr><name>copy</name> = <name>left</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>left</name> -= <name>copy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>length</name></name> -= <name>copy</name></expr>;</expr_stmt>
            <do>do <block>{
                <expr_stmt><expr>*<name>put</name>++ = *<name>from</name>++</expr>;</expr_stmt>
            }</block> while <condition>(<expr>--<name>copy</name></expr>)</condition>;</do>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>LEN</name></expr>;</expr_stmt></then></if>
            <break>break;</break>
        </case><case>case <expr><name>LIT</name></expr>:
            <if>if <condition>(<expr><name>left</name> == 0</expr>)</condition><then> <goto>goto <name>inf_leave</name>;</goto></then></if>
            <expr_stmt><expr>*<name>put</name>++ = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>state</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>left</name>--</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>LEN</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>CHECK</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>wrap</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>out</name> -= <name>left</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_out</name></name> += <name>out</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>total</name></name> += <name>out</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>out</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <name><name>state</name>-&gt;<name>check</name></name> =
                        <call><name>UPDATE</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name>put</name> - <name>out</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>out</name> = <name>left</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>(
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
                     <name><name>state</name>-&gt;<name>flags</name></name> ? <name>hold</name> :
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                     <call><name>REVERSE</name><argument_list>(<argument><expr><name>hold</name></expr></argument>)</argument_list></call>) != <name><name>state</name>-&gt;<name>check</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"incorrect data check"</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:   check matches trailer\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GUNZIP</name></cpp:ifdef>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>LENGTH</name></expr>;</expr_stmt>
        </case><case>case <expr><name>LENGTH</name></expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>wrap</name></name> &amp;&amp; <name><name>state</name>-&gt;<name>flags</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>NEEDBITS</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>hold</name> != (<name><name>state</name>-&gt;<name>total</name></name> &amp; 0xffffffffUL)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>strm</name>-&gt;<name>msg</name></name> = (<name>char</name> *)"incorrect length check"</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>BAD</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name>INITBITS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:   length matches trailer\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>DONE</name></expr>;</expr_stmt>
        </case><case>case <expr><name>DONE</name></expr>:
            <expr_stmt><expr><name>ret</name> = <name>Z_STREAM_END</name></expr>;</expr_stmt>
            <goto>goto <name>inf_leave</name>;</goto>
        </case><case>case <expr><name>BAD</name></expr>:
            <expr_stmt><expr><name>ret</name> = <name>Z_DATA_ERROR</name></expr>;</expr_stmt>
            <goto>goto <name>inf_leave</name>;</goto>
        </case><case>case <expr><name>MEM</name></expr>:
            <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
        </case><case>case <expr><name>SYNC</name></expr>:
        </case><default>default:
            <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>
        </default>}</block></switch></for>

    <comment type="block">/*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */</comment>
  <label><name>inf_leave</name>:</label>
    <expr_stmt><expr><call><name>RESTORE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>wsize</name></name> || (<name><name>state</name>-&gt;<name>mode</name></name> &lt; <name>CHECK</name> &amp;&amp; <name>out</name> != <name><name>strm</name>-&gt;<name>avail_out</name></name>)</expr>)</condition><then>
        <if>if <condition>(<expr><call><name>updatewindow</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>MEM</name></expr>;</expr_stmt>
            <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
        }</block></then></if></then></if>
    <expr_stmt><expr><name>in</name> -= <name><name>strm</name>-&gt;<name>avail_in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>out</name> -= <name><name>strm</name>-&gt;<name>avail_out</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_in</name></name> += <name>in</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_out</name></name> += <name>out</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>total</name></name> += <name>out</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>wrap</name></name> &amp;&amp; <name>out</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>strm</name>-&gt;<name>adler</name></name> = <name><name>state</name>-&gt;<name>check</name></name> =
            <call><name>UPDATE</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>check</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_out</name></name> - <name>out</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>data_type</name></name> = <name><name>state</name>-&gt;<name>bits</name></name> + (<name><name>state</name>-&gt;<name>last</name></name> ? 64 : 0) +
                      (<name><name>state</name>-&gt;<name>mode</name></name> == <name>TYPE</name> ? 128 : 0)</expr>;</expr_stmt>
    <if>if <condition>(<expr>((<name>in</name> == 0 &amp;&amp; <name>out</name> == 0) || <name>flush</name> == <name>Z_FINISH</name>) &amp;&amp; <name>ret</name> == <name>Z_OK</name></expr>)</condition><then>
        <expr_stmt><expr><name>ret</name> = <name>Z_BUF_ERROR</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateEnd</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>zfree</name></name> == (<name>free_func</name>)0</expr>)</condition><then>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>window</name></name> != <name>Z_NULL</name></expr>)</condition><then> <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>state</name></name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate: end\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateSetDictionary</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>dictionary</name></type></decl></param>, <param><decl><type><name>dictLength</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> *</type><name>dictionary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>dictLength</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>id</name></decl>;</decl_stmt>

    <comment type="block">/* check state */</comment>
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>wrap</name></name> != 0 &amp;&amp; <name><name>state</name>-&gt;<name>mode</name></name> != <name>DICT</name></expr>)</condition><then>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <comment type="block">/* check for correct dictionary id */</comment>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>mode</name></name> == <name>DICT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>id</name> = <call><name>adler32</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>id</name> = <call><name>adler32</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>id</name> != <name><name>state</name>-&gt;<name>check</name></name></expr>)</condition><then>
            <return>return <expr><name>Z_DATA_ERROR</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="block">/* copy dictionary to window */</comment>
    <if>if <condition>(<expr><call><name>updatewindow</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>avail_out</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>MEM</name></expr>;</expr_stmt>
        <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>dictLength</name> &gt; <name><name>state</name>-&gt;<name>wsize</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name>dictionary</name> + <name>dictLength</name> - <name><name>state</name>-&gt;<name>wsize</name></name></expr></argument>,
                <argument><expr><name><name>state</name>-&gt;<name>wsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>whave</name></name> = <name><name>state</name>-&gt;<name>wsize</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>window</name></name> + <name><name>state</name>-&gt;<name>wsize</name></name> - <name>dictLength</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>,
                <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>whave</name></name> = <name>dictLength</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>havedict</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tracev</name><argument_list>(<argument><expr>(<name>stderr</name>, "inflate:   dictionary set\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateGetHeader</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>, <param><decl><type><name>head</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>gz_headerp</name></type> <name>head</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>

    <comment type="block">/* check state */</comment>
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name><name>state</name>-&gt;<name>wrap</name></name> &amp; 2) == 0</expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>

    <comment type="block">/* save header structure */</comment>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>head</name></name> = <name>head</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>head</name>-&gt;<name>done</name></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
   or when out of input.  When called, *have is the number of pattern bytes
   found in order so far, in 0..3.  On return *have is updated to the new
   state.  If on return *have equals four, then the pattern was found and the
   return value is how many bytes were read including the last byte of the
   pattern.  If *have is less than four, then the pattern has not been found
   yet and the return value is len.  In the latter case, syncsearch() can be
   called again with more data and the *have state.  *have is initialized to
   zero for the first call.
 */</comment>
<function><type><name>local</name> <name>unsigned</name></type> <name>syncsearch</name><parameter_list>(<param><decl><type><name>have</name></type></decl></param>, <param><decl><type><name>buf</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>unsigned</name> <name>FAR</name> *</type><name>have</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>got</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>next</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>got</name> = *<name>have</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>next</name> = 0</expr>;</expr_stmt>
    <while>while <condition>(<expr><name>next</name> &lt; <name>len</name> &amp;&amp; <name>got</name> &lt; 4</expr>)</condition> <block>{
        <if>if <condition>(<expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>next</name></expr>]</index></name></expr></argument>)</argument_list></call> == (<name>got</name> &lt; 2 ? 0 : 0xff)</expr>)</condition><then>
            <expr_stmt><expr><name>got</name>++</expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>next</name></expr>]</index></name></expr>)</condition><then>
            <expr_stmt><expr><name>got</name> = 0</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>got</name> = 4 - <name>got</name></expr>;</expr_stmt></else></if></else></if>
        <expr_stmt><expr><name>next</name>++</expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>have</name> = <name>got</name></expr>;</expr_stmt>
    <return>return <expr><name>next</name></expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateSync</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>               <comment type="block">/* number of bytes to look at or looked at */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>      <comment type="block">/* temporary to save total_in and total_out */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* to restore bit buffer to byte string */</comment>
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>

    <comment type="block">/* check parameters */</comment>
    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>strm</name>-&gt;<name>avail_in</name></name> == 0 &amp;&amp; <name><name>state</name>-&gt;<name>bits</name></name> &lt; 8</expr>)</condition><then> <return>return <expr><name>Z_BUF_ERROR</name></expr>;</return></then></if>

    <comment type="block">/* if first time, start search in bit buffer */</comment>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>mode</name></name> != <name>SYNC</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>SYNC</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>hold</name></name> &lt;&lt;= <name><name>state</name>-&gt;<name>bits</name></name> &amp; 7</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>bits</name></name> -= <name><name>state</name>-&gt;<name>bits</name></name> &amp; 7</expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>state</name>-&gt;<name>bits</name></name> &gt;= 8</expr>)</condition> <block>{
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>++</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>state</name>-&gt;<name>hold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>hold</name></name> &gt;&gt;= 8</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>bits</name></name> -= 8</expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>have</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>syncsearch</name><argument_list>(<argument><expr>&amp;(<name><name>state</name>-&gt;<name>have</name></name>)</expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* search available input */</comment>
    <expr_stmt><expr><name>len</name> = <call><name>syncsearch</name><argument_list>(<argument><expr>&amp;(<name><name>state</name>-&gt;<name>have</name></name>)</expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>next_in</name></name></expr></argument>, <argument><expr><name><name>strm</name>-&gt;<name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>avail_in</name></name> -= <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>next_in</name></name> += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_in</name></name> += <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* return no joy or set up to restart inflate() on a new block */</comment>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>have</name></name> != 4</expr>)</condition><then> <return>return <expr><name>Z_DATA_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>in</name> = <name><name>strm</name>-&gt;<name>total_in</name></name></expr>;</expr_stmt>  <expr_stmt><expr><name>out</name> = <name><name>strm</name>-&gt;<name>total_out</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>inflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_in</name></name> = <name>in</name></expr>;</expr_stmt>  <expr_stmt><expr><name><name>strm</name>-&gt;<name>total_out</name></name> = <name>out</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>mode</name></name> = <name>TYPE</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
   Returns true if inflate is currently at the end of a block generated by
   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
   implementation to provide an additional safety check. PPP uses
   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
   block. When decompressing, PPP checks that at the end of input packet,
   inflate is waiting for these length bytes.
 */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateSyncPoint</name><parameter_list>(<param><decl><type><name>strm</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>strm</name> == <name>Z_NULL</name> || <name><name>strm</name>-&gt;<name>state</name></name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>strm</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <return>return <expr><name><name>state</name>-&gt;<name>mode</name></name> == <name>STORED</name> &amp;&amp; <name><name>state</name>-&gt;<name>bits</name></name> == 0</expr>;</return>
}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>inflateCopy</name><parameter_list>(<param><decl><type><name>dest</name></type></decl></param>, <param><decl><type><name>source</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_streamp</name></type> <name>source</name></decl>;</decl_stmt>
<block>{
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>inflate_state</name> <name>FAR</name> *</type><name>copy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>FAR</name> *</type><name>window</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>wsize</name></decl>;</decl_stmt>

    <comment type="block">/* check input */</comment>
    <if>if <condition>(<expr><name>dest</name> == <name>Z_NULL</name> || <name>source</name> == <name>Z_NULL</name> || <name><name>source</name>-&gt;<name>state</name></name> == <name>Z_NULL</name> ||
        <name><name>source</name>-&gt;<name>zalloc</name></name> == (<name>alloc_func</name>)0 || <name><name>source</name>-&gt;<name>zfree</name></name> == (<name>free_func</name>)0</expr>)</condition><then>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>state</name> = (struct <name>inflate_state</name> <name>FAR</name> *)<name><name>source</name>-&gt;<name>state</name></name></expr>;</expr_stmt>

    <comment type="block">/* allocate space */</comment>
    <expr_stmt><expr><name>copy</name> = (struct <name>inflate_state</name> <name>FAR</name> *)
           <call><name>ZALLOC</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>inflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>copy</name> == <name>Z_NULL</name></expr>)</condition><then> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>window</name> = <name>Z_NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>window</name></name> != <name>Z_NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>window</name> = (<name>unsigned</name> <name>char</name> <name>FAR</name> *)
                 <call><name>ZALLOC</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr>1U &lt;&lt; <name><name>state</name>-&gt;<name>wbits</name></name></expr></argument>, <argument><expr>sizeof(<name>unsigned</name> <name>char</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>window</name> == <name>Z_NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* copy state */</comment>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>inflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>lencode</name></name> &gt;= <name><name>state</name>-&gt;<name>codes</name></name> &amp;&amp;
        <name><name>state</name>-&gt;<name>lencode</name></name> &lt;= <name><name>state</name>-&gt;<name>codes</name></name> + <name>ENOUGH</name> - 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>copy</name>-&gt;<name>lencode</name></name> = <name><name>copy</name>-&gt;<name>codes</name></name> + (<name><name>state</name>-&gt;<name>lencode</name></name> - <name><name>state</name>-&gt;<name>codes</name></name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>copy</name>-&gt;<name>distcode</name></name> = <name><name>copy</name>-&gt;<name>codes</name></name> + (<name><name>state</name>-&gt;<name>distcode</name></name> - <name><name>state</name>-&gt;<name>codes</name></name>)</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>copy</name>-&gt;<name>next</name></name> = <name><name>copy</name>-&gt;<name>codes</name></name> + (<name><name>state</name>-&gt;<name>next</name></name> - <name><name>state</name>-&gt;<name>codes</name></name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>window</name> != <name>Z_NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wsize</name> = 1U &lt;&lt; <name><name>state</name>-&gt;<name>wbits</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>window</name></name></expr></argument>, <argument><expr><name>wsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>copy</name>-&gt;<name>window</name></name> = <name>window</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name>-&gt;<name>state</name></name> = (struct <name>internal_state</name> <name>FAR</name> *)<name>copy</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
}</block></function>
</unit>
