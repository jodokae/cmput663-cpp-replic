<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/cmathmodule.c"><comment type="block">/* Complex math module */</comment>

<comment type="block">/* much code borrowed from mathmodule.c */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<comment type="block">/* we need DBL_MAX, DBL_MIN, DBL_EPSILON, DBL_MANT_DIG and FLT_RADIX from
   float.h.  We assume that FLT_RADIX is either 2 or 16. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>FLT_RADIX</name> != 2 &amp;&amp; <name>FLT_RADIX</name> != 16)</expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "Modules/cmathmodule.c expects FLT_RADIX to be 2 or 16"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_LN2</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_LN2</name></cpp:macro> <cpp:value>(0.6931471805599453094)</cpp:value></cpp:define> <comment type="block">/* natural log of 2 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_LN10</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_LN10</name></cpp:macro> <cpp:value>(2.302585092994045684)</cpp:value></cpp:define> <comment type="block">/* natural log of 10 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
   CM_LARGE_DOUBLE is used to avoid spurious overflow in the sqrt, log,
   inverse trig and inverse hyperbolic trig functions.  Its log is used in the
   evaluation of exp, cos, cosh, sin, sinh, tan, and tanh to avoid unecessary
   overflow.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CM_LARGE_DOUBLE</name></cpp:macro> <cpp:value>(DBL_MAX/4.)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CM_SQRT_LARGE_DOUBLE</name></cpp:macro> <cpp:value>(sqrt(CM_LARGE_DOUBLE))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CM_LOG_LARGE_DOUBLE</name></cpp:macro> <cpp:value>(log(CM_LARGE_DOUBLE))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CM_SQRT_DBL_MIN</name></cpp:macro> <cpp:value>(sqrt(DBL_MIN))</cpp:value></cpp:define>

<comment type="block">/* 
   CM_SCALE_UP is an odd integer chosen such that multiplication by
   2**CM_SCALE_UP is sufficient to turn a subnormal into a normal.
   CM_SCALE_DOWN is (-(CM_SCALE_UP+1)/2).  These scalings are used to compute
   square roots accurately when the real and imaginary parts of the argument
   are subnormal.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FLT_RADIX</name>==2</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CM_SCALE_UP</name></cpp:macro> <cpp:value>(2*(DBL_MANT_DIG/2) + 1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>FLT_RADIX</name>==16</expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CM_SCALE_UP</name></cpp:macro> <cpp:value>(4*DBL_MANT_DIG+1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CM_SCALE_DOWN</name></cpp:macro> <cpp:value>(-(CM_SCALE_UP+1)/2)</cpp:value></cpp:define>

<comment type="block">/* forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name>c_asinh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name>c_atanh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name>c_cosh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name>c_sinh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name>c_sqrt</name><parameter_list>(<param><decl><type><name>Py_complex</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name>c_tanh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>math_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Code to deal with special values (infinities, NaNs, etc.). */</comment>

<comment type="block">/* special_type takes a double and returns an integer code indicating
   the type of the double as follows:
*/</comment>

<enum>enum <name>special_types</name> <block>{
	<decl><name>ST_NINF</name></decl>,	<comment type="block">/* 0, negative infinity */</comment>
	<decl><name>ST_NEG</name></decl>,		<comment type="block">/* 1, negative finite number (nonzero) */</comment>
	<decl><name>ST_NZERO</name></decl>,	<comment type="block">/* 2, -0. */</comment>
	<decl><name>ST_PZERO</name></decl>,	<comment type="block">/* 3, +0. */</comment>
	<decl><name>ST_POS</name></decl>,		<comment type="block">/* 4, positive finite number (nonzero) */</comment>
	<decl><name>ST_PINF</name></decl>,	<comment type="block">/* 5, positive infinity */</comment>
	<decl><name>ST_NAN</name></decl>,		<comment type="block">/* 6, Not a Number */</comment>
}</block>;</enum>

<enum><specifier>static</specifier> enum <name>special_types</name>
<name>special_type</name><expr_stmt><expr>(<name>double</name> <name>d</name>)
<block>{
	<if>if <condition>(<expr><call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>d</name> != 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call> == 1.</expr>)</condition><then>
				<return>return <expr><name>ST_POS</name></expr>;</return></then>
			<else>else
				<return>return <expr><name>ST_NEG</name></expr>;</return></else></if>
		<expr_stmt/></block></then></if></block></then></if>}</block></expr></expr_stmt></enum>
		<else>else <block>{
			<if>if <condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call> == 1.</expr>)</condition><then>
				<return>return <expr><name>ST_PZERO</name></expr>;</return></then>
			<else>else
				<return>return <expr><name>ST_NZERO</name></expr>;</return></else></if>
		}</block></else>
	}
	if <expr_stmt><expr>(<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call>)</expr></expr_stmt>
		<return>return <expr><name>ST_NAN</name></expr>;</return>
	<if>if <condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call> == 1.</expr>)</condition><then>
		<return>return <expr><name>ST_PINF</name></expr>;</return></then>
	<else>else
		<return>return <expr><name>ST_NINF</name></expr>;</return></else></if>
}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPECIAL_VALUE</name><parameter_list>(<param><type><name>z</name></type></param>, <param><type><name>table</name></type></param>)</parameter_list></cpp:macro>						\
	<cpp:value>if (!Py_IS_FINITE((z).real) || !Py_IS_FINITE((z).imag)) {	\
		errno = 0;                                              \
		return table[special_type((z).real)]	                \
			    [special_type((z).imag)];			\
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P</name></cpp:macro> <cpp:value>Py_MATH_PI</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P14</name></cpp:macro> <cpp:value>0.25*Py_MATH_PI</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P12</name></cpp:macro> <cpp:value>0.5*Py_MATH_PI</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P34</name></cpp:macro> <cpp:value>0.75*Py_MATH_PI</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INF</name></cpp:macro> <cpp:value>Py_HUGE_VAL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N</name></cpp:macro> <cpp:value>Py_NAN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U</name></cpp:macro> <cpp:value>-9.5426319407711027e33</cpp:value></cpp:define> <comment type="block">/* unlikely value, used as placeholder */</comment>

<comment type="block">/* First, the C functions that do the real work.  Each of the c_*
   functions computes and returns the C99 Annex G recommended result
   and also sets errno as follows: errno = 0 if no floating-point
   exception is associated with the result; errno = EDOM if C99 Annex
   G recommends raising divide-by-zero or invalid for this result; and
   errno = ERANGE where the overflow floating-point signal should be
   raised.
*/</comment>

static <decl_stmt><decl><type><name>Py_complex</name></type> <name><name>acos_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_acos</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPECIAL_VALUE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>acos_special_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LARGE_DOUBLE</name> || <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<comment type="block">/* avoid unnecessary overflow for large arguments */</comment>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>atan2</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* split into cases to make sure that the branch cut has the
		   correct continuity on systems with unsigned zeros */</comment>
		<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &lt; 0.</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<call><name>copysign</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><call><name>hypot</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name>/2.</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name>/2.</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
					   <name>M_LN2</name>*2.</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><call><name>hypot</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name>/2.</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name>/2.</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
					  <name>M_LN2</name>*2.</expr></argument>, <argument><expr>-<name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>s1</name>.<name>real</name></name> = 1.-<name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s1</name>.<name>imag</name></name> = -<name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s1</name> = <call><name>c_sqrt</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s2</name>.<name>real</name></name> = 1.+<name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s2</name>.<name>imag</name></name> = <name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s2</name> = <call><name>c_sqrt</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = 2.*<call><name>atan2</name><argument_list>(<argument><expr><name><name>s1</name>.<name>real</name></name></expr></argument>, <argument><expr><name><name>s2</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>asinh</name><argument_list>(<argument><expr><name><name>s2</name>.<name>real</name></name>*<name><name>s1</name>.<name>imag</name></name> - <name><name>s2</name>.<name>imag</name></name>*<name><name>s1</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_acos_doc</name></expr></argument>,
<argument><expr>"acos(x)\n"
"\n"
"Return the arc cosine of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>acosh_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_acosh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPECIAL_VALUE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>acosh_special_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LARGE_DOUBLE</name> || <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<comment type="block">/* avoid unnecessary overflow for large arguments */</comment>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>log</name><argument_list>(<argument><expr><call><name>hypot</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name>/2.</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name>/2.</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + <name>M_LN2</name>*2.</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>atan2</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>s1</name>.<name>real</name></name> = <name><name>z</name>.<name>real</name></name> - 1.</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s1</name>.<name>imag</name></name> = <name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s1</name> = <call><name>c_sqrt</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s2</name>.<name>real</name></name> = <name><name>z</name>.<name>real</name></name> + 1.</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s2</name>.<name>imag</name></name> = <name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s2</name> = <call><name>c_sqrt</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>asinh</name><argument_list>(<argument><expr><name><name>s1</name>.<name>real</name></name>*<name><name>s2</name>.<name>real</name></name> + <name><name>s1</name>.<name>imag</name></name>*<name><name>s2</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = 2.*<call><name>atan2</name><argument_list>(<argument><expr><name><name>s1</name>.<name>imag</name></name></expr></argument>, <argument><expr><name><name>s2</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_acosh_doc</name></expr></argument>,
<argument><expr>"acosh(x)\n"
"\n"
"Return the hyperbolic arccosine of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_asin</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* asin(z) = -i asinh(iz) */</comment>
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>s</name>.<name>real</name></name> = -<name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name>.<name>imag</name></name> = <name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> = <call><name>c_asinh</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>s</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<name><name>s</name>.<name>real</name></name></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_asin_doc</name></expr></argument>,
<argument><expr>"asin(x)\n"
"\n"
"Return the arc sine of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>asinh_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_asinh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPECIAL_VALUE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>asinh_special_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LARGE_DOUBLE</name> || <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>z</name>.<name>imag</name></name> &gt;= 0.</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><call><name>hypot</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name>/2.</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name>/2.</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
					  <name>M_LN2</name>*2.</expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = -<call><name>copysign</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><call><name>hypot</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name>/2.</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name>/2.</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
					   <name>M_LN2</name>*2.</expr></argument>, <argument><expr>-<name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>atan2</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>, <argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>s1</name>.<name>real</name></name> = 1.+<name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s1</name>.<name>imag</name></name> = -<name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s1</name> = <call><name>c_sqrt</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s2</name>.<name>real</name></name> = 1.-<name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s2</name>.<name>imag</name></name> = <name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s2</name> = <call><name>c_sqrt</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>asinh</name><argument_list>(<argument><expr><name><name>s1</name>.<name>real</name></name>*<name><name>s2</name>.<name>imag</name></name>-<name><name>s2</name>.<name>real</name></name>*<name><name>s1</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>atan2</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>, <argument><expr><name><name>s1</name>.<name>real</name></name>*<name><name>s2</name>.<name>real</name></name>-<name><name>s1</name>.<name>imag</name></name>*<name><name>s2</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_asinh_doc</name></expr></argument>,
<argument><expr>"asinh(x)\n"
"\n"
"Return the hyperbolic arc sine of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_atan</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* atan(z) = -i atanh(iz) */</comment>
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>s</name>.<name>real</name></name> = -<name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name>.<name>imag</name></name> = <name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> = <call><name>c_atanh</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>s</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<name><name>s</name>.<name>real</name></name></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<comment type="block">/* Windows screws up atan2 for inf and nan, and alpha Tru64 5.1 doesn't follow
   C99 for atan2(0., 0.). */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>c_atan2</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> || <call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>Py_NAN</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> == 1.</expr>)</condition><then>
				<comment type="block">/* atan2(+-inf, +inf) == +-pi/4 */</comment>
				<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr>0.25*<name>Py_MATH_PI</name></expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
			<else>else
				<comment type="block">/* atan2(+-inf, -inf) == +-pi*3/4 */</comment>
				<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr>0.75*<name>Py_MATH_PI</name></expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
		}</block></then></if>
		<comment type="block">/* atan2(+-inf, x) == +-pi/2 for finite x */</comment>
		<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr>0.5*<name>Py_MATH_PI</name></expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> || <name><name>z</name>.<name>imag</name></name> == 0.</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> == 1.</expr>)</condition><then>
			<comment type="block">/* atan2(+-y, +inf) = atan2(+-0, +x) = +-0. */</comment>
			<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
		<else>else
			<comment type="block">/* atan2(+-y, -inf) = atan2(+-0., -x) = +-pi. */</comment>
			<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr><name>Py_MATH_PI</name></expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then></if>
	<return>return <expr><call><name>atan2</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_atan_doc</name></expr></argument>,
<argument><expr>"atan(x)\n"
"\n"
"Return the arc tangent of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>atanh_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_atanh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>ay</name></decl>, <decl><type ref="prev"/><name>h</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPECIAL_VALUE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>atanh_special_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce to case where z.real &gt;= 0., using atanh(z) = -atanh(-z). */</comment>
	<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &lt; 0.</expr>)</condition><then> <block>{
		<return>return <expr><call><name>c_neg</name><argument_list>(<argument><expr><call><name>c_atanh</name><argument_list>(<argument><expr><call><name>c_neg</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>ay</name> = <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &gt; <name>CM_SQRT_LARGE_DOUBLE</name> || <name>ay</name> &gt; <name>CM_SQRT_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<comment type="block">/*
		   if abs(z) is large then we use the approximation
		   atanh(z) ~ 1/z +/- i*pi/2 (+/- depending on the sign
		   of z.imag)
		*/</comment>
		<expr_stmt><expr><name>h</name> = <call><name>hypot</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name>/2.</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name>/2.</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* safe from overflow */</comment>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>z</name>.<name>real</name></name>/4./<name>h</name>/<name>h</name></expr>;</expr_stmt>
		<comment type="block">/* the two negations in the next line cancel each other out
		   except when working with unsigned zeros: they're there to
		   ensure that the branch cut has the correct continuity on
		   systems that don't support signed zeros */</comment>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<call><name>copysign</name><argument_list>(<argument><expr><name>Py_MATH_PI</name>/2.</expr></argument>, <argument><expr>-<name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> == 1. &amp;&amp; <name>ay</name> &lt; <name>CM_SQRT_DBL_MIN</name></expr>)</condition><then> <block>{
		<comment type="block">/* C99 standard says:  atanh(1+/-0.) should be inf +/- 0i */</comment>
		<if>if <condition>(<expr><name>ay</name> == 0.</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name>INF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = -<call><name>log</name><argument_list>(<argument><expr><call><name>sqrt</name><argument_list>(<argument><expr><name>ay</name></expr></argument>)</argument_list></call>/<call><name>sqrt</name><argument_list>(<argument><expr><call><name>hypot</name><argument_list>(<argument><expr><name>ay</name></expr></argument>, <argument><expr>2.</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><call><name>atan2</name><argument_list>(<argument><expr>2.</expr></argument>, <argument><expr>-<name>ay</name></expr></argument>)</argument_list></call>/2</expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
		}</block></else></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>log1p</name><argument_list>(<argument><expr>4.*<name><name>z</name>.<name>real</name></name>/((1-<name><name>z</name>.<name>real</name></name>)*(1-<name><name>z</name>.<name>real</name></name>) + <name>ay</name>*<name>ay</name>)</expr></argument>)</argument_list></call>/4.</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<call><name>atan2</name><argument_list>(<argument><expr>-2.*<name><name>z</name>.<name>imag</name></name></expr></argument>, <argument><expr>(1-<name><name>z</name>.<name>real</name></name>)*(1+<name><name>z</name>.<name>real</name></name>) - <name>ay</name>*<name>ay</name></expr></argument>)</argument_list></call>/2.</expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	}</block></else></if></else></if>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_atanh_doc</name></expr></argument>,
<argument><expr>"atanh(x)\n"
"\n"
"Return the hyperbolic arc tangent of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_cos</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* cos(z) = cosh(iz) */</comment>
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = -<name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> = <call><name>c_cosh</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_cos_doc</name></expr></argument>,
<argument><expr>"cos(x)\n"
"n"
"Return the cosine of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* cosh(infinity + i*y) needs to be dealt with specially */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>cosh_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_cosh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>x_minus_one</name></decl>;</decl_stmt>

	<comment type="block">/* special treatment for cosh(+/-inf + iy) if y is not a NaN */</comment>
	<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> || !<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> &amp;&amp;
		    (<name><name>z</name>.<name>imag</name></name> != 0.)</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>r</name> = <name><name>cosh_special_values</name><index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>]</index>
				               <index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		}</block></else></if>
		<comment type="block">/* need to set errno = EDOM if y is +/- infinity and x is not
		   a NaN */</comment>
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
		<return>return <expr><name>r</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LOG_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<comment type="block">/* deal correctly with cases where cosh(z.real) overflows but
		   cosh(z) does not. */</comment>
		<expr_stmt><expr><name>x_minus_one</name> = <name><name>z</name>.<name>real</name></name> - <call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> * <call><name>cosh</name><argument_list>(<argument><expr><name>x_minus_one</name></expr></argument>)</argument_list></call> * <name>Py_MATH_E</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> * <call><name>sinh</name><argument_list>(<argument><expr><name>x_minus_one</name></expr></argument>)</argument_list></call> * <name>Py_MATH_E</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> * <call><name>cosh</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> * <call><name>sinh</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<comment type="block">/* detect overflow, and set errno accordingly */</comment>
	<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>r</name>.<name>real</name></name></expr></argument>)</argument_list></call> || <call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>r</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_cosh_doc</name></expr></argument>,
<argument><expr>"cosh(x)\n"
"n"
"Return the hyperbolic cosine of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* exp(infinity + i*y) and exp(-infinity + i*y) need special treatment for
   finite y */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>exp_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_exp</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>l</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> || !<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>
		    &amp;&amp; (<name><name>z</name>.<name>imag</name></name> != 0.)</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>r</name> = <name><name>exp_special_values</name><index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>]</index>
				              <index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		}</block></else></if>
		<comment type="block">/* need to set errno = EDOM if y is +/- infinity and x is not
		   a NaN and not -infinity */</comment>
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> &amp;&amp;
		    (<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> ||
		     (<call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>z</name>.<name>real</name></name> &gt; 0))</expr>)</condition><then>
			<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
		<return>return <expr><name>r</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &gt; <name>CM_LOG_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>l</name> = <call><name>exp</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name>-1.</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name>l</name>*<call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>*<name>Py_MATH_E</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name>l</name>*<call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>*<name>Py_MATH_E</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>l</name> = <call><name>exp</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name>l</name>*<call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name>l</name>*<call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<comment type="block">/* detect overflow, and set errno accordingly */</comment>
	<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>r</name>.<name>real</name></name></expr></argument>)</argument_list></call> || <call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>r</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_exp_doc</name></expr></argument>,
<argument><expr>"exp(x)\n"
"\n"
"Return the exponential value e**x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>log_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_log</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/*
	   The usual formula for the real part is log(hypot(z.real, z.imag)).
	   There are four situations where this formula is potentially
	   problematic:

	   (1) the absolute value of z is subnormal.  Then hypot is subnormal,
	   so has fewer than the usual number of bits of accuracy, hence may
	   have large relative error.  This then gives a large absolute error
	   in the log.  This can be solved by rescaling z by a suitable power
	   of 2.

	   (2) the absolute value of z is greater than DBL_MAX (e.g. when both
	   z.real and z.imag are within a factor of 1/sqrt(2) of DBL_MAX)
	   Again, rescaling solves this.

	   (3) the absolute value of z is close to 1.  In this case it's
	   difficult to achieve good accuracy, at least in part because a
	   change of 1ulp in the real or imaginary part of z can result in a
	   change of billions of ulps in the correctly rounded answer.

	   (4) z = 0.  The simplest thing to do here is to call the
	   floating-point log with an argument of 0, and let its behaviour
	   (returning -infinity, signaling a floating-point exception, setting
	   errno, or whatever) determine that of c_log.  So the usual formula
	   is fine here.

	 */</comment>

	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>ax</name></decl>, <decl><type ref="prev"/><name>ay</name></decl>, <decl><type ref="prev"/><name>am</name></decl>, <decl><type ref="prev"/><name>an</name></decl>, <decl><type ref="prev"/><name>h</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPECIAL_VALUE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>log_special_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ax</name> = <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ay</name> = <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>ax</name> &gt; <name>CM_LARGE_DOUBLE</name> || <name>ay</name> &gt; <name>CM_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>log</name><argument_list>(<argument><expr><call><name>hypot</name><argument_list>(<argument><expr><name>ax</name>/2.</expr></argument>, <argument><expr><name>ay</name>/2.</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + <name>M_LN2</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>ax</name> &lt; <name>DBL_MIN</name> &amp;&amp; <name>ay</name> &lt; <name>DBL_MIN</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>ax</name> &gt; 0. || <name>ay</name> &gt; 0.</expr>)</condition><then> <block>{
			<comment type="block">/* catch cases where hypot(ax, ay) is subnormal */</comment>
			<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>log</name><argument_list>(<argument><expr><call><name>hypot</name><argument_list>(<argument><expr><call><name>ldexp</name><argument_list>(<argument><expr><name>ax</name></expr></argument>, <argument><expr><name>DBL_MANT_DIG</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>ldexp</name><argument_list>(<argument><expr><name>ay</name></expr></argument>, <argument><expr><name>DBL_MANT_DIG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> - <name>DBL_MANT_DIG</name>*<name>M_LN2</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* log(+/-0. +/- 0i) */</comment>
			<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = -<name>INF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>atan2</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt>
			<return>return <expr><name>r</name></expr>;</return>
		}</block></else></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>h</name> = <call><name>hypot</name><argument_list>(<argument><expr><name>ax</name></expr></argument>, <argument><expr><name>ay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>0.71 &lt;= <name>h</name> &amp;&amp; <name>h</name> &lt;= 1.73</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>am</name> = <name>ax</name> &gt; <name>ay</name> ? <name>ax</name> : <name>ay</name></expr>;</expr_stmt>  <comment type="block">/* max(ax, ay) */</comment>
			<expr_stmt><expr><name>an</name> = <name>ax</name> &gt; <name>ay</name> ? <name>ay</name> : <name>ax</name></expr>;</expr_stmt>  <comment type="block">/* min(ax, ay) */</comment>
			<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>log1p</name><argument_list>(<argument><expr>(<name>am</name>-1)*(<name>am</name>+1)+<name>an</name>*<name>an</name></expr></argument>)</argument_list></call>/2.</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>log</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></else></if></else></if>
	<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>atan2</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_log10</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>errno_save</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r</name> = <call><name>c_log</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno_save</name> = <name>errno</name></expr>;</expr_stmt> <comment type="block">/* just in case the divisions affect errno */</comment>
	<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>r</name>.<name>real</name></name> / <name>M_LN10</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name><name>r</name>.<name>imag</name></name> / <name>M_LN10</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> = <name>errno_save</name></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_log10_doc</name></expr></argument>,
<argument><expr>"log10(x)\n"
"\n"
"Return the base-10 logarithm of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_sin</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* sin(z) = -i sin(iz) */</comment>
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>s</name>.<name>real</name></name> = -<name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name>.<name>imag</name></name> = <name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> = <call><name>c_sinh</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>s</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<name><name>s</name>.<name>real</name></name></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_sin_doc</name></expr></argument>,
<argument><expr>"sin(x)\n"
"\n"
"Return the sine of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* sinh(infinity + i*y) needs to be dealt with specially */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>sinh_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_sinh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>x_minus_one</name></decl>;</decl_stmt>

	<comment type="block">/* special treatment for sinh(+/-inf + iy) if y is finite and
	   nonzero */</comment>
	<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> || !<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>
		    &amp;&amp; (<name><name>z</name>.<name>imag</name></name> != 0.)</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = -<call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>r</name> = <name><name>sinh_special_values</name><index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>]</index>
				               <index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		}</block></else></if>
		<comment type="block">/* need to set errno = EDOM if y is +/- infinity and x is not
		   a NaN */</comment>
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
		<return>return <expr><name>r</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LOG_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x_minus_one</name> = <name><name>z</name>.<name>real</name></name> - <call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> * <call><name>sinh</name><argument_list>(<argument><expr><name>x_minus_one</name></expr></argument>)</argument_list></call> * <name>Py_MATH_E</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> * <call><name>cosh</name><argument_list>(<argument><expr><name>x_minus_one</name></expr></argument>)</argument_list></call> * <name>Py_MATH_E</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> * <call><name>sinh</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> * <call><name>cosh</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<comment type="block">/* detect overflow, and set errno accordingly */</comment>
	<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>r</name>.<name>real</name></name></expr></argument>)</argument_list></call> || <call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>r</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_sinh_doc</name></expr></argument>,
<argument><expr>"sinh(x)\n"
"\n"
"Return the hyperbolic sine of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>sqrt_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_sqrt</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/*
	   Method: use symmetries to reduce to the case when x = z.real and y
	   = z.imag are nonnegative.  Then the real part of the result is
	   given by

	     s = sqrt((x + hypot(x, y))/2)

	   and the imaginary part is

	     d = (y/2)/s

	   If either x or y is very large then there's a risk of overflow in
	   computation of the expression x + hypot(x, y).  We can avoid this
	   by rewriting the formula for s as:

	     s = 2*sqrt(x/8 + hypot(x/8, y/8))

	   This costs us two extra multiplications/divisions, but avoids the
	   overhead of checking for x and y large.

	   If both x and y are subnormal then hypot(x, y) may also be
	   subnormal, so will lack full precision.  We solve this by rescaling
	   x and y by a sufficiently large power of 2 to ensure that x and y
	   are normal.
	*/</comment>


	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>s</name></decl>,<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>ax</name></decl>, <decl><type ref="prev"/><name>ay</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPECIAL_VALUE</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>sqrt_special_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> == 0. &amp;&amp; <name><name>z</name>.<name>imag</name></name> == 0.</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = 0.</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
		<return>return <expr><name>r</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>ax</name> = <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ay</name> = <call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>ax</name> &lt; <name>DBL_MIN</name> &amp;&amp; <name>ay</name> &lt; <name>DBL_MIN</name> &amp;&amp; (<name>ax</name> &gt; 0. || <name>ay</name> &gt; 0.)</expr>)</condition><then> <block>{
		<comment type="block">/* here we catch cases where hypot(ax, ay) is subnormal */</comment>
		<expr_stmt><expr><name>ax</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>ax</name></expr></argument>, <argument><expr><name>CM_SCALE_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> = <call><name>ldexp</name><argument_list>(<argument><expr><call><name>sqrt</name><argument_list>(<argument><expr><name>ax</name> + <call><name>hypot</name><argument_list>(<argument><expr><name>ax</name></expr></argument>, <argument><expr><call><name>ldexp</name><argument_list>(<argument><expr><name>ay</name></expr></argument>, <argument><expr><name>CM_SCALE_UP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name>CM_SCALE_DOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>ax</name> /= 8.</expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> = 2.*<call><name>sqrt</name><argument_list>(<argument><expr><name>ax</name> + <call><name>hypot</name><argument_list>(<argument><expr><name>ax</name></expr></argument>, <argument><expr><name>ay</name>/8.</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>d</name> = <name>ay</name>/(2.*<name>s</name>)</expr>;</expr_stmt>

	<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &gt;= 0.</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name>s</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name>d</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_sqrt_doc</name></expr></argument>,
<argument><expr>"sqrt(x)\n"
"\n"
"Return the square root of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_tan</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* tan(z) = -i tanh(iz) */</comment>
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>s</name>.<name>real</name></name> = -<name><name>z</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name>.<name>imag</name></name> = <name><name>z</name>.<name>real</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> = <call><name>c_tanh</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <name><name>s</name>.<name>imag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = -<name><name>s</name>.<name>real</name></name></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_tan_doc</name></expr></argument>,
<argument><expr>"tan(x)\n"
"\n"
"Return the tangent of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* tanh(infinity + i*y) needs to be dealt with specially */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>tanh_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Py_complex</name></type>
<name>c_tanh</name><parameter_list>(<param><decl><type><name>Py_complex</name></type> <name>z</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* Formula:

	   tanh(x+iy) = (tanh(x)(1+tan(y)^2) + i tan(y)(1-tanh(x))^2) /
	   (1+tan(y)^2 tanh(x)^2)

	   To avoid excessive roundoff error, 1-tanh(x)^2 is better computed
	   as 1/cosh(x)^2.  When abs(x) is large, we approximate 1-tanh(x)^2
	   by 4 exp(-2*x) instead, to avoid possible overflow in the
	   computation of cosh(x).

	*/</comment>

	<decl_stmt><decl><type><name>Py_complex</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>tx</name></decl>, <decl><type ref="prev"/><name>ty</name></decl>, <decl><type ref="prev"/><name>cx</name></decl>, <decl><type ref="prev"/><name>txty</name></decl>, <decl><type ref="prev"/><name>denom</name></decl>;</decl_stmt>

	<comment type="block">/* special treatment for tanh(+/-inf + iy) if y is finite and
	   nonzero */</comment>
	<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> || !<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>
		    &amp;&amp; (<name><name>z</name>.<name>imag</name></name> != 0.)</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>z</name>.<name>real</name></name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = 1.0</expr>;</expr_stmt>
				<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>,
						  <argument><expr>2.*<call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>*<call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = -1.0</expr>;</expr_stmt>
				<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>,
						  <argument><expr>2.*<call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>*<call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>r</name> = <name><name>tanh_special_values</name><index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>]</index>
				               <index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		}</block></else></if>
		<comment type="block">/* need to set errno = EDOM if z.imag is +/-infinity and
		   z.real is finite */</comment>
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
		<return>return <expr><name>r</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* danger of overflow in 2.*z.imag !*/</comment>
	<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> &gt; <name>CM_LOG_LARGE_DOUBLE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = 4.*<call><name>sin</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>*<call><name>cos</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call>*<call><name>exp</name><argument_list>(<argument><expr>-2.*<call><name>fabs</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>tx</name> = <call><name>tanh</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ty</name> = <call><name>tan</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cx</name> = 1./<call><name>cosh</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>txty</name> = <name>tx</name>*<name>ty</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>denom</name> = 1. + <name>txty</name>*<name>txty</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>real</name></name> = <call><name>tx</name>*<argument_list>(<argument><expr>1.+<name>ty</name>*<name>ty</name></expr></argument>)</argument_list></call>/<name>denom</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name>.<name>imag</name></name> = ((<name>ty</name>/<name>denom</name>)*<name>cx</name>)*<name>cx</name></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>c_tanh_doc</name></expr></argument>,
<argument><expr>"tanh(x)\n"
"\n"
"Return the hyperbolic tangent of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmath_log</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>y</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"D|D"</expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex function"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>x</name> = <call><name>c_log</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 2</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>y</name> = <call><name>c_log</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> = <call><name>c_quot</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>x</argument>)</argument_list></macro>
	<if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then>
		<return>return <expr><call><name>math_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cmath_log_doc</name></expr></argument>,
<argument><expr>"log(x[, base]) -&gt; the logarithm of x to the given base.\n\
If the base not specified, returns the natural logarithm (base e) of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* And now the glue to make them available from Python: */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>errno</name> == <name>EDOM</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"math domain error"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <if>if <condition>(<expr><name>errno</name> == <name>ERANGE</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"math range error"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else    <comment type="block">/* Unexpected math error */</comment>
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_1</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><function_decl><type><name>Py_complex</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>Py_complex</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>x</name></decl>,<decl><type ref="prev"/><name>r</name></decl> ;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"D"</expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"complex function"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<expr_stmt><expr><name>r</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>errno</name> == <name>EDOM</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"math domain error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else <if>if <condition>(<expr><name>errno</name> == <name>ERANGE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"math range error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then>
	<else>else <block>{
		<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if></else></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC1</name><parameter_list>(<param><type><name>stubname</name></type></param>, <param><type><name>func</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>static PyObject * stubname(PyObject *self, PyObject *args) { \
		return math_1(args, func); \
	}</cpp:value></cpp:define>

<macro><name>FUNC1</name><argument_list>(<argument>cmath_acos</argument>, <argument>c_acos</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_acosh</argument>, <argument>c_acosh</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_asin</argument>, <argument>c_asin</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_asinh</argument>, <argument>c_asinh</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_atan</argument>, <argument>c_atan</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_atanh</argument>, <argument>c_atanh</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_cos</argument>, <argument>c_cos</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_cosh</argument>, <argument>c_cosh</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_exp</argument>, <argument>c_exp</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_log10</argument>, <argument>c_log10</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_sin</argument>, <argument>c_sin</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_sinh</argument>, <argument>c_sinh</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_sqrt</argument>, <argument>c_sqrt</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_tan</argument>, <argument>c_tan</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cmath_tanh</argument>, <argument>c_tanh</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmath_phase</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>phi</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"D:phase"</expr></argument>, <argument><expr>&amp;<name>z</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"arg function"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>phi</name> = <call><name>c_atan2</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>phi</argument>)</argument_list></macro>
	<if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then>
		<return>return <expr><call><name>math_error</name><argument_list>()</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cmath_phase_doc</name></expr></argument>,
<argument><expr>"phase(z) -&gt; float\n\n\
Return argument, also known as the phase angle, of a complex."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmath_polar</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>phi</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"D:polar"</expr></argument>, <argument><expr>&amp;<name>z</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"polar function"</argument>, <argument>return 0</argument>)</argument_list></macro>
	<expr_stmt><expr><name>phi</name> = <call><name>c_atan2</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* should not cause any exception */</comment>
	<expr_stmt><expr><name>r</name> = <call><name>c_abs</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* sets errno to ERANGE on overflow;  otherwise 0 */</comment>
	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>r</argument>)</argument_list></macro>
	<if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then>
		<return>return <expr><call><name>math_error</name><argument_list>()</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"dd"</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cmath_polar_doc</name></expr></argument>,
<argument><expr>"polar(z) -&gt; r: float, phi: float\n\n\
Convert a complex from rectangular coordinates to polar coordinates. r is\n\
the distance from 0 and phi the phase angle."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
  rect() isn't covered by the C99 standard, but it's not too hard to
  figure out 'spirit of C99' rules for special value handing:

    rect(x, t) should behave like exp(log(x) + it) for positive-signed x
    rect(x, t) should behave like -exp(log(-x) + it) for negative-signed x
    rect(nan, t) should behave like exp(nan + it), except that rect(nan, 0)
      gives nan +- i0 with the sign of the imaginary part unspecified.

*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>Py_complex</name></type> <name><name>rect_special_values</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmath_rect</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>phi</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"dd:rect"</expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>&amp;<name>phi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"rect function"</argument>, <argument>return 0</argument>)</argument_list></macro>

	<comment type="block">/* deal with special values */</comment>
	<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> || !<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<comment type="block">/* if r is +/-infinity and phi is finite but nonzero then
		   result is (+-INF +-INF i), but we need to compute cos(phi)
		   and sin(phi) to figure out the signs. */</comment>
		<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp;&amp; (<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call>
					  &amp;&amp; (<name>phi</name> != 0.))</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>r</name> &gt; 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>z</name>.<name>real</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>z</name>.<name>imag</name></name> = <call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name><name>z</name>.<name>real</name></name> = -<call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>cos</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>z</name>.<name>imag</name></name> = -<call><name>copysign</name><argument_list>(<argument><expr><name>INF</name></expr></argument>, <argument><expr><call><name>sin</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>z</name> = <name><name>rect_special_values</name><index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>]</index>
				               <index>[<expr><call><name>special_type</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		}</block></else></if>
		<comment type="block">/* need to set errno = EDOM if r is a nonzero number and phi
		   is infinite */</comment>
		<if>if <condition>(<expr><name>r</name> != 0. &amp;&amp; !<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name><name>z</name>.<name>real</name></name> = <name>r</name> * <call><name>cos</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name>.<name>imag</name></name> = <name>r</name> * <call><name>sin</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
	}</block></else></if>

	<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>z</argument>)</argument_list></macro>
	<if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then>
		<return>return <expr><call><name>math_error</name><argument_list>()</argument_list></call></expr>;</return></then>
	<else>else
		<return>return <expr><call><name>PyComplex_FromCComplex</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cmath_rect_doc</name></expr></argument>,
<argument><expr>"rect(r, phi) -&gt; z: complex\n\n\
Convert from polar coordinates to rectangular coordinates."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmath_isnan</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>z</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"D:isnan"</expr></argument>, <argument><expr>&amp;<name>z</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> || <call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cmath_isnan_doc</name></expr></argument>,
<argument><expr>"isnan(z) -&gt; bool\n\
Checks if the real or imaginary part of z not a number (NaN)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cmath_isinf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_complex</name></type> <name>z</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"D:isnan"</expr></argument>, <argument><expr>&amp;<name>z</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>real</name></name></expr></argument>)</argument_list></call> ||
			       <call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name><name>z</name>.<name>imag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cmath_isinf_doc</name></expr></argument>,
<argument><expr>"isinf(z) -&gt; bool\n\
Checks if the real or imaginary part of z is infinite."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"This module is always available. It provides access to mathematical\n"
"functions for complex numbers."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>cmath_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"acos"</expr>,   <expr><name>cmath_acos</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>c_acos_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"acosh"</expr>,  <expr><name>cmath_acosh</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>c_acosh_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"asin"</expr>,   <expr><name>cmath_asin</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>c_asin_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"asinh"</expr>,  <expr><name>cmath_asinh</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>c_asinh_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"atan"</expr>,   <expr><name>cmath_atan</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>c_atan_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"atanh"</expr>,  <expr><name>cmath_atanh</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>c_atanh_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"cos"</expr>,    <expr><name>cmath_cos</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>c_cos_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"cosh"</expr>,   <expr><name>cmath_cosh</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>c_cosh_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"exp"</expr>,    <expr><name>cmath_exp</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>c_exp_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"isinf"</expr>,  <expr><name>cmath_isinf</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>cmath_isinf_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"isnan"</expr>,  <expr><name>cmath_isnan</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>cmath_isnan_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"log"</expr>,    <expr><name>cmath_log</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>cmath_log_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"log10"</expr>,  <expr><name>cmath_log10</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>c_log10_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"phase"</expr>,  <expr><name>cmath_phase</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>cmath_phase_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"polar"</expr>,  <expr><name>cmath_polar</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>cmath_polar_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"rect"</expr>,   <expr><name>cmath_rect</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>cmath_rect_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"sin"</expr>,    <expr><name>cmath_sin</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>c_sin_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"sinh"</expr>,   <expr><name>cmath_sinh</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>c_sinh_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"sqrt"</expr>,   <expr><name>cmath_sqrt</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>c_sqrt_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"tan"</expr>,    <expr><name>cmath_tan</name></expr>,   <expr><name>METH_VARARGS</name></expr>, <expr><name>c_tan_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"tanh"</expr>,   <expr><name>cmath_tanh</name></expr>,  <expr><name>METH_VARARGS</name></expr>, <expr><name>c_tanh_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,		<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initcmath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"cmath"</expr></argument>, <argument><expr><name>cmath_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"pi"</expr></argument>,
                           <argument><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>Py_MATH_PI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"e"</expr></argument>, <argument><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>Py_MATH_E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize special value tables */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_SPECIAL_VALUES</name><parameter_list>(<param><type><name>NAME</name></type></param>, <param><type><name>BODY</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ Py_complex* p = (Py_complex*)NAME; BODY }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C</name><parameter_list>(<param><type><name>REAL</name></type></param>, <param><type><name>IMAG</name></type></param>)</parameter_list></cpp:macro> <cpp:value>p-&gt;real = REAL; p-&gt;imag = IMAG; ++p;</cpp:value></cpp:define>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>acos_special_values</argument>, <argument>{
	  C(P34,INF) C(P,INF)  C(P,INF)  C(P,-INF)  C(P,-INF)  C(P34,-INF) C(N,INF)
	  C(P12,INF) C(U,U)    C(U,U)    C(U,U)     C(U,U)     C(P12,-INF) C(N,N)
	  C(P12,INF) C(U,U)    C(P12,0.) C(P12,-0.) C(U,U)     C(P12,-INF) C(P12,N)
	  C(P12,INF) C(U,U)    C(P12,0.) C(P12,-0.) C(U,U)     C(P12,-INF) C(P12,N)
	  C(P12,INF) C(U,U)    C(U,U)    C(U,U)     C(U,U)     C(P12,-INF) C(N,N)
	  C(P14,INF) C(0.,INF) C(0.,INF) C(0.,-INF) C(0.,-INF) C(P14,-INF) C(N,INF)
	  C(N,INF)   C(N,N)    C(N,N)    C(N,N)     C(N,N)     C(N,-INF)   C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>acosh_special_values</argument>, <argument>{
	  C(INF,-P34) C(INF,-P)  C(INF,-P)  C(INF,P)  C(INF,P)  C(INF,P34) C(INF,N)
	  C(INF,-P12) C(U,U)     C(U,U)     C(U,U)    C(U,U)    C(INF,P12) C(N,N)
	  C(INF,-P12) C(U,U)     C(0.,-P12) C(0.,P12) C(U,U)    C(INF,P12) C(N,N)
	  C(INF,-P12) C(U,U)     C(0.,-P12) C(0.,P12) C(U,U)    C(INF,P12) C(N,N)
	  C(INF,-P12) C(U,U)     C(U,U)     C(U,U)    C(U,U)    C(INF,P12) C(N,N)
	  C(INF,-P14) C(INF,-0.) C(INF,-0.) C(INF,0.) C(INF,0.) C(INF,P14) C(INF,N)
	  C(INF,N)    C(N,N)     C(N,N)     C(N,N)    C(N,N)    C(INF,N)   C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>asinh_special_values</argument>, <argument>{
	  C(-INF,-P14) C(-INF,-0.) C(-INF,-0.) C(-INF,0.) C(-INF,0.) C(-INF,P14) C(-INF,N)
	  C(-INF,-P12) C(U,U)      C(U,U)      C(U,U)     C(U,U)     C(-INF,P12) C(N,N)
	  C(-INF,-P12) C(U,U)      C(-0.,-0.)  C(-0.,0.)  C(U,U)     C(-INF,P12) C(N,N)
	  C(INF,-P12)  C(U,U)      C(0.,-0.)   C(0.,0.)   C(U,U)     C(INF,P12)  C(N,N)
	  C(INF,-P12)  C(U,U)      C(U,U)      C(U,U)     C(U,U)     C(INF,P12)  C(N,N)
	  C(INF,-P14)  C(INF,-0.)  C(INF,-0.)  C(INF,0.)  C(INF,0.)  C(INF,P14)  C(INF,N)
	  C(INF,N)     C(N,N)      C(N,-0.)    C(N,0.)    C(N,N)     C(INF,N)    C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>atanh_special_values</argument>, <argument>{
	  C(-0.,-P12) C(-0.,-P12) C(-0.,-P12) C(-0.,P12) C(-0.,P12) C(-0.,P12) C(-0.,N)
	  C(-0.,-P12) C(U,U)      C(U,U)      C(U,U)     C(U,U)     C(-0.,P12) C(N,N)
	  C(-0.,-P12) C(U,U)      C(-0.,-0.)  C(-0.,0.)  C(U,U)     C(-0.,P12) C(-0.,N)
	  C(0.,-P12)  C(U,U)      C(0.,-0.)   C(0.,0.)   C(U,U)     C(0.,P12)  C(0.,N)
	  C(0.,-P12)  C(U,U)      C(U,U)      C(U,U)     C(U,U)     C(0.,P12)  C(N,N)
	  C(0.,-P12)  C(0.,-P12)  C(0.,-P12)  C(0.,P12)  C(0.,P12)  C(0.,P12)  C(0.,N)
	  C(0.,-P12)  C(N,N)      C(N,N)      C(N,N)     C(N,N)     C(0.,P12)  C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>cosh_special_values</argument>, <argument>{
	  C(INF,N) C(U,U) C(INF,0.)  C(INF,-0.) C(U,U) C(INF,N) C(INF,N)
	  C(N,N)   C(U,U) C(U,U)     C(U,U)     C(U,U) C(N,N)   C(N,N)
	  C(N,0.)  C(U,U) C(1.,0.)   C(1.,-0.)  C(U,U) C(N,0.)  C(N,0.)
	  C(N,0.)  C(U,U) C(1.,-0.)  C(1.,0.)   C(U,U) C(N,0.)  C(N,0.)
	  C(N,N)   C(U,U) C(U,U)     C(U,U)     C(U,U) C(N,N)   C(N,N)
	  C(INF,N) C(U,U) C(INF,-0.) C(INF,0.)  C(U,U) C(INF,N) C(INF,N)
	  C(N,N)   C(N,N) C(N,0.)    C(N,0.)    C(N,N) C(N,N)   C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>exp_special_values</argument>, <argument>{
	  C(0.,0.) C(U,U) C(0.,-0.)  C(0.,0.)  C(U,U) C(0.,0.) C(0.,0.)
	  C(N,N)   C(U,U) C(U,U)     C(U,U)    C(U,U) C(N,N)   C(N,N)
	  C(N,N)   C(U,U) C(1.,-0.)  C(1.,0.)  C(U,U) C(N,N)   C(N,N)
	  C(N,N)   C(U,U) C(1.,-0.)  C(1.,0.)  C(U,U) C(N,N)   C(N,N)
	  C(N,N)   C(U,U) C(U,U)     C(U,U)    C(U,U) C(N,N)   C(N,N)
	  C(INF,N) C(U,U) C(INF,-0.) C(INF,0.) C(U,U) C(INF,N) C(INF,N)
	  C(N,N)   C(N,N) C(N,-0.)   C(N,0.)   C(N,N) C(N,N)   C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>log_special_values</argument>, <argument>{
	  C(INF,-P34) C(INF,-P)  C(INF,-P)   C(INF,P)   C(INF,P)  C(INF,P34)  C(INF,N)
	  C(INF,-P12) C(U,U)     C(U,U)      C(U,U)     C(U,U)    C(INF,P12)  C(N,N)
	  C(INF,-P12) C(U,U)     C(-INF,-P)  C(-INF,P)  C(U,U)    C(INF,P12)  C(N,N)
	  C(INF,-P12) C(U,U)     C(-INF,-0.) C(-INF,0.) C(U,U)    C(INF,P12)  C(N,N)
	  C(INF,-P12) C(U,U)     C(U,U)      C(U,U)     C(U,U)    C(INF,P12)  C(N,N)
	  C(INF,-P14) C(INF,-0.) C(INF,-0.)  C(INF,0.)  C(INF,0.) C(INF,P14)  C(INF,N)
	  C(INF,N)    C(N,N)     C(N,N)      C(N,N)     C(N,N)    C(INF,N)    C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>sinh_special_values</argument>, <argument>{
	  C(INF,N) C(U,U) C(-INF,-0.) C(-INF,0.) C(U,U) C(INF,N) C(INF,N)
	  C(N,N)   C(U,U) C(U,U)      C(U,U)     C(U,U) C(N,N)   C(N,N)
	  C(0.,N)  C(U,U) C(-0.,-0.)  C(-0.,0.)  C(U,U) C(0.,N)  C(0.,N)
	  C(0.,N)  C(U,U) C(0.,-0.)   C(0.,0.)   C(U,U) C(0.,N)  C(0.,N)
	  C(N,N)   C(U,U) C(U,U)      C(U,U)     C(U,U) C(N,N)   C(N,N)
	  C(INF,N) C(U,U) C(INF,-0.)  C(INF,0.)  C(U,U) C(INF,N) C(INF,N)
	  C(N,N)   C(N,N) C(N,-0.)    C(N,0.)    C(N,N) C(N,N)   C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>sqrt_special_values</argument>, <argument>{
	  C(INF,-INF) C(0.,-INF) C(0.,-INF) C(0.,INF) C(0.,INF) C(INF,INF) C(N,INF)
	  C(INF,-INF) C(U,U)     C(U,U)     C(U,U)    C(U,U)    C(INF,INF) C(N,N)
	  C(INF,-INF) C(U,U)     C(0.,-0.)  C(0.,0.)  C(U,U)    C(INF,INF) C(N,N)
	  C(INF,-INF) C(U,U)     C(0.,-0.)  C(0.,0.)  C(U,U)    C(INF,INF) C(N,N)
	  C(INF,-INF) C(U,U)     C(U,U)     C(U,U)    C(U,U)    C(INF,INF) C(N,N)
	  C(INF,-INF) C(INF,-0.) C(INF,-0.) C(INF,0.) C(INF,0.) C(INF,INF) C(INF,N)
	  C(INF,-INF) C(N,N)     C(N,N)     C(N,N)    C(N,N)    C(INF,INF) C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>tanh_special_values</argument>, <argument>{
	  C(-1.,0.) C(U,U) C(-1.,-0.) C(-1.,0.) C(U,U) C(-1.,0.) C(-1.,0.)
	  C(N,N)    C(U,U) C(U,U)     C(U,U)    C(U,U) C(N,N)    C(N,N)
	  C(N,N)    C(U,U) C(-0.,-0.) C(-0.,0.) C(U,U) C(N,N)    C(N,N)
	  C(N,N)    C(U,U) C(0.,-0.)  C(0.,0.)  C(U,U) C(N,N)    C(N,N)
	  C(N,N)    C(U,U) C(U,U)     C(U,U)    C(U,U) C(N,N)    C(N,N)
	  C(1.,0.)  C(U,U) C(1.,-0.)  C(1.,0.)  C(U,U) C(1.,0.)  C(1.,0.)
	  C(N,N)    C(N,N) C(N,-0.)   C(N,0.)   C(N,N) C(N,N)    C(N,N)
	}</argument>)</argument_list></macro>

	<macro><name>INIT_SPECIAL_VALUES</name><argument_list>(<argument>rect_special_values</argument>, <argument>{
	  C(INF,N) C(U,U) C(-INF,0.) C(-INF,-0.) C(U,U) C(INF,N) C(INF,N)
	  C(N,N)   C(U,U) C(U,U)     C(U,U)      C(U,U) C(N,N)   C(N,N)
	  C(0.,0.) C(U,U) C(-0.,0.)  C(-0.,-0.)  C(U,U) C(0.,0.) C(0.,0.)
	  C(0.,0.) C(U,U) C(0.,-0.)  C(0.,0.)    C(U,U) C(0.,0.) C(0.,0.)
	  C(N,N)   C(U,U) C(U,U)     C(U,U)      C(U,U) C(N,N)   C(N,N)
	  C(INF,N) C(U,U) C(INF,-0.) C(INF,0.)   C(U,U) C(INF,N) C(INF,N)
	  C(N,N)   C(N,N) C(N,0.)    C(N,0.)     C(N,N) C(N,N)   C(N,N)
	}</argument>)</argument_list></macro>
}</block></function>
</unit>
