<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/socketmodule.c"><comment type="block">/* Socket module */</comment>

<comment type="block">/*

This module provides an interface to Berkeley socket IPC.

Limitations:

- Only AF_INET, AF_INET6 and AF_UNIX address families are supported in a
  portable manner, though AF_PACKET, AF_NETLINK and AF_TIPC are supported
  under Linux.
- No read/write operations (use sendall/recv or makefile instead).
- Additional restrictions apply on some non-Unix platforms (compensated
  for by socket.py).

Module interface:

- socket.error: exception raised for socket specific errors
- socket.gaierror: exception raised for getaddrinfo/getnameinfo errors,
	a subclass of socket.error
- socket.herror: exception raised for gethostby* errors,
	a subclass of socket.error
- socket.fromfd(fd, family, type[, proto]) --&gt; new socket object (created
        from an existing file descriptor)
- socket.gethostbyname(hostname) --&gt; host IP address (string: 'dd.dd.dd.dd')
- socket.gethostbyaddr(IP address) --&gt; (hostname, [alias, ...], [IP addr, ...])
- socket.gethostname() --&gt; host name (string: 'spam' or 'spam.domain.com')
- socket.getprotobyname(protocolname) --&gt; protocol number
- socket.getservbyname(servicename[, protocolname]) --&gt; port number
- socket.getservbyport(portnumber[, protocolname]) --&gt; service name
- socket.socket([family[, type [, proto]]]) --&gt; new socket object
- socket.socketpair([family[, type [, proto]]]) --&gt; (socket, socket)
- socket.ntohs(16 bit value) --&gt; new int object
- socket.ntohl(32 bit value) --&gt; new int object
- socket.htons(16 bit value) --&gt; new int object
- socket.htonl(32 bit value) --&gt; new int object
- socket.getaddrinfo(host, port [, family, socktype, proto, flags])
	--&gt; List of (family, socktype, proto, canonname, sockaddr)
- socket.getnameinfo(sockaddr, flags) --&gt; (host, port)
- socket.AF_INET, socket.SOCK_STREAM, etc.: constants from &lt;socket.h&gt;
- socket.has_ipv6: boolean value indicating if IPv6 is supported
- socket.inet_aton(IP address) -&gt; 32-bit packed IP representation
- socket.inet_ntoa(packed IP) -&gt; IP address string
- socket.getdefaulttimeout() -&gt; None | float
- socket.setdefaulttimeout(None | float)
- an Internet socket address is a pair (hostname, port)
  where hostname can be anything recognized by gethostbyname()
  (including the dd.dd.dd.dd notation) and port is in host byte order
- where a hostname is returned, the dd.dd.dd.dd notation is used
- a UNIX domain socket address is a string specifying the pathname
- an AF_PACKET socket address is a tuple containing a string
  specifying the ethernet interface and an integer specifying
  the Ethernet protocol number to be received. For example:
  ("eth0",0x1234).  Optional 3rd,4th,5th elements in the tuple
  specify packet-type and ha-type/addr.
- an AF_TIPC socket address is expressed as
 (addr_type, v1, v2, v3 [, scope]); where addr_type can be one of:
	TIPC_ADDR_NAMESEQ, TIPC_ADDR_NAME, and TIPC_ADDR_ID;
  and scope can be one of:
	TIPC_ZONE_SCOPE, TIPC_CLUSTER_SCOPE, and TIPC_NODE_SCOPE.
  The meaning of v1, v2 and v3 depends on the value of addr_type:
	if addr_type is TIPC_ADDR_NAME:
		v1 is the server type
		v2 is the port identifier
		v3 is ignored
	if addr_type is TIPC_ADDR_NAMESEQ:
		v1 is the server type
		v2 is the lower port number
		v3 is the upper port number
	if addr_type is TIPC_ADDR_ID:
		v1 is the node
		v2 is the ref
		v3 is ignored


Local naming conventions:

- names starting with sock_ are socket object methods
- names starting with socket_ are module-level functions
- names starting with PySocket are exported through socketmodule.h

*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
  <comment type="block">/*
   * inet_aton is not available on OSX 10.3, yet we want to use a binary
   * that was build on 10.4 or later to work on that release, weak linking
   * comes to the rescue.
   */</comment>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> weak inet_aton</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; (y) ? (y) : (x))</cpp:value></cpp:define>

<comment type="block">/* Socket object documentation */</comment>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sock_doc</name></expr></argument>,
<argument><expr>"socket([family[, type[, proto]]]) -&gt; socket object\n\
\n\
Open a socket of the given type.  The family argument specifies the\n\
address family; it defaults to AF_INET.  The type argument specifies\n\
whether this is a stream (SOCK_STREAM, this is the default)\n\
or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,\n\
specifying the default protocol.  Keyword arguments are accepted.\n\
\n\
A socket object represents one endpoint of a network connection.\n\
\n\
Methods of socket objects (keyword arguments not allowed):\n\
\n\
accept() -- accept a connection, returning new socket and client address\n\
bind(addr) -- bind the socket to a local address\n\
close() -- close the socket\n\
connect(addr) -- connect the socket to a remote address\n\
connect_ex(addr) -- connect, return an error code instead of an exception\n\
dup() -- return a new socket object identical to the current one [*]\n\
fileno() -- return underlying file descriptor\n\
getpeername() -- return remote address [*]\n\
getsockname() -- return local address\n\
getsockopt(level, optname[, buflen]) -- get socket options\n\
gettimeout() -- return timeout or None\n\
listen(n) -- start listening for incoming connections\n\
makefile([mode, [bufsize]]) -- return a file object for the socket [*]\n\
recv(buflen[, flags]) -- receive data\n\
recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)\n\
recvfrom(buflen[, flags]) -- receive data and sender\'s address\n\
recvfrom_into(buffer[, nbytes, [, flags])\n\
  -- receive data and sender\'s address (into a buffer)\n\
sendall(data[, flags]) -- send all data\n\
send(data[, flags]) -- send data, may not send all of it\n\
sendto(data[, flags], addr) -- send data to a given address\n\
setblocking(0 | 1) -- set or clear the blocking I/O flag\n\
setsockopt(level, optname, value) -- set socket options\n\
settimeout(None | float) -- set or clear the timeout\n\
shutdown(how) -- shut down traffic in one or both directions\n\
\n\
 [*] not available on all platforms!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* XXX This is a terrible mess of platform-dependent preprocessor hacks.
   I hope some day someone can clean this up please... */</comment>

<comment type="block">/* Hacks for gethostbyname_r().  On some non-Linux platforms, the configure
   script doesn't get this right, so we hardcode some platform checks below.
   On the other hand, not all Linux versions agree, so there the settings
   computed by the configure script are needed! */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>linux</name></cpp:ifndef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R_3_ARG</name></cpp:undef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R_5_ARG</name></cpp:undef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R_6_ARG</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITH_THREAD</name></cpp:ifndef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:ifdef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__osf__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETHOSTBYNAME_R_3_ARG</name></cpp:macro></cpp:define>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETHOSTBYNAME_R_5_ARG</name></cpp:macro></cpp:define>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* Rely on the configure script */</comment>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:undef>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call> &amp;&amp; \
    !<call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>USE_GETHOSTBYNAME_LOCK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* To use __FreeBSD_version */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_PARAM_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* On systems on which getaddrinfo() is believed to not be thread-safe,
   (this includes the getaddrinfo emulation) protect access with a lock. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call> &amp;&amp; (<call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> || \
    (<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>__FreeBSD_version</name>+0 &lt; 503000) || \
    <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call> || \
    <call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETADDRINFO</name></expr></argument>)</argument_list></call>)</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_GETADDRINFO_LOCK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_GETADDRINFO_LOCK</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_GETADDRINFO_LOCK</name></cpp:macro> <cpp:value>PyThread_acquire_lock(netdb_lock, 1);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_GETADDRINFO_LOCK</name></cpp:macro> <cpp:value>PyThread_release_lock(netdb_lock);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACQUIRE_GETADDRINFO_LOCK</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELEASE_GETADDRINFO_LOCK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_GETADDRINFO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;types.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;utils.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;ioctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive>  <cpp:macro><name>INCL_DOS</name></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive>  <cpp:macro><name>INCL_DOSERRORS</name></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive>  <cpp:macro><name>INCL_NOPMAPI</name></cpp:macro></cpp:define>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_COMPILER_VERSION</name>&gt;700 &amp;&amp; !<name>_SGIAPI</name></expr></cpp:if>
<comment type="block">/* make sure that the reentrant (gethostbyaddr_r etc)
   functions are declared correctly if compiling with
   MIPSPro 7.x in ANSI C mode (default) */</comment>

<comment type="block">/* XXX Using _SGIAPI is the wrong thing,
   but I don't know what the right thing is. */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_SGIAPI</name></cpp:undef> <comment type="block">/* to avoid warning */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SGIAPI</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_XOPEN_SOURCE</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SS_ALIGNSIZE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETADDRINFO</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETNAMEINFO</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_INET_PTON</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Irix 6.5 fails to define this variable at all. This is needed
   for both GCC and SGI's compiler. I'd say that the SGI headers
   are just busted. Same thing for Solaris. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>sun</name></expr></argument>)</argument_list></call>) &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>INET_ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INET_ADDRSTRLEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Generic includes */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_TYPES_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Generic socket object definitions and includes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySocket_BUILDING_SOCKET</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"socketmodule.h"</cpp:file></cpp:include>

<comment type="block">/* Addressing includes */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>

<comment type="block">/* Non-MS WINDOWS includes */</comment>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Headers needed for inet_ntoa() and inet_addr() */</comment>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>__BEOS__</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;net/netdb.h&gt;</cpp:file></cpp:include>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<typedef>typedef <type><name>size_t</name></type> <name>socklen_t</name>;</typedef>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>RISCOS</name></cpp:ifndef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;socklib.h&gt;</cpp:file></cpp:include>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DUP</name></cpp:macro></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>h_errno</name></decl>;</decl_stmt> <comment type="block">/* not used */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>INET_ADDRSTRLEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* MS_WINDOWS includes */</comment>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>HAVE_FCNTL_H</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>offsetof</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>offsetof</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>member</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((size_t)(&amp;((type *)0)-&gt;member))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_NONBLOCK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>O_NONBLOCK</name></cpp:macro> <cpp:value>O_NDELAY</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* include Python's addrinfo.h unless it causes trouble */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_COMPILER_VERSION</name>&gt;700 &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>_SS_ALIGNSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Do not include addinfo.h on some newer IRIX versions.
   * _SS_ALIGNSIZE is defined in sys/socket.h by 6.5.21,
   * for example, but not by 6.5.10.
   */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_MSC_VER</name>&gt;1201</expr></cpp:elif>
  <comment type="block">/* Do not include addrinfo.h for MSVC7 or greater. 'addrinfo' and
   * EAI_* constants are defined in (the already included) ws2tcpip.h.
   */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"addrinfo.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_INET_PTON</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NTDDI_VERSION</name></expr></argument>)</argument_list></call> || (<name>NTDDI_VERSION</name> &lt; <name>NTDDI_LONGHORN</name>)</expr></cpp:if>
<function_decl><type><name>int</name></type> <name>inet_pton</name><parameter_list>(<param><decl><type><name>int</name></type> <name>af</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dst</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>inet_ntop</name><parameter_list>(<param><decl><type><name>int</name></type> <name>af</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>src</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>socklen_t</name></type> <name>size</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
<comment type="block">/* On OS X, getaddrinfo returns no error indication of lookup
   failure, so we must use the emulation instead of the libinfo
   implementation. Unfortunately, performing an autoconf test
   for this bug would require DNS access for the machine performing
   the configuration, which is not acceptable. Therefore, we
   determine the bug just by checking for __APPLE__. If this bug
   gets ever fixed, perhaps checking for sys/version.h would be
   appropriate, which is 10/0 on the system with the bug. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_GETNAMEINFO</name></cpp:ifndef>
<comment type="block">/* This bug seems to be fixed in Jaguar. Ths easiest way I could
   Find to check for Jaguar is that it has getnameinfo(), which
   older releases don't have */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_GETADDRINFO</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INET_ATON</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_INET_ATON_WEAKLINK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* I know this is a bad practice, but it is the easiest... */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETADDRINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* avoid clashes with the C library definition of the symbol. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getaddrinfo</name></cpp:macro> <cpp:value>fake_getaddrinfo</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gai_strerror</name></cpp:macro> <cpp:value>fake_gai_strerror</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>freeaddrinfo</name></cpp:macro> <cpp:value>fake_freeaddrinfo</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getaddrinfo.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETNAMEINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getnameinfo</name></cpp:macro> <cpp:value>fake_getnameinfo</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getnameinfo.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* BeOS suffers from the same socket dichotomy as Win32... - [cjh] */</comment>
<comment type="block">/* seem to be a few differences in the API */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCKETCLOSE</name></cpp:macro> <cpp:value>closesocket</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DUP</name></cpp:macro></cpp:define> <comment type="block">/* Actually it exists on NT 3.5, but what the heck... */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAFNOSUPPORT</name></cpp:macro> <cpp:value>WSAEAFNOSUPPORT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCKETCLOSE</name></cpp:macro> <cpp:value>soclose</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DUP</name></cpp:macro></cpp:define> <comment type="block">/* Sockets are Not Actual File Handles under OS/2 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SOCKETCLOSE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCKETCLOSE</name></cpp:macro> <cpp:value>close</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BLUETOOTH_H</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BLUETOOTH_BLUETOOTH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_BLUETOOTH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTPROTO_L2CAP</name></cpp:macro> <cpp:value>BLUETOOTH_PROTO_L2CAP</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTPROTO_RFCOMM</name></cpp:macro> <cpp:value>BLUETOOTH_PROTO_RFCOMM</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTPROTO_HCI</name></cpp:macro> <cpp:value>BLUETOOTH_PROTO_HCI</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOL_HCI</name></cpp:macro> <cpp:value>SOL_HCI_RAW</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HCI_FILTER</name></cpp:macro> <cpp:value>SO_HCI_RAW_FILTER</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_l2</name></cpp:macro> <cpp:value>sockaddr_l2cap</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_rc</name></cpp:macro> <cpp:value>sockaddr_rfcomm</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hci_dev</name></cpp:macro> <cpp:value>hci_node</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_L2_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;l2cap_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_RC_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;rfcomm_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_HCI_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;hci_##memb)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_l2</name></cpp:macro> <cpp:value>sockaddr_bt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_rc</name></cpp:macro> <cpp:value>sockaddr_bt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_hci</name></cpp:macro> <cpp:value>sockaddr_bt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sockaddr_sco</name></cpp:macro> <cpp:value>sockaddr_bt</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_L2_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;bt_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_RC_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;bt_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_HCI_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;bt_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_SCO_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;bt_##memb)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_L2_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;l2_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_RC_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;rc_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_HCI_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;hci_##memb)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BT_SCO_MEMB</name><parameter_list>(<param><type><name>sa</name></type></param>, <param><type><name>memb</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((sa)-&gt;sco_##memb)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
<comment type="block">/* TCP/IP Services for VMS uses a maximum send/recv buffer length */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_SIZE</name></cpp:macro> <cpp:value>(32 * 1024 -1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>SAS2SA</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((struct sockaddr *)(x))</cpp:value></cpp:define>

<comment type="block">/*
 * Constants for getnameinfo()
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_MAXHOST</name></cpp:macro> <cpp:value>1025</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NI_MAXSERV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NI_MAXSERV</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* XXX There's a problem here: *static* functions are not supposed to have
   a Py prefix (or use CapitalizedWords).  Later... */</comment>

<comment type="block">/* Global variable holding the exception type for errors detected
   by this module (but not argument type or memory errors, etc.). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>socket_error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>socket_herror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>socket_gaierror</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>socket_timeout</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
<comment type="block">/* Global variable which is !=0 if Python is running in a RISC OS taskwindow */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>taskwindow</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* A forward reference to the socket type object.
   The sock_type variable contains pointers to various functions,
   some of which call new_sockobject(), which uses sock_type, so
   there has to be a circular reference. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>sock_type</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE</name></cpp:ifdef>
<comment type="block">/* Platform can select file descriptors beyond FD_SETSIZE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SELECTABLE</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* Instead of select(), we'll use poll() since poll() works on any fd. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SELECTABLE</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/* Can we call select() with this socket without a buffer overrun? */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* POSIX says selecting file descriptors beyond FD_SETSIZE
   has undefined behaviour.  If there's no timeout left, we don't have to
   call select, so it's a safe, little white lie. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SELECTABLE</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((s)-&gt;sock_fd &lt; FD_SETSIZE || s-&gt;sock_timeout &lt;= 0.0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>select_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"unable to select on socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Convenience function to raise an error according to errno
   and return a NULL pointer from a function. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>err_no</name> <init>= <expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* PyErr_SetExcFromWindowsErr() invokes FormatMessage() which
	   recognizes the error codes used by both GetLastError() and
	   WSAGetLastError */</comment>
	<if>if <condition>(<expr><name>err_no</name></expr>)</condition><then>
		<return>return <expr><call><name>PyErr_SetExcFromWindowsErr</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>err_no</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><call><name>sock_errno</name><argument_list>()</argument_list></call> != <name>NO_ERROR</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ULONG</name></type>  <name>msglen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>outbuf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>myerrorcode</name> <init>= <expr><call><name>sock_errno</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Retrieve socket-related error message from MPTN.MSG file */</comment>
		<expr_stmt><expr><name>rc</name> = <call><name>DosGetMessage</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				   <argument><expr><name>myerrorcode</name> - <name>SOCBASEERR</name> + 26</expr></argument>,
				   <argument><expr>"mptn.msg"</expr></argument>,
				   <argument><expr>&amp;<name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rc</name> == <name>NO_ERROR</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

			<comment type="block">/* OS/2 doesn't guarantee a terminator */</comment>
			<expr_stmt><expr><name><name>outbuf</name><index>[<expr><name>msglen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
				<comment type="block">/* If non-empty msg, trim CRLF */</comment>
				<decl_stmt><decl><type><name>char</name> *</type><name>lastc</name> <init>= <expr>&amp;<name><name>outbuf</name><index>[ <expr><call><name>strlen</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>)</argument_list></call>-1</expr> ]</index></name></expr></init></decl>;</decl_stmt>
				<while>while <condition>(<expr><name>lastc</name> &gt; <name>outbuf</name> &amp;&amp;
				       <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>lastc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
					<comment type="block">/* Trim trailing whitespace (CRLF) */</comment>
					<expr_stmt><expr>*<name>lastc</name>-- = '\0'</expr>;</expr_stmt>
				}</block></while>
			}</block></then></if>
			<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>myerrorcode</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><name><name>_inet_error</name>.<name>errnum</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name>_inet_err</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_herror</name><parameter_list>(<param><decl><type><name>int</name></type> <name>h_error</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_HSTRERROR</name></cpp:ifdef>
	<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>h_error</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>hstrerror</name><argument_list>(<argument><expr><name>h_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>h_error</name></expr></argument>, <argument><expr>"host not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>socket_herror</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set_gaierror</name><parameter_list>(<param><decl><type><name>int</name></type> <name>error</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_SYSTEM</name></cpp:ifdef>
	<comment type="block">/* EAI_SYSTEM is not available on Windows XP. */</comment>
	<if>if <condition>(<expr><name>error</name> == <name>EAI_SYSTEM</name></expr>)</condition><then>
		<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GAI_STRERROR</name></cpp:ifdef>
	<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(is)"</expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr>"getaddrinfo failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>socket_gaierror</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
<comment type="block">/* Function to send in segments */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>sendsegmented</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sock_fd</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>remaining</name> &gt; 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>segment</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>segment</name> = (<name>remaining</name> &gt;= <name>SEGMENT_SIZE</name> ? <name>SEGMENT_SIZE</name> : <name>remaining</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>send</name><argument_list>(<argument><expr><name>sock_fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
			<return>return <expr><name>n</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>remaining</name> -= <name>segment</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> += <name>segment</name></expr>;</expr_stmt>
	}</block></while> <comment type="block">/* end while */</comment>

	<return>return <expr><name>len</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Function to perform the setting of socket blocking mode
   internally. block = (1 | 0). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_setblocking</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RISCOS</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
	<decl_stmt><decl><type><name>int</name></type> <name>delay_flag</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__BEOS__</name></cpp:ifdef>
	<name>block</name> <init>= <expr>!<name>block</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_NONBLOCK</name></expr></argument>,
		   <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr>&amp;<name>block</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RISCOS</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>block</name> = !<name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr>(<name>caddr_t</name>)&amp;<name>block</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>block</name> = !<name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>int</name> *)&amp;<name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* !PYOS_OS2 &amp;&amp; !__VMS */</comment>
	<expr_stmt><expr><name>delay_flag</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>block</name></expr>)</condition><then>
		<expr_stmt><expr><name>delay_flag</name> &amp;= (~<name>O_NONBLOCK</name>)</expr>;</expr_stmt></then>
	<else>else
		<expr_stmt><expr><name>delay_flag</name> |= <name>O_NONBLOCK</name></expr>;</expr_stmt></else></if>
	<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>delay_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !PYOS_OS2 */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* MS_WINDOWS */</comment>
	<expr_stmt><expr><name>block</name> = !<name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ioctlsocket</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr>(<name>u_long</name>*)&amp;<name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* RISCOS */</comment>
	<expr_stmt><expr><name>block</name> = !<name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>socketioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr>(<name>u_long</name>*)&amp;<name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* RISCOS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __BEOS__ */</comment>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<comment type="block">/* Since these don't return anything */</comment>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Do a select()/poll() on the socket, if necessary (sock_timeout &gt; 0).
   The argument writing indicates the direction.
   This does not raise an exception; we'll let our caller do that
   after they've reacquired the interpreter lock.
   Returns 1 on timeout, -1 on error, 0 otherwise. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_select</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>writing</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do unless we're in timeout mode (not non-blocking) */</comment>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &lt;= 0.0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<comment type="block">/* Guard against closed socket */</comment>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_fd</name></name> &lt; 0</expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<comment type="block">/* Prefer poll, if available, since you can poll() any fd
	 * which can't be done with select(). */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL</name></cpp:ifdef>
	<block>{
		<decl_stmt><decl><type>struct <name>pollfd</name></type> <name>pollfd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>pollfd</name>.<name>fd</name></name> = <name><name>s</name>-&gt;<name>sock_fd</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pollfd</name>.<name>events</name></name> = <name>writing</name> ? <name>POLLOUT</name> : <name>POLLIN</name></expr>;</expr_stmt>

		<comment type="block">/* s-&gt;sock_timeout is in seconds, timeout in ms */</comment>
		<expr_stmt><expr><name>timeout</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> * 1000 + 0.5</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<expr_stmt><expr><name>n</name> = <call><name>poll</name><argument_list>(<argument><expr>&amp;<name>pollfd</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<block>{
		<comment type="block">/* Construct the arguments to select */</comment>
		<decl_stmt><decl><type><name>fd_set</name></type> <name>fds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>tv</name>.<name>tv_sec</name></name> = (<name>int</name>)<name><name>s</name>-&gt;<name>sock_timeout</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tv</name>.<name>tv_usec</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>sock_timeout</name></name> - <name><name>tv</name>.<name>tv_sec</name></name>) * 1e6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* See if the socket is ready */</comment>
		<if>if <condition>(<expr><name>writing</name></expr>)</condition><then>
			<expr_stmt><expr><name>n</name> = <call><name>select</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name>+1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>n</name> = <call><name>select</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name>+1</expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>
	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
		<return>return <expr>1</expr>;</return></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Initialize a new socket object. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>defaulttimeout</name> <init>= <expr>-1.0</expr></init></decl>;</decl_stmt> <comment type="block">/* Default timeout for new sockets */</comment>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_sockobject</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>,
		<param><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl></param>, <param><decl><type><name>int</name></type> <name>family</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>int</name></type> <name>proto</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>block</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_fd</name></name> = <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_family</name></name> = <name>family</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_type</name></name> = <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_proto</name></name> = <name>proto</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> = <name>defaulttimeout</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>s</name>-&gt;<name>errorhandler</name></name> = &amp;<name>set_error</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>defaulttimeout</name> &gt;= 0.0</expr>)</condition><then>
		<expr_stmt><expr><call><name>internal_setblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
	<if>if <condition>(<expr><name>taskwindow</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>socketioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>0x80046679</expr></argument>, <argument><expr>(<name>u_long</name>*)&amp;<name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="block">/* Create a new socket object.
   This just creates the object and initializes it.
   If the creation fails, return NULL and set an exception (implicit
   in NEWOBJ()). */</comment>

<function><type><specifier>static</specifier> <name>PySocketSockObject</name> *</type>
<name>new_sockobject</name><parameter_list>(<param><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl></param>, <param><decl><type><name>int</name></type> <name>family</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>int</name></type> <name>proto</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>s</name> = (<name>PySocketSockObject</name> *)
		<call><name>PyType_GenericNew</name><argument_list>(<argument><expr>&amp;<name>sock_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>init_sockobject</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>s</name></expr>;</return>
}</block></function>


<comment type="block">/* Lock to allow python interpreter to continue, but only allow one
   thread to be in gethostbyname or getaddrinfo */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_GETADDRINFO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyThread_type_lock</name></type> <name>netdb_lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Convert a string specifying a host name or one of a few symbolic
   names to a numeric IP address.  This usually calls gethostbyname()
   to do the work; the names "" and "&lt;broadcast&gt;" are special.
   Return the length (IPv4 should be 4 bytes), or negative if
   an error occurred; then an exception is raised. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setipaddr</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type>struct <name>sockaddr</name> *</type><name>addr_ret</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>addr_ret_size</name></decl></param>, <param><decl><type><name>int</name></type> <name>af</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>addrinfo</name></type> <name>hints</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>d1</name></decl>, <decl><type ref="prev"/><name>d2</name></decl>, <decl><type ref="prev"/><name>d3</name></decl>, <decl><type ref="prev"/><name>d4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) <name>addr_ret</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>addr_ret</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>siz</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>af</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name>.<name>ai_socktype</name></name> = <name>SOCK_DGRAM</name></expr>;</expr_stmt>	<comment type="block">/*dummy*/</comment>
		<expr_stmt><expr><name><name>hints</name>.<name>ai_flags</name></name> = <name>AI_PASSIVE</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name>
		<name>ACQUIRE_GETADDRINFO_LOCK</name></type>
		<name>error</name> <init>= <expr><call><name>getaddrinfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>"0"</expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
		<comment type="block">/* We assume that those thread-unsafe getaddrinfo() versions
		   *are* safe regarding their return value, ie. that a
		   subsequent call to getaddrinfo() does not destroy the
		   outcome of the first call. */</comment>
		<name>RELEASE_GETADDRINFO_LOCK</name></expr></expr_stmt>
		<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<switch>switch <condition>(<expr><name><name>res</name>-&gt;<name>ai_family</name></name></expr>)</condition> <block>{
		<case>case <expr><name>AF_INET</name></expr>:
			<expr_stmt><expr><name>siz</name> = 4</expr>;</expr_stmt>
			<break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
		</case><case>case <expr><name>AF_INET6</name></expr>:
			<expr_stmt><expr><name>siz</name> = 16</expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><default>default:
			<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
				<argument><expr>"unsupported address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		</default>}</block></switch>
		<if>if <condition>(<expr><name><name>res</name>-&gt;<name>ai_next</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
				<argument><expr>"wildcard resolved to multiple address"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>res</name>-&gt;<name>ai_addrlen</name></name> &lt; <name>addr_ret_size</name></expr>)</condition><then>
			<expr_stmt><expr><name>addr_ret_size</name> = <name><name>res</name>-&gt;<name>ai_addrlen</name></name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>addr_ret</name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addr</name></name></expr></argument>, <argument><expr><name>addr_ret_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>siz</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == '&lt;' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"&lt;broadcast&gt;"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type>struct <name>sockaddr_in</name> *</type><name>sin</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>af</name> != <name>AF_INET</name> &amp;&amp; <name>af</name> != <name>AF_UNSPEC</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
				<argument><expr>"address family mismatched"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>sin</name> = (struct <name>sockaddr_in</name> *)<name>addr_ret</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) <name>sin</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SOCKADDR_SA_LEN</name></cpp:ifdef>
		<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>sin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_addr</name>.<name>s_addr</name></name> = <name>INADDR_BROADCAST</name></expr>;</expr_stmt>
		<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sin</name>-&gt;<name>sin_addr</name></name></expr></argument>)</argument_list></sizeof></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"%d.%d.%d.%d%c"</expr></argument>, <argument><expr>&amp;<name>d1</name></expr></argument>, <argument><expr>&amp;<name>d2</name></expr></argument>, <argument><expr>&amp;<name>d3</name></expr></argument>, <argument><expr>&amp;<name>d4</name></expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>)</argument_list></call> == 4 &amp;&amp;
	    0 &lt;= <name>d1</name> &amp;&amp; <name>d1</name> &lt;= 255 &amp;&amp; 0 &lt;= <name>d2</name> &amp;&amp; <name>d2</name> &lt;= 255 &amp;&amp;
	    0 &lt;= <name>d3</name> &amp;&amp; <name>d3</name> &lt;= 255 &amp;&amp; 0 &lt;= <name>d4</name> &amp;&amp; <name>d4</name> &lt;= 255</expr>)</condition><then> <block>{
		<decl_stmt><decl><type>struct <name>sockaddr_in</name> *</type><name>sin</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>sin</name> = (struct <name>sockaddr_in</name> *)<name>addr_ret</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_addr</name>.<name>s_addr</name></name> = <call><name>htonl</name><argument_list>(
			<argument><expr>((<name>long</name>) <name>d1</name> &lt;&lt; 24) | ((<name>long</name>) <name>d2</name> &lt;&lt; 16) |
			((<name>long</name>) <name>d3</name> &lt;&lt; 8) | ((<name>long</name>) <name>d4</name> &lt;&lt; 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SOCKADDR_SA_LEN</name></cpp:ifdef>
		<expr_stmt><expr><name><name>sin</name>-&gt;<name>sin_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>sin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>4</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>af</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name>
	<name>ACQUIRE_GETADDRINFO_LOCK</name></type>
	<name>error</name> <init>= <expr><call><name>getaddrinfo</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__digital__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__unix__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if <condition>(<expr><name>error</name> == <name>EAI_NONAME</name> &amp;&amp; <name>af</name> == <name>AF_UNSPEC</name></expr>)</condition><then> <block>{
		<comment type="block">/* On Tru64 V5.1, numeric-to-addr conversion fails
		   if no address family is given. Assume IPv4 for now.*/</comment>
		<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>error</name> = <call><name>getaddrinfo</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
	<name>RELEASE_GETADDRINFO_LOCK</name></expr></expr_stmt>  <comment type="block">/* see comment in setipaddr() */</comment>
	<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>res</name>-&gt;<name>ai_addrlen</name></name> &lt; <name>addr_ret_size</name></expr>)</condition><then>
		<expr_stmt><expr><name>addr_ret_size</name> = <name><name>res</name>-&gt;<name>ai_addrlen</name></name></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *) <name>addr_ret</name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addr</name></name></expr></argument>, <argument><expr><name>addr_ret_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>addr_ret</name>-&gt;<name>sa_family</name></name></expr>)</condition> <block>{
	<case>case <expr><name>AF_INET</name></expr>:
		<return>return <expr>4</expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	</case><case>case <expr><name>AF_INET6</name></expr>:
		<return>return <expr>16</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"unknown address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	</default>}</block></switch>
}</block></function>


<comment type="block">/* Create a string object representing an IP address.
   This is always a string of the form 'dd.dd.dd.dd' (with variable
   size numbers). */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>makeipaddr</name><parameter_list>(<param><decl><type>struct <name>sockaddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>addrlen</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>error</name> = <call><name>getnameinfo</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
		<argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BLUETOOTH</name></cpp:ifdef>
<comment type="block">/* Convert a string representation of a Bluetooth address into a numeric
   address.  Returns the length (6), or raises an exception and returns -1 if
   an error occurred. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setbdaddr</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>bdaddr_t</name> *</type><name>bdaddr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>b0</name></decl>, <decl><type ref="prev"/><name>b1</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>, <decl><type ref="prev"/><name>b3</name></decl>, <decl><type ref="prev"/><name>b4</name></decl>, <decl><type ref="prev"/><name>b5</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> = <call><name>sscanf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"%X:%X:%X:%X:%X:%X%c"</expr></argument>,
		   <argument><expr>&amp;<name>b5</name></expr></argument>, <argument><expr>&amp;<name>b4</name></expr></argument>, <argument><expr>&amp;<name>b3</name></expr></argument>, <argument><expr>&amp;<name>b2</name></expr></argument>, <argument><expr>&amp;<name>b1</name></expr></argument>, <argument><expr>&amp;<name>b0</name></expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> == 6 &amp;&amp; (<name>b0</name> | <name>b1</name> | <name>b2</name> | <name>b3</name> | <name>b4</name> | <name>b5</name>) &lt; 256</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>0</expr>]</index></name> = <name>b0</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>1</expr>]</index></name> = <name>b1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>2</expr>]</index></name> = <name>b2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>3</expr>]</index></name> = <name>b3</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>4</expr>]</index></name> = <name>b4</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>5</expr>]</index></name> = <name>b5</name></expr>;</expr_stmt>
		<return>return <expr>6</expr>;</return>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"bad bluetooth address"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></else></if>
}</block></function>

<comment type="block">/* Create a string representation of the Bluetooth address.  This is always a
   string of the form 'XX:XX:XX:XX:XX:XX' where XX is a two digit hexadecimal
   value (zero padded if necessary). */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>makebdaddr</name><parameter_list>(<param><decl><type><name>bdaddr_t</name> *</type><name>bdaddr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>(6 * 2) + 5 + 1</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%02X:%02X:%02X:%02X:%02X:%02X"</expr></argument>,
		<argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>5</expr>]</index></name></expr></argument>, <argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>3</expr>]</index></name></expr></argument>,
		<argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>bdaddr</name>-&gt;<name>b</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Create an object representing the given socket address,
   suitable for passing it back to bind(), connect() etc.
   The family field of the sockaddr structure is inspected
   to determine what kind of address it really is. */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>makesockaddr</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sockfd</name></decl></param>, <param><decl><type>struct <name>sockaddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>addrlen</name></decl></param>, <param><decl><type><name>int</name></type> <name>proto</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>addrlen</name> == 0</expr>)</condition><then> <block>{
		<comment type="block">/* No address -- may be recvfrom() from known socket */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__BEOS__</name></cpp:ifdef>
	<comment type="block">/* XXX: BeOS version of accept() doesn't set family correctly */</comment>
	<expr_stmt><expr><name><name>addr</name>-&gt;<name>sa_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<switch>switch <condition>(<expr><name><name>addr</name>-&gt;<name>sa_family</name></name></expr>)</condition> <block>{

	<case>case <expr><name>AF_INET</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_in</name> *</type><name>a</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>addrobj</name> <init>= <expr><call><name>makeipaddr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>addrobj</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>a</name> = (struct <name>sockaddr_in</name> *)<name>addr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oi"</expr></argument>, <argument><expr><name>addrobj</name></expr></argument>, <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sin_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr><name>ret</name></expr>;</return>
	}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
	</case><case>case <expr><name>AF_UNIX</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_un</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_un</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>linux</name></cpp:ifdef>
		<if>if <condition>(<expr><name><name>a</name>-&gt;<name>sun_path</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then> <block>{  <comment type="block">/* Linux abstract namespace */</comment>
			<expr_stmt><expr><name>addrlen</name> -= <call><name>offsetof</name><argument_list>(<argument>struct <expr><name>sockaddr_un</name></expr></argument>, <argument><expr><name>sun_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sun_path</name></name></expr></argument>,
							  <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* linux */</comment>
		<block>{
			<comment type="block">/* regular NULL-terminated string */</comment>
			<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sun_path</name></name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></else></if>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AF_UNIX */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
       </case><case>case <expr><name>AF_NETLINK</name></expr>:
       <block>{
               <decl_stmt><decl><type>struct <name>sockaddr_nl</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_nl</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
               <return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"II"</expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>nl_pid</name></name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>nl_groups</name></name></expr></argument>)</argument_list></call></expr>;</return>
       }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AF_NETLINK */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	</case><case>case <expr><name>AF_INET6</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_in6</name> *</type><name>a</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>addrobj</name> <init>= <expr><call><name>makeipaddr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>addrobj</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>a</name> = (struct <name>sockaddr_in6</name> *)<name>addr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oiii"</expr></argument>,
					    <argument><expr><name>addrobj</name></expr></argument>,
					    <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sin6_port</name></name></expr></argument>)</argument_list></call></expr></argument>,
					    <argument><expr><name><name>a</name>-&gt;<name>sin6_flowinfo</name></name></expr></argument>,
					    <argument><expr><name><name>a</name>-&gt;<name>sin6_scope_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr><name>ret</name></expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BLUETOOTH</name></cpp:ifdef>
	</case><case>case <expr><name>AF_BLUETOOTH</name></expr>:
		<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{

		<case>case <expr><name>BTPROTO_L2CAP</name></expr>:
		<block>{
			<decl_stmt><decl><type>struct <name>sockaddr_l2</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_l2</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>addrobj</name> <init>= <expr><call><name>makebdaddr</name><argument_list>(<argument><expr>&amp;<call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>addrobj</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oi"</expr></argument>,
						    <argument><expr><name>addrobj</name></expr></argument>,
						    <argument><expr><call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>psm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<return>return <expr><name>ret</name></expr>;</return>
		}</block>

		</case><case>case <expr><name>BTPROTO_RFCOMM</name></expr>:
		<block>{
			<decl_stmt><decl><type>struct <name>sockaddr_rc</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_rc</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>addrobj</name> <init>= <expr><call><name>makebdaddr</name><argument_list>(<argument><expr>&amp;<call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>addrobj</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Oi"</expr></argument>,
						    <argument><expr><name>addrobj</name></expr></argument>,
						    <argument><expr><call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addrobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<return>return <expr><name>ret</name></expr>;</return>
		}</block>

		</case><case>case <expr><name>BTPROTO_HCI</name></expr>:
		<block>{
			<decl_stmt><decl><type>struct <name>sockaddr_hci</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_hci</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"i"</expr></argument>, <argument><expr><call><name>_BT_HCI_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>dev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ret</name></expr>;</return>
		}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
		</case><case>case <expr><name>BTPROTO_SCO</name></expr>:
		<block>{
			<decl_stmt><decl><type>struct <name>sockaddr_sco</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_sco</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>makebdaddr</name><argument_list>(<argument><expr>&amp;<call><name>_BT_SCO_MEMB</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		</case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETPACKET_PACKET_H</name></cpp:ifdef>
	</case><case>case <expr><name>AF_PACKET</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_ll</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_ll</name> *)<name>addr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>ifname</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>ifreq</name></type> <name>ifr</name></decl>;</decl_stmt>
		<comment type="block">/* need to look up interface name give index */</comment>
		<if>if <condition>(<expr><name><name>a</name>-&gt;<name>sll_ifindex</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>ifr</name>.<name>ifr_ifindex</name></name> = <name><name>a</name>-&gt;<name>sll_ifindex</name></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name>sockfd</name></expr></argument>, <argument><expr><name>SIOCGIFNAME</name></expr></argument>, <argument><expr>&amp;<name>ifr</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ifname</name> = <name><name>ifr</name>.<name>ifr_name</name></name></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"shbhs#"</expr></argument>,
				     <argument><expr><name>ifname</name></expr></argument>,
				     <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>sll_protocol</name></name></expr></argument>)</argument_list></call></expr></argument>,
				     <argument><expr><name><name>a</name>-&gt;<name>sll_pkttype</name></name></expr></argument>,
				     <argument><expr><name><name>a</name>-&gt;<name>sll_hatype</name></name></expr></argument>,
				     <argument><expr><name><name>a</name>-&gt;<name>sll_addr</name></name></expr></argument>,
				     <argument><expr><name><name>a</name>-&gt;<name>sll_halen</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_TIPC_H</name></cpp:ifdef>
	</case><case>case <expr><name>AF_TIPC</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_tipc</name> *</type><name>a</name> <init>= <expr>(struct <name>sockaddr_tipc</name> *) <name>addr</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name><name>a</name>-&gt;<name>addrtype</name></name> == <name>TIPC_ADDR_NAMESEQ</name></expr>)</condition><then> <block>{
			<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"IIIII"</expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addrtype</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>type</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>lower</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>upper</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>scope</name></name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then> <else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>addrtype</name></name> == <name>TIPC_ADDR_NAME</name></expr>)</condition><then> <block>{
			<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"IIIII"</expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addrtype</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>type</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>instance</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>instance</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>scope</name></name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then> <else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>addrtype</name></name> == <name>TIPC_ADDR_ID</name></expr>)</condition><then> <block>{
			<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"IIIII"</expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addrtype</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>id</name>.<name>node</name></name></expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>addr</name>.<name>id</name>.<name>ref</name></name></expr></argument>,
					<argument><expr>0</expr></argument>,
					<argument><expr><name><name>a</name>-&gt;<name>scope</name></name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
					<argument><expr>"Invalid address type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></else></if></else></if></else></if>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* More cases here... */</comment>

	</case><default>default:
		<comment type="block">/* If we don't know the address family, don't raise an
		   exception -- return it as a tuple. */</comment>
		<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"is#"</expr></argument>,
				     <argument><expr><name><name>addr</name>-&gt;<name>sa_family</name></name></expr></argument>,
				     <argument><expr><name><name>addr</name>-&gt;<name>sa_data</name></name></expr></argument>,
				     <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>addr</name>-&gt;<name>sa_data</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

	</default>}</block></switch>
}</block></function>


<comment type="block">/* Parse a socket address argument according to the socket object's
   address family.  Return 1 if the address was in the proper format,
   0 of not.  The address is returned through addr_ret, its length
   through len_ret. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>getsockaddrarg</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>,
	       <param><decl><type>struct <name>sockaddr</name> *</type><name>addr_ret</name></decl></param>, <param><decl><type><name>int</name> *</type><name>len_ret</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr>)</condition> <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<case>case <expr><name>AF_UNIX</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_un</name>*</type> <name>addr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>

		<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_un</name>*)<name>addr_ret</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>linux</name></cpp:ifdef>
		<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name><name>path</name><index>[<expr>0</expr>]</index></name> == 0</expr>)</condition><then> <block>{
			<comment type="block">/* Linux abstract namespace extension */</comment>
			<if>if <condition>(<expr><name>len</name> &gt; sizeof <name><name>addr</name>-&gt;<name>sun_path</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
						<argument><expr>"AF_UNIX path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
		}</block></then>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* linux */</comment>
                <block>{
			<comment type="block">/* regular NULL-terminated string */</comment>
			<if>if <condition>(<expr><name>len</name> &gt;= sizeof <name><name>addr</name>-&gt;<name>sun_path</name></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
						<argument><expr>"AF_UNIX path too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name><name>addr</name>-&gt;<name>sun_path</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>
		}</block></else></if>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sun_family</name></name> = <name><name>s</name>-&gt;<name>sock_family</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>addr</name>-&gt;<name>sun_path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr>*<name>len_ret</name> = <name>len</name> + <call><name>offsetof</name><argument_list>(<argument>struct <expr><name>sockaddr_un</name></expr></argument>, <argument><expr><name>sun_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AF_UNIX */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
	</case><case>case <expr><name>AF_NETLINK</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_nl</name>*</type> <name>addr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>, <decl><type ref="prev"/><name>groups</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_nl</name> *)<name>addr_ret</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"getsockaddrarg: "
				"AF_NETLINK address must be tuple, not %.500s"</expr></argument>,
				<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"II:getsockaddrarg"</expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr>&amp;<name>groups</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>nl_family</name></name> = <name>AF_NETLINK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>nl_pid</name></name> = <name>pid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>nl_groups</name></name> = <name>groups</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case><case>case <expr><name>AF_INET</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_in</name>*</type> <name>addr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>host</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"getsockaddrarg: "
				"AF_INET address must be tuple, not %.500s"</expr></argument>,
				<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti:getsockaddrarg"</expr></argument>,
				      <argument><expr>"idna"</expr></argument>, <argument><expr>&amp;<name>host</name></expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name>addr</name>=(struct <name>sockaddr_in</name>*)<name>addr_ret</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> = <call><name>setipaddr</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)<name>addr</name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>,  <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin_port</name></name> = <call><name>htons</name><argument_list>(<argument><expr>(<name>short</name>)<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	</case><case>case <expr><name>AF_INET6</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_in6</name>*</type> <name>addr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>host</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>, <decl><type ref="prev"/><name>flowinfo</name></decl>, <decl><type ref="prev"/><name>scope_id</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>flowinfo</name> = <name>scope_id</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"getsockaddrarg: "
				"AF_INET6 address must be tuple, not %.500s"</expr></argument>,
				<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"eti|ii"</expr></argument>,
				      <argument><expr>"idna"</expr></argument>, <argument><expr>&amp;<name>host</name></expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>, <argument><expr>&amp;<name>flowinfo</name></expr></argument>,
				      <argument><expr>&amp;<name>scope_id</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_in6</name>*)<name>addr_ret</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> = <call><name>setipaddr</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)<name>addr</name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin6_family</name></name> = <name><name>s</name>-&gt;<name>sock_family</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin6_port</name></name> = <call><name>htons</name><argument_list>(<argument><expr>(<name>short</name>)<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin6_flowinfo</name></name> = <name>flowinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sin6_scope_id</name></name> = <name>scope_id</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BLUETOOTH</name></cpp:ifdef>
	</case><case>case <expr><name>AF_BLUETOOTH</name></expr>:
	<block>{
		<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr>)</condition> <block>{
		<case>case <expr><name>BTPROTO_L2CAP</name></expr>:
		<block>{
			<decl_stmt><decl><type>struct <name>sockaddr_l2</name> *</type><name>addr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>straddr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_l2</name> *)<name>addr_ret</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call> = <name>AF_BLUETOOTH</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"si"</expr></argument>, <argument><expr>&amp;<name>straddr</name></expr></argument>,
					      <argument><expr>&amp;<call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>psm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: "
						"wrong format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>setbdaddr</name><argument_list>(<argument><expr><name>straddr</name></expr></argument>, <argument><expr>&amp;<call><name>_BT_L2_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>

			<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block>
		</case><case>case <expr><name>BTPROTO_RFCOMM</name></expr>:
		<block>{
			<decl_stmt><decl><type>struct <name>sockaddr_rc</name> *</type><name>addr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>straddr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_rc</name> *)<name>addr_ret</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call> = <name>AF_BLUETOOTH</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"si"</expr></argument>, <argument><expr>&amp;<name>straddr</name></expr></argument>,
					      <argument><expr>&amp;<call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: "
						"wrong format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>setbdaddr</name><argument_list>(<argument><expr><name>straddr</name></expr></argument>, <argument><expr>&amp;<call><name>_BT_RC_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>

			<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block>
		</case><case>case <expr><name>BTPROTO_HCI</name></expr>:
		<block>{
			<decl_stmt><decl><type>struct <name>sockaddr_hci</name> *</type><name>addr</name> <init>= <expr>(struct <name>sockaddr_hci</name> *)<name>addr_ret</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>_BT_HCI_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call> = <name>AF_BLUETOOTH</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i"</expr></argument>, <argument><expr>&amp;<call><name>_BT_HCI_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>dev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: "
						"wrong format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
		</case><case>case <expr><name>BTPROTO_SCO</name></expr>:
		<block>{
			<decl_stmt><decl><type>struct <name>sockaddr_sco</name> *</type><name>addr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>straddr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_sco</name> *)<name>addr_ret</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_BT_SCO_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call> = <name>AF_BLUETOOTH</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>straddr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>straddr</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: "
						"wrong format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>0</expr>;</return>
			}</block></then></if>
			<if>if <condition>(<expr><call><name>setbdaddr</name><argument_list>(<argument><expr><name>straddr</name></expr></argument>, <argument><expr>&amp;<call><name>_BT_SCO_MEMB</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>bdaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
				<return>return <expr>0</expr>;</return></then></if>

			<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: unknown Bluetooth protocol"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		</default>}</block></switch>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETPACKET_PACKET_H</name></cpp:ifdef>
	</case><case>case <expr><name>AF_PACKET</name></expr>:
	<block>{
		<decl_stmt><decl><type>struct <name>sockaddr_ll</name>*</type> <name>addr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>ifreq</name></type> <name>ifr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>interfaceName</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>protoNumber</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>hatype</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>pkttype</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>haddr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>halen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

		<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"getsockaddrarg: "
				"AF_PACKET address must be tuple, not %.500s"</expr></argument>,
				<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"si|iis#"</expr></argument>, <argument><expr>&amp;<name>interfaceName</name></expr></argument>,
				      <argument><expr>&amp;<name>protoNumber</name></expr></argument>, <argument><expr>&amp;<name>pkttype</name></expr></argument>, <argument><expr>&amp;<name>hatype</name></expr></argument>,
				      <argument><expr>&amp;<name>haddr</name></expr></argument>, <argument><expr>&amp;<name>halen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>ifr</name>.<name>ifr_name</name></name></expr></argument>, <argument><expr><name>interfaceName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ifr</name>.<name>ifr_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ifr</name>.<name>ifr_name</name><index>[<expr>(<sizeof>sizeof<argument_list>(<argument><expr><name><name>ifr</name>.<name>ifr_name</name></name></expr></argument>)</argument_list></sizeof>)-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>SIOCGIFINDEX</name></expr></argument>, <argument><expr>&amp;<name>ifr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		        <expr_stmt><expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>halen</name> &gt; 8</expr>)</condition><then> <block>{
		  <expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				  <argument><expr>"Hardware address must be 8 bytes or less"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <return>return <expr>0</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_ll</name>*)<name>addr_ret</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_family</name></name> = <name>AF_PACKET</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_protocol</name></name> = <call><name>htons</name><argument_list>(<argument><expr>(<name>short</name>)<name>protoNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_ifindex</name></name> = <name><name>ifr</name>.<name>ifr_ifindex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_pkttype</name></name> = <name>pkttype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_hatype</name></name> = <name>hatype</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>halen</name> != 0</expr>)</condition><then> <block>{
		  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>addr</name>-&gt;<name>sll_addr</name></name></expr></argument>, <argument><expr><name>haddr</name></expr></argument>, <argument><expr><name>halen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>sll_halen</name></name> = <name>halen</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>len_ret</name> = sizeof *<name>addr</name></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_TIPC_H</name></cpp:ifdef>
	</case><case>case <expr><name>AF_TIPC</name></expr>:
	<block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>atype</name></decl>, <decl><type ref="prev"/><name>v1</name></decl>, <decl><type ref="prev"/><name>v2</name></decl>, <decl><type ref="prev"/><name>v3</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>scope</name> <init>= <expr><name>TIPC_CLUSTER_SCOPE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type>struct <name>sockaddr_tipc</name> *</type><name>addr</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
				<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"getsockaddrarg: "
				"AF_TIPC address must be tuple, not %.500s"</expr></argument>,
				<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>

		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
					<argument><expr>"IIII|I;Invalid TIPC address format"</expr></argument>,
					<argument><expr>&amp;<name>atype</name></expr></argument>, <argument><expr>&amp;<name>v1</name></expr></argument>, <argument><expr>&amp;<name>v2</name></expr></argument>, <argument><expr>&amp;<name>v3</name></expr></argument>, <argument><expr>&amp;<name>scope</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>

		<expr_stmt><expr><name>addr</name> = (struct <name>sockaddr_tipc</name> *) <name>addr_ret</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>sockaddr_tipc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>addr</name>-&gt;<name>family</name></name> = <name>AF_TIPC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>scope</name></name> = <name>scope</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name>-&gt;<name>addrtype</name></name> = <name>atype</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>atype</name> == <name>TIPC_ADDR_NAMESEQ</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>type</name></name> = <name>v1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>lower</name></name> = <name>v2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>nameseq</name>.<name>upper</name></name> = <name>v3</name></expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>atype</name> == <name>TIPC_ADDR_NAME</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>type</name></name> = <name>v1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>name</name>.<name>name</name>.<name>instance</name></name> = <name>v2</name></expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name>atype</name> == <name>TIPC_ADDR_ID</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>id</name>.<name>node</name></name> = <name>v1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>addr</name>-&gt;<name>addr</name>.<name>id</name>.<name>ref</name></name> = <name>v2</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<comment type="block">/* Shouldn't happen */</comment>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"Invalid address type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>
		}</block></else></if></else></if></else></if>

		<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof<argument_list>(<argument><expr>*<name>addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* More cases here... */</comment>

	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrarg: bad family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>

	</default>}</block></switch>
}</block></function>


<comment type="block">/* Get the address length according to the socket object's address family.
   Return 1 if the family is known, 0 otherwise.  The length is returned
   through len_ret. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>getsockaddrlen</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>socklen_t</name> *</type><name>len_ret</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr>)</condition> <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<case>case <expr><name>AF_UNIX</name></expr>:
	<block>{
		<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_un</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AF_UNIX */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
       </case><case>case <expr><name>AF_NETLINK</name></expr>:
       <block>{
               <expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_nl</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
               <return>return <expr>1</expr>;</return>
       }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case><case>case <expr><name>AF_INET</name></expr>:
	<block>{
		<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	</case><case>case <expr><name>AF_INET6</name></expr>:
	<block>{
		<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BLUETOOTH</name></cpp:ifdef>
	</case><case>case <expr><name>AF_BLUETOOTH</name></expr>:
	<block>{
		<switch>switch<condition>(<expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr>)</condition>
		<block>{

		<case>case <expr><name>BTPROTO_L2CAP</name></expr>:
			<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_l2</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>BTPROTO_RFCOMM</name></expr>:
			<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_rc</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		</case><case>case <expr><name>BTPROTO_HCI</name></expr>:
			<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_hci</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
		</case><case>case <expr><name>BTPROTO_SCO</name></expr>:
			<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_sco</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</case><default>default:
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrlen: "
					"unknown BT protocol"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>0</expr>;</return>

		</default>}</block></switch>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETPACKET_PACKET_H</name></cpp:ifdef>
	</case><case>case <expr><name>AF_PACKET</name></expr>:
	<block>{
		<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_ll</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_TIPC_H</name></cpp:ifdef>
	</case><case>case <expr><name>AF_TIPC</name></expr>:
	<block>{
		<expr_stmt><expr>*<name>len_ret</name> = <sizeof>sizeof <argument_list>(<argument>struct <expr><name>sockaddr_tipc</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* More cases here... */</comment>

	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockaddrlen: bad family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>

	</default>}</block></switch>
}</block></function>


<comment type="block">/* s.accept() method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_accept</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>newfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>getsockaddrlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<expr_stmt><expr><name>newfd</name> = <name>INVALID_SOCKET</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>newfd</name> = -1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
		<expr_stmt><expr><name>newfd</name> = <call><name>accept</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<if>if <condition>(<expr><name>newfd</name> == <name>INVALID_SOCKET</name></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><name>newfd</name> &lt; 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if></then></if>

	<comment type="block">/* Create the new object with unspecified family,
	   to avoid calls to bind() etc. on it. */</comment>
	<expr_stmt><expr><name>sock</name> = (<name>PyObject</name> *) <call><name>new_sockobject</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>,
					   <argument><expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr></argument>,
					   <argument><expr><name><name>s</name>-&gt;<name>sock_type</name></name></expr></argument>,
					   <argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>sock</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>finally</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>addr</name> = <call><name>makesockaddr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>,
			    <argument><expr><name>addrlen</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>addr</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>finally</name>;</goto></then></if>

	<expr_stmt><expr><name>res</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>sock</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>finally</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>accept_doc</name></expr></argument>,
<argument><expr>"accept() -&gt; (socket object, address info)\n\
\n\
Wait for an incoming connection.  Return a new socket representing the\n\
connection, and the address of the client.  For IP sockets, the address\n\
info is a pair (hostaddr, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* s.setblocking(flag) method.  Argument:
   False -- non-blocking mode; same as settimeout(0)
   True -- blocking mode; same as settimeout(None)
*/</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_setblocking</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>block</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>block</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>block</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> = <name>block</name> ? -1.0 : 0.0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>internal_setblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setblocking_doc</name></expr></argument>,
<argument><expr>"setblocking(flag)\n\
\n\
Set the socket to blocking (flag is true) or non-blocking (false).\n\
setblocking(True) is equivalent to settimeout(None);\n\
setblocking(False) is equivalent to settimeout(0.0)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* s.settimeout(timeout) method.  Argument:
   None -- no timeout, blocking mode; same as setblocking(True)
   0.0  -- non-blocking mode; same as setblocking(False)
   &gt; 0  -- timeout mode; operations time out after timeout seconds
   &lt; 0  -- illegal; raises an exception
*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_settimeout</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>timeout</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>timeout</name> = -1.0</expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>timeout</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>timeout</name> &lt; 0.0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"Timeout value out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></else></if>

	<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> = <name>timeout</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>internal_setblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>timeout</name> &lt; 0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>settimeout_doc</name></expr></argument>,
<argument><expr>"settimeout(timeout)\n\
\n\
Set a timeout on socket operations.  'timeout' can be a float,\n\
giving in seconds, or None.  Setting a timeout of None disables\n\
the timeout feature and is equivalent to setblocking(1).\n\
Setting a timeout of zero is the same as setblocking(0)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* s.gettimeout() method.
   Returns the timeout associated with a socket. */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_gettimeout</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &lt; 0.0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_timeout</name></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gettimeout_doc</name></expr></argument>,
<argument><expr>"gettimeout() -&gt; timeout\n\
\n\
Returns the timeout in floating seconds associated with socket \n\
operations. A timeout of None indicates that timeouts on socket \n\
operations are disabled."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
<comment type="block">/* s.sleeptaskw(1 | 0) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_sleeptaskw</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>,<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>block</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>block</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>block</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>socketioctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>0x80046679</expr></argument>, <argument><expr>(<name>u_long</name>*)&amp;<name>block</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<function_decl><type><name>Py_END_ALLOW_THREADS</name></type>

	<name>Py_INCREF</name><parameter_list>(<param><decl><type><name>Py_None</name></type></decl></param>)</parameter_list>;</function_decl>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sleeptaskw_doc</name></expr></argument>,
<argument><expr>"sleeptaskw(flag)\n\
\n\
Allow sleeps in taskwindows."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* s.setsockopt() method.
   With an integer third argument, sets an integer option.
   With a string third argument, sets an option from a buffer;
   use optional built-in module 'struct' to encode the string. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_setsockopt</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>optname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iii:setsockopt"</expr></argument>,
			     <argument><expr>&amp;<name>level</name></expr></argument>, <argument><expr>&amp;<name>optname</name></expr></argument>, <argument><expr>&amp;<name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>buf</name> = (<name>char</name> *) &amp;<name>flag</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buflen</name> = sizeof <name>flag</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iis#:setsockopt"</expr></argument>,
				      <argument><expr>&amp;<name>level</name></expr></argument>, <argument><expr>&amp;<name>optname</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></else></if>
	<expr_stmt><expr><name>res</name> = <call><name>setsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setsockopt_doc</name></expr></argument>,
<argument><expr>"setsockopt(level, option, value)\n\
\n\
Set a socket option.  See the Unix manual for level and option.\n\
The value argument can either be an integer or a string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.getsockopt() method.
   With two arguments, retrieves an integer option.
   With a third integer argument, retrieves a string buffer of that size;
   use optional built-in module 'struct' to decode the string. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_getsockopt</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>optname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type> <name>buflen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__BEOS__</name></cpp:ifdef>
	<comment type="block">/* We have incomplete socket support. */</comment>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getsockopt not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ii|i:getsockopt"</expr></argument>,
			      <argument><expr>&amp;<name>level</name></expr></argument>, <argument><expr>&amp;<name>optname</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>buflen</name> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>socklen_t</name></type> <name>flagsize</name> <init>= <expr>sizeof <name>flag</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>res</name> = <call><name>getsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>,
				 <argument><expr>(<name>void</name> *)&amp;<name>flag</name></expr></argument>, <argument><expr>&amp;<name>flagsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
			<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
		<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
	<comment type="block">/* socklen_t is unsigned so no negative test is needed,
	   test buflen == 0 is previously done */</comment>
	<if>if <condition>(<expr><name>buflen</name> &gt; 1024</expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><name>buflen</name> &lt;= 0 || <name>buflen</name> &gt; 1024</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
				<argument><expr>"getsockopt buflen out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>buf</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>getsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>,
			 <argument><expr>(<name>void</name> *)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __BEOS__ */</comment>
}</block></then></if>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getsockopt_doc</name></expr></argument>,
<argument><expr>"getsockopt(level, option[, buffersize]) -&gt; value\n\
\n\
Get a socket option.  See the Unix manual for level and option.\n\
If a nonzero buffersize argument is given, the return value is a\n\
string of that length; otherwise it is an integer."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.bind(sockaddr) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_bind</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>addro</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>addrlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>getsockaddrarg</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addro</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>bind</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bind_doc</name></expr></argument>,
<argument><expr>"bind(address)\n\
\n\
Bind the socket to a local address.  For IP sockets, the address is a\n\
pair (host, port); the host must refer to the local host. For raw packet\n\
sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.close() method.
   Set the file descriptor to -1 so operations tried subsequently
   will surely fail. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_close</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>(<name>fd</name> = <name><name>s</name>-&gt;<name>sock_fd</name></name>) != -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>s</name>-&gt;<name>sock_fd</name></name> = -1</expr>;</expr_stmt>
		<macro><name>Py_BEGIN_ALLOW_THREADS</name>
		<argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>close_doc</name></expr></argument>,
<argument><expr>"close()\n\
\n\
Close the socket.  It cannot be used after this call."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_connect</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type>struct <name>sockaddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>addrlen</name></decl></param>,
		 <param><decl><type><name>int</name> *</type><name>timeoutp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>timeout</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>timeout</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> = <call><name>connect</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>

	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &gt; 0.0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>res</name> &lt; 0 &amp;&amp; <call><name>WSAGetLastError</name><argument_list>()</argument_list></call> == <name>WSAEWOULDBLOCK</name> &amp;&amp;
		    <call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* This is a mess.  Best solution: trust select */</comment>
			<decl_stmt><decl><type><name>fd_set</name></type> <name>fds</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fd_set</name></type> <name>fds_exc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>tv</name>.<name>tv_sec</name></name> = (<name>int</name>)<name><name>s</name>-&gt;<name>sock_timeout</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tv</name>.<name>tv_usec</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr>(<name><name>s</name>-&gt;<name>sock_timeout</name></name> - <name><name>tv</name>.<name>tv_sec</name></name>) * 1e6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr>&amp;<name>fds_exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds_exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> = <call><name>select</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name>+1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>, <argument><expr>&amp;<name>fds_exc</name></expr></argument>, <argument><expr>&amp;<name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>res</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>res</name> = <name>WSAEWOULDBLOCK</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>timeout</name> = 1</expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><name>res</name> &gt; 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
					<comment type="block">/* The socket is in the writeable set - this
					   means connected */</comment>
					<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt></then>
				<else>else <block>{
					<comment type="block">/* As per MS docs, we need to call getsockopt()
					   to get the underlying error */</comment>
					<decl_stmt><decl><type><name>int</name></type> <name>res_size</name> <init>= <expr>sizeof <name>res</name></expr></init></decl>;</decl_stmt>
					<comment type="block">/* It must be in the exception set */</comment>
					<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr>&amp;<name>fds_exc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr>0 == <call><name>getsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_ERROR</name></expr></argument>,
					                    <argument><expr>(<name>char</name> *)&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>res_size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<comment type="block">/* getsockopt also clears WSAGetLastError,
						   so reset it back. */</comment>
						<expr_stmt><expr><call><name>WSASetLastError</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
					<else>else
						<expr_stmt><expr><name>res</name> = <call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
				}</block></else></if>
			}</block></then></if></else></if>
			<comment type="block">/* else if (res &lt; 0) an error occurred */</comment>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_timeout</name></name> &gt; 0.0</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>res</name> &lt; 0 &amp;&amp; <name>errno</name> == <name>EINPROGRESS</name> &amp;&amp; <call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>timeout</name> = <call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>timeout</name> == 0</expr>)</condition><then> <block>{
                                <comment type="block">/* Bug #1019808: in case of an EINPROGRESS, 
                                   use getsockopt(SO_ERROR) to get the real 
                                   error. */</comment>
                                <decl_stmt><decl><type><name>socklen_t</name></type> <name>res_size</name> <init>= <expr>sizeof <name>res</name></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr>(<name>void</name>)<call><name>getsockopt</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, 
                                                 <argument><expr><name>SO_ERROR</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>res_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if>if <condition>(<expr><name>res</name> == <name>EISCONN</name></expr>)</condition><then>
                                        <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt></then></if>
                                <expr_stmt><expr><name>errno</name> = <name>res</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <if>if <condition>(<expr><name>timeout</name> == -1</expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>res</name> = <name>errno</name></expr>;</expr_stmt>            <comment type="block">/* had error */</comment>
                        }</block></then>
			<else>else
				<expr_stmt><expr><name>res</name> = <name>EWOULDBLOCK</name></expr>;</expr_stmt></else></if></else></if>	<comment type="block">/* timed out */</comment>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<expr_stmt><expr><name>res</name> = <name>errno</name></expr>;</expr_stmt></then></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr>*<name>timeoutp</name> = <name>timeout</name></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/* s.connect(sockaddr) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_connect</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>addro</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>addrlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>getsockaddrarg</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addro</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>internal_connect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>, <argument><expr>&amp;<name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>connect_doc</name></expr></argument>,
<argument><expr>"connect(address)\n\
\n\
Connect the socket to a remote address.  For IP sockets, the address\n\
is a pair (host, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.connect_ex(sockaddr) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_connect_ex</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>addro</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>addrlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>getsockaddrarg</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addro</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>internal_connect</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>, <argument><expr>&amp;<name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<comment type="block">/* Signals are not errors (though they may raise exceptions).  Adapted
	   from PyErr_SetFromErrnoWithFilenameObject(). */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EINTR</name></cpp:ifdef>
	<if>if <condition>(<expr><name>res</name> == <name>EINTR</name> &amp;&amp; <call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>connect_ex_doc</name></expr></argument>,
<argument><expr>"connect_ex(address) -&gt; errno\n\
\n\
This is like connect(address), but returns an error code (the errno value)\n\
instead of raising an exception when an error occurs."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.fileno() method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_fileno</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SOCKET_T</name> &lt;= <name>SIZEOF_LONG</name></expr></cpp:if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr>(<name>PY_LONG_LONG</name>)<name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fileno_doc</name></expr></argument>,
<argument><expr>"fileno() -&gt; integer\n\
\n\
Return the integer file descriptor of the socket."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUP</name></cpp:ifndef>
<comment type="block">/* s.dup() method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_dup</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>newfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sock</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newfd</name> = <call><name>dup</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>newfd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>sock</name> = (<name>PyObject</name> *) <call><name>new_sockobject</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>,
					   <argument><expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr></argument>,
					   <argument><expr><name><name>s</name>-&gt;<name>sock_type</name></name></expr></argument>,
					   <argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sock</name> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>sock</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>dup_doc</name></expr></argument>,
<argument><expr>"dup() -&gt; socket object\n\
\n\
Return a new socket object connected to the same system resource."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* s.getsockname() method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_getsockname</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>getsockaddrlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>getsockname</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>makesockaddr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>,
			    <argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getsockname_doc</name></expr></argument>,
<argument><expr>"getsockname() -&gt; address info\n\
\n\
Return the address of the local endpoint.  For IP sockets, the address\n\
info is a pair (hostaddr, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPEERNAME</name></cpp:ifdef>		<comment type="block">/* Cray APP doesn't have this :-( */</comment>
<comment type="block">/* s.getpeername() method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_getpeername</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>getsockaddrlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>getpeername</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>makesockaddr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>,
			    <argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getpeername_doc</name></expr></argument>,
<argument><expr>"getpeername() -&gt; address info\n\
\n\
Return the address of the remote endpoint.  For IP sockets, the address\n\
info is a pair (hostaddr, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETPEERNAME */</comment>


<comment type="block">/* s.listen(n) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_listen</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>backlog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>backlog</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>backlog</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>backlog</name> &lt; 1</expr>)</condition><then>
		<expr_stmt><expr><name>backlog</name> = 1</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>listen</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>backlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>listen_doc</name></expr></argument>,
<argument><expr>"listen(backlog)\n\
\n\
Enable a server to accept connections.  The backlog argument must be at\n\
least 1; it specifies the number of unaccepted connection that the system\n\
will allow before refusing new connections."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUP</name></cpp:ifndef>
<comment type="block">/* s.makefile(mode) method.
   Create a new open file object referring to a dupped version of
   the socket's file descriptor.  (The dup() call is necessary so
   that the open file and socket objects may be closed independent
   of each other.)
   The mode argument specifies 'r' or 'w' passed to fdopen(). */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_makefile</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>fclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Py_intptr_t</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>f</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode_r</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>mode_w</name> <init>= <expr>"w"</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|si:makefile"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>,<argument><expr>"rb"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>mode</name> = <name>mode_r</name></expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>,<argument><expr>"wb"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>mode</name> = <name>mode_w</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>
	<if>if <condition>(<expr>((<name>fd</name> = <call><name>_open_osfhandle</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call>) &lt; 0) ||
	    ((<name>fd</name> = <call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call>) &lt; 0) || ((<name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name>)</expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr>(<name>fd</name> = <call><name>dup</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call>) &lt; 0 || (<name>fp</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{
		<if>if <condition>(<expr><name>fd</name> &gt;= 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if></then></if>
	<expr_stmt><expr><name>f</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"&lt;socket&gt;"</expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>f</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>makefile_doc</name></expr></argument>,
<argument><expr>"makefile([mode[, buffersize]]) -&gt; file object\n\
\n\
Return a regular file object corresponding to the socket.\n\
The mode and buffersize arguments are as for the built-in open() function."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_DUP */</comment>

<comment type="block">/*
 * This is the guts of the recv() and recv_into() methods, which reads into a
 * char buffer.  If you have any inc/dec ref to do to the objects that contain
 * the buffer, do it in the caller.  This function returns the number of bytes
 * succesfully read.  If there was an error, it returns -1.  Note that it is
 * also possible that we return a number of bytes smaller than the request
 * bytes.
 */</comment>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>sock_recv_guts</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>cbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>outlen</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>remaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>read_buf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__VMS</name></cpp:ifndef>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
		<expr_stmt><expr><name>outlen</name> = <call><name>recv</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>outlen</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* Note: the call to errorhandler() ALWAYS indirectly returned
		   NULL, so ignore its return value */</comment>
		<expr_stmt><expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>read_buf</name> = <name>cbuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>remaining</name> = <name>len</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>remaining</name> != 0</expr>)</condition> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>segment</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nread</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>segment</name> = <name>remaining</name> /<name>SEGMENT_SIZE</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>segment</name> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>segment</name> = <name>SEGMENT_SIZE</name></expr>;</expr_stmt>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name>segment</name> = <name>remaining</name></expr>;</expr_stmt>
		}</block></else></if>

		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
			<expr_stmt><expr><name>nread</name> = <call><name>recv</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>read_buf</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>

		<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>nread</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>-1</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name>nread</name> != <name>remaining</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>read_buf</name> += <name>nread</name></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>

		<expr_stmt><expr><name>remaining</name> -= <name>segment</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>read_buf</name> += <name>segment</name></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>outlen</name> = <name>read_buf</name> - <name>cbuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !__VMS */</comment>

	<return>return <expr><name>outlen</name></expr>;</return>
}</block></function>


<comment type="block">/* s.recv(nbytes [,flags]) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_recv</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>recvlen</name></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>outlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>buf</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|i:recv"</expr></argument>, <argument><expr>&amp;<name>recvlen</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>recvlen</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"negative buffersize in recv"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Allocate a new string. */</comment>
	<expr_stmt><expr><name>buf</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *) 0</expr></argument>, <argument><expr><name>recvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="block">/* Call the guts */</comment>
	<expr_stmt><expr><name>outlen</name> = <call><name>sock_recv_guts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recvlen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>outlen</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* An error occurred, release the string and return an
		   error. */</comment>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>outlen</name> != <name>recvlen</name></expr>)</condition><then> <block>{
		<comment type="block">/* We did not read as many bytes as we anticipated, resize the
		   string if possible and be succesful. */</comment>
		<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>outlen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<comment type="block">/* Oopsy, not so succesful after all. */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>

	<return>return <expr><name>buf</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>recv_doc</name></expr></argument>,
<argument><expr>"recv(buffersize[, flags]) -&gt; data\n\
\n\
Receive up to buffersize bytes from the socket.  For the optional flags\n\
argument, see the Unix manual.  When no data is available, block until\n\
at least one byte is available or until the remote end is closed.  When\n\
the remote end is closed and all data is read, return the empty string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.recv_into(buffer, [nbytes [,flags]]) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>sock_recv_into</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"buffer"</expr>, <expr>"nbytes"</expr>, <expr>"flags"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>recvlen</name> <init>= <expr>0</expr></init>, <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>readlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>

	<comment type="block">/* Get the buffer's memory */</comment>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"w#|ii:recv_into"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
					 <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>, <argument><expr>&amp;<name>recvlen</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> != 0 &amp;&amp; <name>buflen</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>recvlen</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"negative buffersize in recv_into"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>recvlen</name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* If nbytes was not specified, use the buffer's length */</comment>
            <expr_stmt><expr><name>recvlen</name> = <name>buflen</name></expr>;</expr_stmt>
	}</block></then></if>

	<comment type="block">/* Check if the buffer is large enough */</comment>
	<if>if <condition>(<expr><name>buflen</name> &lt; <name>recvlen</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"buffer too small for requested bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Call the guts */</comment>
	<expr_stmt><expr><name>readlen</name> = <call><name>sock_recv_guts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>recvlen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>readlen</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* Return an error. */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Return the number of bytes read.  Note that we do not do anything
	   special here in the case that readlen &lt; recvlen. */</comment>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>readlen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>recv_into_doc</name></expr></argument>,
<argument><expr>"recv_into(buffer, [nbytes[, flags]]) -&gt; nbytes_read\n\
\n\
A version of recv() that stores its data into a buffer rather than creating \n\
a new string.  Receive up to buffersize bytes from the socket.  If buffersize \n\
is not specified (or 0), receive up to the size available in the given buffer.\n\
\n\
See recv() for documentation about the flags."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * This is the guts of the recvfrom() and recvfrom_into() methods, which reads
 * into a char buffer.  If you have any inc/def ref to do to the objects that
 * contain the buffer, do it in the caller.  This function returns the number
 * of bytes succesfully read.  If there was an error, it returns -1.  Note
 * that it is also possible that we return a number of bytes smaller than the
 * request bytes.
 *
 * 'addr' is a return value for the address object.  Note that you must decref
 * it yourself.
 */</comment>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>sock_recvfrom_guts</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>cbuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
		   <param><decl><type><name>PyObject</name>**</type> <name>addr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>n</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl>;</decl_stmt>

	<expr_stmt><expr>*<name>addr</name> = <name>NULL</name></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>getsockaddrlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>memset</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<expr_stmt><expr><name>timeout</name> = <call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then> <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><name>n</name> = <call><name>recvfrom</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
			     <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>n</name> = <call><name>recvfrom</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
			     <argument><expr>(<name>void</name> *) &amp;<name>addrbuf</name></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>n</name> = <call><name>recvfrom</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
			     <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then></if>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

	<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!(*<name>addr</name> = <call><name>makesockaddr</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>addrlen</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="block">/* s.recvfrom(nbytes [,flags]) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_recvfrom</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>recvlen</name></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>outlen</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i|i:recvfrom"</expr></argument>, <argument><expr>&amp;<name>recvlen</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>recvlen</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"negative buffersize in recvfrom"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>buf</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *) 0</expr></argument>, <argument><expr><name>recvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><name>outlen</name> = <call><name>sock_recvfrom_guts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
				    <argument><expr><name>recvlen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>outlen</name> &lt; 0</expr>)</condition><then> <block>{
		<goto>goto <name>finally</name>;</goto>
	}</block></then></if>

	<if>if <condition>(<expr><name>outlen</name> != <name>recvlen</name></expr>)</condition><then> <block>{
		<comment type="block">/* We did not read as many bytes as we anticipated, resize the
		   string if possible and be succesful. */</comment>
		<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>outlen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<comment type="block">/* Oopsy, not so succesful after all. */</comment>
			<goto>goto <name>finally</name>;</goto></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>ret</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>finally</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>recvfrom_doc</name></expr></argument>,
<argument><expr>"recvfrom(buffersize[, flags]) -&gt; (data, address info)\n\
\n\
Like recv(buffersize, flags) but also return the sender's address info."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.recvfrom_into(buffer[, nbytes [,flags]]) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_recvfrom_into</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"buffer"</expr>, <expr>"nbytes"</expr>, <expr>"flags"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>recvlen</name> <init>= <expr>0</expr></init>, <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ssize_t</name></type> <name>readlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"w#|ii:recvfrom_into"</expr></argument>,
					 <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>,
					 <argument><expr>&amp;<name>recvlen</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> != 0 &amp;&amp; <name>buflen</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>recvlen</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"negative buffersize in recvfrom_into"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>recvlen</name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* If nbytes was not specified, use the buffer's length */</comment>
            <expr_stmt><expr><name>recvlen</name> = <name>buflen</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>readlen</name> = <call><name>sock_recvfrom_guts</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>recvlen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>readlen</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="block">/* Return an error */</comment>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Return the number of bytes read and the address.  Note that we do
	   not do anything special here in the case that readlen &lt; recvlen. */</comment>
 	<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"lN"</expr></argument>, <argument><expr><name>readlen</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>recvfrom_into_doc</name></expr></argument>,
<argument><expr>"recvfrom_into(buffer[, nbytes[, flags]]) -&gt; (nbytes, address info)\n\
\n\
Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.send(data [,flags]) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_send</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>-1</expr></init>, <name>flags</name> <init>= <expr>0</expr></init>, <name>timeout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|i:send"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>buf</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
		<expr_stmt><expr><name>n</name> = <call><name>sendsegmented</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>n</name> = <call><name>send</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>

	<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>send_doc</name></expr></argument>,
<argument><expr>"send(data[, flags]) -&gt; count\n\
\n\
Send a data string to the socket.  For the optional flags\n\
argument, see the Unix manual.  Return the number of bytes\n\
sent; this may be less than len(data) if the network is busy."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.sendall(data [,flags]) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_sendall</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>-1</expr></init>, <name>flags</name> <init>= <expr>0</expr></init>, <name>timeout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*|i:sendall"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>buf</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>

	<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
	<do>do <block>{
		<expr_stmt><expr><name>timeout</name> = <call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = -1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>timeout</name></expr>)</condition><then>
			<break>break;</break></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
		<expr_stmt><expr><name>n</name> = <call><name>sendsegmented</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>n</name> = <call><name>send</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
			<break>break;</break></then></if>
		<expr_stmt><expr><name>buf</name> += <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> -= <name>n</name></expr>;</expr_stmt>
	}</block> while <condition>(<expr><name>len</name> &gt; 0</expr>)</condition>;</do>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sendall_doc</name></expr></argument>,
<argument><expr>"sendall(data[, flags])\n\
\n\
Send a data string to the socket.  For the optional flags\n\
argument, see the Unix manual.  This calls send() repeatedly\n\
until all data is sent.  If an error occurs, it's impossible\n\
to tell how much data has been sent."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.sendto(data, [flags,] sockaddr) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_sendto</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>addro</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>addrlen</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>-1</expr></init>, <name>flags</name></decl>, <decl><type ref="prev"/><name>timeout</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>flags</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*O:sendto"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>addro</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*iO:sendto"</expr></argument>,
				      <argument><expr>&amp;<name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>, <argument><expr>&amp;<name>addro</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>buf</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>IS_SELECTABLE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>select_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr>!<call><name>getsockaddrarg</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>addro</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>timeout</name> <init>= <expr><call><name>internal_select</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>timeout</name></expr>)</condition><then>
		<expr_stmt><expr><name>n</name> = <call><name>sendto</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>

	<name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>timeout</name> == 1</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>, <argument><expr>"timed out"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sendto_doc</name></expr></argument>,
<argument><expr>"sendto(data[, flags], address) -&gt; count\n\
\n\
Like send(data, flags) but allows specifying the destination address.\n\
For IP sockets, the address is a pair (hostaddr, port)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* s.shutdown(how) method */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_shutdown</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>how</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>how</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>how</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name><name>s</name>-&gt;<name>errorhandler</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>shutdown_doc</name></expr></argument>,
<argument><expr>"shutdown(flag)\n\
\n\
Shut down the reading side of the socket (flag == SHUT_RD), the writing side\n\
of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SIO_RCVALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>sock_ioctl</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>cmd</name> <init>= <expr><name>SIO_RCVALL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>option</name> <init>= <expr><name>RCVALL_ON</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DWORD</name></type> <name>recv</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"kI:ioctl"</expr></argument>, <argument><expr>&amp;<name>cmd</name></expr></argument>, <argument><expr>&amp;<name>option</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>WSAIoctl</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr>&amp;<name>option</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
		     <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>recv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> == <name>SOCKET_ERROR</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sock_ioctl_doc</name></expr></argument>,
<argument><expr>"ioctl(cmd, option) -&gt; long\n\
\n\
Control the socket with WSAIoctl syscall. Currently only socket.SIO_RCVALL\n\
is supported as control. Options must be one of the socket.RCVALL_*\n\
constants."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* List of methods for socket objects */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>sock_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"accept"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_accept</name></expr>, <expr><name>METH_NOARGS</name></expr>,
			  <expr><name>accept_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"bind"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_bind</name></expr>, <expr><name>METH_O</name></expr>,
			  <expr><name>bind_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"close"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_close</name></expr>, <expr><name>METH_NOARGS</name></expr>,
			  <expr><name>close_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"connect"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_connect</name></expr>, <expr><name>METH_O</name></expr>,
			  <expr><name>connect_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"connect_ex"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_connect_ex</name></expr>, <expr><name>METH_O</name></expr>,
			  <expr><name>connect_ex_doc</name></expr>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUP</name></cpp:ifndef>
	<expr><block>{<expr>"dup"</expr>,		  <expr>(<name>PyCFunction</name>)<name>sock_dup</name></expr>, <expr><name>METH_NOARGS</name></expr>,
			  <expr><name>dup_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"fileno"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>,
			  <expr><name>fileno_doc</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPEERNAME</name></cpp:ifdef>
	<expr><block>{<expr>"getpeername"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_getpeername</name></expr>,
			  <expr><name>METH_NOARGS</name></expr>, <expr><name>getpeername_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"getsockname"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_getsockname</name></expr>,
			  <expr><name>METH_NOARGS</name></expr>, <expr><name>getsockname_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getsockopt"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_getsockopt</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>getsockopt_doc</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SIO_RCVALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr><block>{<expr>"ioctl"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_ioctl</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>sock_ioctl_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"listen"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_listen</name></expr>, <expr><name>METH_O</name></expr>,
			  <expr><name>listen_doc</name></expr>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUP</name></cpp:ifndef>
	<expr><block>{<expr>"makefile"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_makefile</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>makefile_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"recv"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_recv</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>recv_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"recv_into"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_recv_into</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
			  <expr><name>recv_into_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"recvfrom"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_recvfrom</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>recvfrom_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"recvfrom_into"</expr>,  <expr>(<name>PyCFunction</name>)<name>sock_recvfrom_into</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>,
			  <expr><name>recvfrom_into_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"send"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_send</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>send_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"sendall"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_sendall</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>sendall_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"sendto"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_sendto</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>sendto_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"setblocking"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_setblocking</name></expr>, <expr><name>METH_O</name></expr>,
			  <expr><name>setblocking_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"settimeout"</expr>,    <expr>(<name>PyCFunction</name>)<name>sock_settimeout</name></expr>, <expr><name>METH_O</name></expr>,
			  <expr><name>settimeout_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"gettimeout"</expr>,    <expr>(<name>PyCFunction</name>)<name>sock_gettimeout</name></expr>, <expr><name>METH_NOARGS</name></expr>,
			  <expr><name>gettimeout_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"setsockopt"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_setsockopt</name></expr>, <expr><name>METH_VARARGS</name></expr>,
			  <expr><name>setsockopt_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"shutdown"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_shutdown</name></expr>, <expr><name>METH_O</name></expr>,
			  <expr><name>shutdown_doc</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
	<expr><block>{<expr>"sleeptaskw"</expr>,	  <expr>(<name>PyCFunction</name>)<name>sock_sleeptaskw</name></expr>, <expr><name>METH_O</name></expr>,
	 		  <expr><name>sleeptaskw_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>,			<expr><name>NULL</name></expr>}</block></expr>		<comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* SockObject members */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>sock_memberlist</name><index>[]</index></name> <init>= <expr><block>{
       <expr><block>{<expr>"family"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>, <argument><expr><name>sock_family</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <expr>"the socket family"</expr>}</block></expr>,
       <expr><block>{<expr>"type"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>, <argument><expr><name>sock_type</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <expr>"the socket type"</expr>}</block></expr>,
       <expr><block>{<expr>"proto"</expr>, <expr><name>T_INT</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>, <argument><expr><name>sock_proto</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <expr>"the socket protocol"</expr>}</block></expr>,
       <expr><block>{<expr>"timeout"</expr>, <expr><name>T_DOUBLE</name></expr>, <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>, <argument><expr><name>sock_timeout</name></expr></argument>)</argument_list></call></expr>, <expr><name>READONLY</name></expr>, <expr>"the socket timeout"</expr>}</block></expr>,
       <expr><block>{<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Deallocate a socket object in response to the last Py_DECREF().
   First close the file description. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sock_dealloc</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_fd</name></name> != -1</expr>)</condition><then>
		<expr_stmt><expr>(<name>void</name>) <call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_repr</name><parameter_list>(<param><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SOCKET_T</name> &gt; <name>SIZEOF_LONG</name></expr></cpp:if>
	<if>if <condition>(<expr><name><name>s</name>-&gt;<name>sock_fd</name></name> &gt; <name>LONG_MAX</name></expr>)</condition><then> <block>{
		<comment type="block">/* this can occur on Win64, and actually there is a special
		   ugly printf formatter for decimal pointer length integer
		   printing, only bother if necessary*/</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
				<argument><expr>"no printf formatter to display "
				"the socket descriptor in decimal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(
		<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		<argument><expr>"&lt;socket object, fd=%ld, family=%d, type=%d, protocol=%d&gt;"</expr></argument>,
		<argument><expr>(<name>long</name>)<name><name>s</name>-&gt;<name>sock_fd</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>sock_family</name></name></expr></argument>,
		<argument><expr><name><name>s</name>-&gt;<name>sock_type</name></name></expr></argument>,
		<argument><expr><name><name>s</name>-&gt;<name>sock_proto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Create a new, uninitialized socket object. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>sock_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>new</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>new</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>((<name>PySocketSockObject</name> *)<name>new</name>)-&gt;<name>sock_fd</name> = -1</expr>;</expr_stmt>
		<expr_stmt><expr>((<name>PySocketSockObject</name> *)<name>new</name>)-&gt;<name>sock_timeout</name> = -1.0</expr>;</expr_stmt>
		<expr_stmt><expr>((<name>PySocketSockObject</name> *)<name>new</name>)-&gt;<name>errorhandler</name> = &amp;<name>set_error</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>new</name></expr>;</return>
}</block></function>


<comment type="block">/* Initialize a new socket object. */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>sock_initobj</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>s</name> <init>= <expr>(<name>PySocketSockObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>family</name> <init>= <expr><name>AF_INET</name></expr></init>, <name>type</name> <init>= <expr><name>SOCK_STREAM</name></expr></init>, <name>proto</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"family"</expr>, <expr>"type"</expr>, <expr>"proto"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>,
					 <argument><expr>"|iii:socket"</expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
					 <argument><expr>&amp;<name>family</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>-1</expr>;</return></then></if>

	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>fd</name> <init>= <expr><call><name>socket</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
	<if>if <condition>(<expr><name>fd</name> == <name>INVALID_SOCKET</name></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{
		<expr_stmt><expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if></then></if>
	<expr_stmt><expr><call><name>init_sockobject</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>

}</block></function>


<comment type="block">/* Type object for socket objects. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>sock_type</name> <init>= <expr><block>{
	<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>	<comment type="block">/* Must fill in type value later */</comment>
	"_socket.socket"</expr>,			<comment type="block">/* tp_name */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PySocketSockObject</name></expr></argument>)</argument_list></sizeof></expr>,		<comment type="block">/* tp_basicsize */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_itemsize */</comment>
	<expr>(<name>destructor</name>)<name>sock_dealloc</name></expr>,		<comment type="block">/* tp_dealloc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_print */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_compare */</comment>
	<expr>(<name>reprfunc</name>)<name>sock_repr</name></expr>,			<comment type="block">/* tp_repr */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_number */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_sequence */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_mapping */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_hash */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_call */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_str */</comment>
	<expr><name>PyObject_GenericGetAttr</name></expr>,		<comment type="block">/* tp_getattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_setattro */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_as_buffer */</comment>
	<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>, <comment type="block">/* tp_flags */</comment>
	<expr><name>sock_doc</name></expr>,				<comment type="block">/* tp_doc */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_traverse */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_clear */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_richcompare */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_weaklistoffset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iter */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_iternext */</comment>
	<expr><name>sock_methods</name></expr>,				<comment type="block">/* tp_methods */</comment>
	<expr><name>sock_memberlist</name></expr>,			<comment type="block">/* tp_members */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_getset */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_base */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dict */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_get */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_descr_set */</comment>
	<expr>0</expr>,					<comment type="block">/* tp_dictoffset */</comment>
	<expr><name>sock_initobj</name></expr>,				<comment type="block">/* tp_init */</comment>
	<expr><name>PyType_GenericAlloc</name></expr>,			<comment type="block">/* tp_alloc */</comment>
	<expr><name>sock_new</name></expr>,				<comment type="block">/* tp_new */</comment>
	<expr><name>PyObject_Del</name></expr>,				<comment type="block">/* tp_free */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Python interface to gethostname(). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_gethostname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>res</name> <init>= <expr><call><name>gethostname</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>int</name>) sizeof <name>buf</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name><name>buf</name><index>[<expr/></index></name>sizeof <name>buf</name> - 1] = '\0'</expr>;</expr_stmt>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gethostname_doc</name></expr></argument>,
<argument><expr>"gethostname() -&gt; string\n\
\n\
Return the current host name."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* Python interface to gethostbyname(name). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_gethostbyname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sock_addr_t</name></type> <name>addrbuf</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:gethostbyname"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>setipaddr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>,  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>makeipaddr</name><argument_list>(<argument><expr><call><name>SAS2SA</name><argument_list>(<argument><expr>&amp;<name>addrbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gethostbyname_doc</name></expr></argument>,
<argument><expr>"gethostbyname(host) -&gt; address\n\
\n\
Return the IP address (a string of the form '255.255.255.255') for a host."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* Convenience function common to gethostbyname_ex and gethostbyaddr */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>gethost_common</name><parameter_list>(<param><decl><type>struct <name>hostent</name> *</type><name>h</name></decl></param>, <param><decl><type>struct <name>sockaddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>alen</name></decl></param>, <param><decl><type><name>int</name></type> <name>af</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> **</type><name>pch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>rtn_tuple</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>name_list</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr_list</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>h</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* Let's get real error message to return */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RISCOS</name></cpp:ifndef>
		<expr_stmt><expr><call><name>set_herror</name><argument_list>(<argument><expr><name>h_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"host not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>h</name>-&gt;<name>h_addrtype</name></name> != <name>af</name></expr>)</condition><then> <block>{
		<comment type="block">/* Let's get real error message to return */</comment>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
				<argument><expr>(<name>char</name> *)<call><name>strerror</name><argument_list>(<argument><expr><name>EAFNOSUPPORT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<switch>switch <condition>(<expr><name>af</name></expr>)</condition> <block>{

	<case>case <expr><name>AF_INET</name></expr>:
		<if>if <condition>(<expr><name>alen</name> &lt; <sizeof>sizeof<argument_list>(<argument>struct <expr><name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	</case><case>case <expr><name>AF_INET6</name></expr>:
		<if>if <condition>(<expr><name>alen</name> &lt; <sizeof>sizeof<argument_list>(<argument>struct <expr><name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</case>}</block></switch>

	<if>if <condition>(<expr>(<name>name_list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>

	<if>if <condition>(<expr>(<name>addr_list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>

	<comment type="block">/* SF #1511317: h_aliases can be NULL */</comment>
	<if>if <condition>(<expr><name><name>h</name>-&gt;<name>h_aliases</name></name></expr>)</condition><then> <block>{
		<for>for (<init><expr><name>pch</name> = <name><name>h</name>-&gt;<name>h_aliases</name></name></expr>;</init> <condition><expr>*<name>pch</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>pch</name>++</expr></incr>) <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>tmp</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>*<name>pch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>

			<expr_stmt><expr><name>status</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>status</name></expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
		}</block></for>
	}</block></then></if>

	<for>for (<init><expr><name>pch</name> = <name><name>h</name>-&gt;<name>h_addr_list</name></name></expr>;</init> <condition><expr>*<name>pch</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>pch</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>af</name></expr>)</condition> <block>{

		<case>case <expr><name>AF_INET</name></expr>:
		    <block>{
			<decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>sin</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sin</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sin</name>.<name>sin_family</name></name> = <name>af</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SOCKADDR_SA_LEN</name></cpp:ifdef>
			<expr_stmt><expr><name><name>sin</name>.<name>sin_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sin</name>.<name>sin_addr</name></name></expr></argument>, <argument><expr>*<name>pch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sin</name>.<name>sin_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp</name> = <call><name>makeipaddr</name><argument_list>(<argument><expr>(struct <name>sockaddr</name> *)&amp;<name>sin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>pch</name> == <name><name>h</name>-&gt;<name>h_addr_list</name></name> &amp;&amp; <name>alen</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *) <name>addr</name></expr></argument>, <argument><expr>&amp;<name>sin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<break>break;</break>
		    }</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
		</case><case>case <expr><name>AF_INET6</name></expr>:
		    <block>{
			<decl_stmt><decl><type>struct <name>sockaddr_in6</name></type> <name>sin6</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sin6</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sin6</name>.<name>sin6_family</name></name> = <name>af</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SOCKADDR_SA_LEN</name></cpp:ifdef>
			<expr_stmt><expr><name><name>sin6</name>.<name>sin6_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sin6</name>.<name>sin6_addr</name></name></expr></argument>, <argument><expr>*<name>pch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sin6</name>.<name>sin6_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp</name> = <call><name>makeipaddr</name><argument_list>(<argument><expr>(struct <name>sockaddr</name> *)&amp;<name>sin6</name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>pch</name> == <name><name>h</name>-&gt;<name>h_addr_list</name></name> &amp;&amp; <name>alen</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *) <name>addr</name></expr></argument>, <argument><expr>&amp;<name>sin6</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<break>break;</break>
		    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		</case><default>default:	<comment type="block">/* can't happen */</comment>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
					<argument><expr>"unsupported address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</default>}</block></switch>

		<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>

		<expr_stmt><expr><name>status</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>addr_list</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>status</name></expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
	}</block></for>

	<expr_stmt><expr><name>rtn_tuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"sOO"</expr></argument>, <argument><expr><name><name>h</name>-&gt;<name>h_name</name></name></expr></argument>, <argument><expr><name>name_list</name></expr></argument>, <argument><expr><name>addr_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <label><name>err</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>addr_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rtn_tuple</name></expr>;</return>
}</block></function>


<comment type="block">/* Python interface to gethostbyname_ex(name). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_gethostbyname_ex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>hostent</name> *</type><name>h</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
        <decl_stmt><decl><type>struct <name>sockaddr_storage</name></type> <name>addr</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>addr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type>struct <name>sockaddr</name> *</type><name>sa</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>hostent</name></type> <name>hp_allocated</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R_3_ARG</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>hostent_data</name></type> <name>data</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>16384</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buf_len</name> <init>= <expr>(sizeof <name>buf</name>) - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>errnop</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_3_ARG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_6_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETHOSTBYNAME_R */</comment>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:gethostbyname_ex"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>setipaddr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive>   <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_6_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<name>result</name> <init>= <expr><call><name>gethostbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>,
				 <argument><expr>&amp;<name>h</name></expr></argument>, <argument><expr>&amp;<name>errnop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_5_ARG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>h</name> = <call><name>gethostbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr>&amp;<name>errnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* HAVE_GETHOSTBYNAME_R_3_ARG */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name>data</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>gethostbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>h</name> = (<name>result</name> != 0) ? <name>NULL</name> : &amp;<name>hp_allocated</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* not HAVE_GETHOSTBYNAME_R */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_GETHOSTBYNAME_LOCK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>netdb_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>h</name> = <call><name>gethostbyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETHOSTBYNAME_R */</comment>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<comment type="block">/* Some C libraries would require addr.__ss_family instead of
	   addr.ss_family.
	   Therefore, we cast the sockaddr_storage into sockaddr to
	   access sa_family. */</comment>
	<name>sa</name> <init>= <expr>(struct <name>sockaddr</name>*)&amp;<name>addr</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>ret</name> = <call><name>gethost_common</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			     <argument><expr><name><name>sa</name>-&gt;<name>sa_family</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_GETHOSTBYNAME_LOCK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>netdb_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ghbn_ex_doc</name></expr></argument>,
<argument><expr>"gethostbyname_ex(host) -&gt; (name, aliaslist, addresslist)\n\
\n\
Return the true host name, a list of aliases, and a list of IP addresses,\n\
for a host.  The host argument is a string giving a host name or IP number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* Python interface to gethostbyaddr(IP). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_gethostbyaddr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>sockaddr_storage</name></type> <name>addr</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>addr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type>struct <name>sockaddr</name> *</type><name>sa</name> <init>= <expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>ip_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>hostent</name> *</type><name>h</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>hostent</name></type> <name>hp_allocated</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R_3_ARG</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>hostent_data</name></type> <name>data</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>16384</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buf_len</name> <init>= <expr>(sizeof <name>buf</name>) - 1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>errnop</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_3_ARG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_6_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETHOSTBYNAME_R */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>al</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>af</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:gethostbyaddr"</expr></argument>, <argument><expr>&amp;<name>ip_num</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>af</name> = <name>AF_UNSPEC</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>setipaddr</name><argument_list>(<argument><expr><name>ip_num</name></expr></argument>, <argument><expr><name>sa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>af</name> = <name><name>sa</name>-&gt;<name>sa_family</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ap</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>al</name> = 0</expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>af</name></expr>)</condition> <block>{
	<case>case <expr><name>AF_INET</name></expr>:
		<expr_stmt><expr><name>ap</name> = (<name>char</name> *)&amp;((struct <name>sockaddr_in</name> *)<name>sa</name>)-&gt;<name>sin_addr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>al</name> = <sizeof>sizeof<argument_list>(<argument><expr>((struct <name>sockaddr_in</name> *)<name>sa</name>)-&gt;<name>sin_addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	</case><case>case <expr><name>AF_INET6</name></expr>:
		<expr_stmt><expr><name>ap</name> = (<name>char</name> *)&amp;((struct <name>sockaddr_in6</name> *)<name>sa</name>)-&gt;<name>sin6_addr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>al</name> = <sizeof>sizeof<argument_list>(<argument><expr>((struct <name>sockaddr_in6</name> *)<name>sa</name>)-&gt;<name>sin6_addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case><default>default:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"unsupported address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</default>}</block></switch>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETHOSTBYNAME_R</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive>   <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_6_ARG</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<name>result</name> <init>= <expr><call><name>gethostbyaddr_r</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>af</name></expr></argument>,
		<argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>,
		<argument><expr>&amp;<name>h</name></expr></argument>, <argument><expr>&amp;<name>errnop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETHOSTBYNAME_R_5_ARG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>h</name> = <call><name>gethostbyaddr_r</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>af</name></expr></argument>,
			    <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr>&amp;<name>errnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* HAVE_GETHOSTBYNAME_R_3_ARG */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name>data</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> = <call><name>gethostbyaddr_r</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>af</name></expr></argument>, <argument><expr>&amp;<name>hp_allocated</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>h</name> = (<name>result</name> != 0) ? <name>NULL</name> : &amp;<name>hp_allocated</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* not HAVE_GETHOSTBYNAME_R */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_GETHOSTBYNAME_LOCK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>netdb_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>h</name> = <call><name>gethostbyaddr</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_GETHOSTBYNAME_R */</comment>
	<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
	<name>ret</name> <init>= <expr><call><name>gethost_common</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_GETHOSTBYNAME_LOCK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>netdb_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>gethostbyaddr_doc</name></expr></argument>,
<argument><expr>"gethostbyaddr(host) -&gt; (name, aliaslist, addresslist)\n\
\n\
Return the true host name, a list of aliases, and a list of IP addresses,\n\
for a host.  The host argument is a string giving a host name or IP number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* Python interface to getservbyname(name).
   This only returns the port number, since the other info is already
   known or not useful (like the list of aliases). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getservbyname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>proto</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>servent</name> *</type><name>sp</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|s:getservbyname"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>sp</name> <init>= <expr><call><name>getservbyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>sp</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"service/proto not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <call><name>ntohs</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>s_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getservbyname_doc</name></expr></argument>,
<argument><expr>"getservbyname(servicename[, protocolname]) -&gt; integer\n\
\n\
Return a port number from a service name and protocol name.\n\
The optional protocol name, if given, should be 'tcp' or 'udp',\n\
otherwise any protocol will match."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* Python interface to getservbyport(port).
   This only returns the service name, since the other info is already
   known or not useful (like the list of aliases). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getservbyport</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>port</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>proto</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>servent</name> *</type><name>sp</name></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"H|s:getservbyport"</expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>sp</name> <init>= <expr><call><name>getservbyport</name><argument_list>(<argument><expr><call><name>htons</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>sp</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"port/proto not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>sp</name>-&gt;<name>s_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getservbyport_doc</name></expr></argument>,
<argument><expr>"getservbyport(port[, protocolname]) -&gt; string\n\
\n\
Return the service name from a port number and protocol name.\n\
The optional protocol name, if given, should be 'tcp' or 'udp',\n\
otherwise any protocol will match."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Python interface to getprotobyname(name).
   This only returns the protocol number, since the other info is
   already known or not useful (like the list of aliases). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getprotobyname</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>protoent</name> *</type><name>sp</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__BEOS__</name></cpp:ifdef>
<comment type="block">/* Not available in BeOS yet. - [cjh] */</comment>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"getprotobyname not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:getprotobyname"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
	<name>sp</name> <init>= <expr><call><name>getprotobyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>Py_END_ALLOW_THREADS</name></macro>
	<if>if <condition>(<expr><name>sp</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"protocol not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name><name>sp</name>-&gt;<name>p_proto</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getprotobyname_doc</name></expr></argument>,
<argument><expr>"getprotobyname(name) -&gt; integer\n\
\n\
Return the protocol number for the named protocol.  (Rarely used.)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SOCKETPAIR</name></cpp:ifdef>
<comment type="block">/* Create a pair of sockets using the socketpair() function.
   Arguments as for socket() except the default family is AF_UNIX if
   defined on the platform; otherwise, the default is AF_INET. */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_socketpair</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>s0</name> <init>= <expr><name>NULL</name></expr></init>, *<name>s1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SOCKET_T</name></type> <name><name>sv</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>family</name></decl>, <decl><type ref="prev"/><name>type</name> <init>= <expr><name>SOCK_STREAM</name></expr></init>, <name>proto</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>family</name> = <name>AF_UNIX</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>family</name> = <name>AF_INET</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|iii:socketpair"</expr></argument>,
			      <argument><expr>&amp;<name>family</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* Create a pair of socket fds */</comment>
	<if>if <condition>(<expr><call><name>socketpair</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>sv</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>s0</name> = <call><name>new_sockobject</name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s0</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>finally</name>;</goto></then></if>
	<expr_stmt><expr><name>s1</name> = <call><name>new_sockobject</name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>s1</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>finally</name>;</goto></then></if>
	<expr_stmt><expr><name>res</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>s0</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>finally</name>:</label>
	<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>s0</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>s1</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>SOCKETCLOSE</name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>socketpair_doc</name></expr></argument>,
<argument><expr>"socketpair([family[, type[, proto]]]) -&gt; (socket object, socket object)\n\
\n\
Create a pair of socket objects from the sockets returned by the platform\n\
socketpair() function.\n\
The arguments are the same as for socket() except the default family is\n\
AF_UNIX if defined on the platform; otherwise, the default is AF_INET."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SOCKETPAIR */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUP</name></cpp:ifndef>
<comment type="block">/* Create a socket object from a numeric file description.
   Useful e.g. if stdin is a socket.
   Additional arguments as for socket(). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_fromfd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PySocketSockObject</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SOCKET_T</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>family</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>proto</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"iii|i:fromfd"</expr></argument>,
			      <argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>family</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="block">/* Dup the fd so it and the socket can be closed independently */</comment>
	<expr_stmt><expr><name>fd</name> = <call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><call><name>set_error</name><argument_list>()</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>s</name> = <call><name>new_sockobject</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>PyObject</name> *) <name>s</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fromfd_doc</name></expr></argument>,
<argument><expr>"fromfd(fd, family, type[, proto]) -&gt; socket object\n\
\n\
Create a socket object from a duplicate of the given\n\
file descriptor.\n\
The remaining arguments are the same as for socket()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_DUP */</comment>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_ntohs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>x2</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:ntohs"</expr></argument>, <argument><expr>&amp;<name>x1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>x1</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"can't convert negative number to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>x2</name> = (<name>unsigned</name> <name>int</name>)<call><name>ntohs</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>short</name>)<name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ntohs_doc</name></expr></argument>,
<argument><expr>"ntohs(integer) -&gt; integer\n\
\n\
Convert a 16-bit integer from network to host byte order."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_ntohl</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>long</name>)<name>x</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			  <argument><expr>"can't convert negative number to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt; 4</expr></cpp:if>
		<block>{
			<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>y</name></decl>;</decl_stmt>
			<comment type="block">/* only want the trailing 32 bits */</comment>
			<expr_stmt><expr><name>y</name> = <name>x</name> &amp; 0xFFFFFFFFUL</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>y</name> ^ <name>x</name></expr>)</condition><then>
				<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
					    <argument><expr>"long int larger than 32 bits"</expr></argument>)</argument_list></call></expr>;</return></then></if>
			<expr_stmt><expr><name>x</name> = <name>y</name></expr>;</expr_stmt>
		}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				    <argument><expr>"expected int/long, %s found"</expr></argument>,
				    <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
	<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ntohl_doc</name></expr></argument>,
<argument><expr>"ntohl(integer) -&gt; integer\n\
\n\
Convert a 32-bit integer from network to host byte order."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_htons</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>x2</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:htons"</expr></argument>, <argument><expr>&amp;<name>x1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>x1</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			<argument><expr>"can't convert negative number to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name>x2</name> = (<name>unsigned</name> <name>int</name>)<call><name>htons</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>short</name>)<name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>htons_doc</name></expr></argument>,
<argument><expr>"htons(integer) -&gt; integer\n\
\n\
Convert a 16-bit integer from host to network byte order."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_htonl</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>long</name>)<name>x</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
			  <argument><expr>"can't convert negative number to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></then>
	<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>long</name>) -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt; 4</expr></cpp:if>
		<block>{
			<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>y</name></decl>;</decl_stmt>
			<comment type="block">/* only want the trailing 32 bits */</comment>
			<expr_stmt><expr><name>y</name> = <name>x</name> &amp; 0xFFFFFFFFUL</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>y</name> ^ <name>x</name></expr>)</condition><then>
				<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
					    <argument><expr>"long int larger than 32 bits"</expr></argument>)</argument_list></call></expr>;</return></then></if>
			<expr_stmt><expr><name>x</name> = <name>y</name></expr>;</expr_stmt>
		}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				    <argument><expr>"expected int/long, %s found"</expr></argument>,
				    <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
	<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><call><name>htonl</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>htonl_doc</name></expr></argument>,
<argument><expr>"htonl(integer) -&gt; integer\n\
\n\
Convert a 32-bit integer from host to network byte order."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* socket.inet_aton() and socket.inet_ntoa() functions. */</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>inet_aton_doc</name></expr></argument>,
<argument><expr>"inet_aton(string) -&gt; packed 32-bit IP representation\n\
\n\
Convert an IP address in string format (123.45.67.89) to the 32-bit packed\n\
binary format used in low-level network functions."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>socket_inet_aton</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INADDR_NONE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INADDR_NONE</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INET_ATON</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>in_addr</name></type> <name>buf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_ATON</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_INET_ATON_WEAKLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* Have to use inet_addr() instead */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>packed_addr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>char</name> *</type><name>ip_addr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:inet_aton"</expr></argument>, <argument><expr>&amp;<name>ip_addr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INET_ATON</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_INET_ATON_WEAKLINK</name></cpp:ifdef>
    <if>if <condition>(<expr><name>inet_aton</name> != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><call><name>inet_aton</name><argument_list>(<argument><expr><name>ip_addr</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><call>(<name>char</name> *)<argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return></then></if>

	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
			<argument><expr>"illegal IP address string passed to inet_aton"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_INET_ATON_WEAKLINK</name></cpp:ifdef>
   }</block></then> <else>else <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INET_ATON</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_INET_ATON_WEAKLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>

	<comment type="block">/* special-case this address as inet_addr might return INADDR_NONE
	 * for this */</comment>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ip_addr</name></expr></argument>, <argument><expr>"255.255.255.255"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>packed_addr</name> = 0xFFFFFFFF</expr>;</expr_stmt>
	}</block></then> <else>else <block>{

		<expr_stmt><expr><name>packed_addr</name> = <call><name>inet_addr</name><argument_list>(<argument><expr><name>ip_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>packed_addr</name> == <name>INADDR_NONE</name></expr>)</condition><then> <block>{	<comment type="block">/* invalid address */</comment>
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
				<argument><expr>"illegal IP address string passed to inet_aton"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></else></if>
	<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *) &amp;<name>packed_addr</name></expr></argument>,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_INET_ATON_WEAKLINK</name></cpp:ifdef>
   }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>inet_ntoa_doc</name></expr></argument>,
<argument><expr>"inet_ntoa(packed_ip) -&gt; ip_address_string\n\
\n\
Convert an IP address from 32-bit packed binary format to string format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>socket_inet_ntoa</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>packed_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>addr_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>in_addr</name></type> <name>packed_addr</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:inet_ntoa"</expr></argument>, <argument><expr>&amp;<name>packed_str</name></expr></argument>, <argument><expr>&amp;<name>addr_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>addr_len</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
			<argument><expr>"packed IP wrong length for inet_ntoa"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>packed_addr</name></expr></argument>, <argument><expr><name>packed_str</name></expr></argument>, <argument><expr><name>addr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><call><name>inet_ntoa</name><argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INET_PTON</name></cpp:ifdef>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>inet_pton_doc</name></expr></argument>,
<argument><expr>"inet_pton(af, ip) -&gt; packed IP address string\n\
\n\
Convert an IP address from string format to a packed string suitable\n\
for use with low-level network functions."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_inet_pton</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>af</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>*</type> <name>ip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type> <name><name>packed</name><index>[<expr><call><name>MAX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <argument><expr><name>in_addr</name></expr></argument></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <argument><expr><name>in6_addr</name></expr></argument></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name></type> <name><name>packed</name><index>[<expr><sizeof>sizeof<argument_list>(<argument>struct <argument><expr><name>in_addr</name></expr></argument></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"is:inet_pton"</expr></argument>, <argument><expr>&amp;<name>af</name></expr></argument>, <argument><expr>&amp;<name>ip</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_IPV6</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if>if<condition>(<expr><name>af</name> == <name>AF_INET6</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
				<argument><expr>"can't use AF_INET6, IPv6 is disabled"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>retval</name> = <call><name>inet_pton</name><argument_list>(<argument><expr><name>af</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>packed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>retval</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><name>retval</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
			<argument><expr>"illegal IP address string passed to inet_pton"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><name>af</name> == <name>AF_INET</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>packed</name></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>in_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	}</block></then> <else>else <if>if <condition>(<expr><name>af</name> == <name>AF_INET6</name></expr>)</condition><then> <block>{
		<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>packed</name></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>in6_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"unknown address family"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if></else></if></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>inet_ntop_doc</name></expr></argument>,
<argument><expr>"inet_ntop(af, packed_ip) -&gt; string formatted IP address\n\
\n\
Convert a packed IP address of the given family to string format."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_inet_ntop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>af</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>*</type> <name>packed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>retval</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><call><name>MAX</name><argument_list>(<argument><expr><name>INET_ADDRSTRLEN</name></expr></argument>, <argument><expr><name>INET6_ADDRSTRLEN</name></expr></argument>)</argument_list></call> + 1</expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>INET_ADDRSTRLEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Guarantee NUL-termination for PyString_FromString() below */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) &amp;<name><name>ip</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"is#:inet_ntop"</expr></argument>, <argument><expr>&amp;<name>af</name></expr></argument>, <argument><expr>&amp;<name>packed</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name>af</name> == <name>AF_INET</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>len</name> != <sizeof>sizeof<argument_list>(<argument>struct <expr><name>in_addr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"invalid length of packed IP address string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	}</block></then> <else>else <if>if <condition>(<expr><name>af</name> == <name>AF_INET6</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>len</name> != <sizeof>sizeof<argument_list>(<argument>struct <expr><name>in6_addr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
				<argument><expr>"invalid length of packed IP address string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
			<argument><expr>"unknown address family %d"</expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if>

	<expr_stmt><expr><name>retval</name> = <call><name>inet_ntop</name><argument_list>(<argument><expr><name>af</name></expr></argument>, <argument><expr><name>packed</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>retval</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then> <else>else <block>{
		<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>

	<comment type="block">/* NOTREACHED */</comment>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>, <argument><expr>"invalid handling of inet_ntop"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_INET_PTON */</comment>

<comment type="block">/* Python interface to getaddrinfo(host, port). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getaddrinfo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>addrinfo</name></type> <name>hints</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>addrinfo</name> *</type><name>res0</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>hobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>pobj</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>pbuf</name><index>[<expr>30</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>hptr</name></decl>, *<decl><type ref="prev"/><name>pptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>family</name></decl>, <decl><type ref="prev"/><name>socktype</name></decl>, <decl><type ref="prev"/><name>protocol</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>all</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>single</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>idna</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>family</name> = <name>socktype</name> = <name>protocol</name> = <name>flags</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>family</name> = <name>AF_UNSPEC</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO|iiii:getaddrinfo"</expr></argument>,
			      <argument><expr>&amp;<name>hobj</name></expr></argument>, <argument><expr>&amp;<name>pobj</name></expr></argument>, <argument><expr>&amp;<name>family</name></expr></argument>, <argument><expr>&amp;<name>socktype</name></expr></argument>,
			      <argument><expr>&amp;<name>protocol</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>hobj</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hptr</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>hobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>idna</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>hobj</name></expr></argument>, <argument><expr>"encode"</expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr>"idna"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>idna</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><name>hptr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>idna</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>hobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hptr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>hobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
				<argument><expr>"getaddrinfo() argument 1 must be string or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></else></if></else></if></else></if>
	<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pptr</name> = <name>pbuf</name></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>pptr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <if>if <condition>(<expr><name>pobj</name> == <name>Py_None</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>pptr</name> = (<name>char</name> *)<name>NULL</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>, <argument><expr>"Int or String expected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>err</name>;</goto>
	}</block></else></if></else></if></else></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>family</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name>.<name>ai_socktype</name></name> = <name>socktype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name>.<name>ai_protocol</name></name> = <name>protocol</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name>.<name>ai_flags</name></name> = <name>flags</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name>
	<name>ACQUIRE_GETADDRINFO_LOCK</name></type>
	<name>error</name> <init>= <expr><call><name>getaddrinfo</name><argument_list>(<argument><expr><name>hptr</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
	<name>RELEASE_GETADDRINFO_LOCK</name></expr></expr_stmt>  <comment type="block">/* see comment in setipaddr() */</comment>
	<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	}</block></then></if>

	<if>if <condition>(<expr>(<name>all</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>
	<for>for (<init><expr><name>res</name> = <name>res0</name></expr>;</init> <condition><expr><name>res</name></expr>;</condition> <incr><expr><name>res</name> = <name><name>res</name>-&gt;<name>ai_next</name></name></expr></incr>) <block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>addr</name> <init>=
			<expr><call><name>makesockaddr</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addrlen</name></name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>addr</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
		<expr_stmt><expr><name>single</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iiisO"</expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_family</name></name></expr></argument>,
			<argument><expr><name><name>res</name>-&gt;<name>ai_socktype</name></name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_protocol</name></name></expr></argument>,
			<argument><expr><name><name>res</name>-&gt;<name>ai_canonname</name></name> ? <name><name>res</name>-&gt;<name>ai_canonname</name></name> : ""</expr></argument>,
			<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>single</name> == <name>NULL</name></expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>

		<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>all</name></expr></argument>, <argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>idna</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res0</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>all</name></expr>;</return>
 <label><name>err</name>:</label>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>idna</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>res0</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr>(<name>PyObject</name> *)<name>NULL</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getaddrinfo_doc</name></expr></argument>,
<argument><expr>"getaddrinfo(host, port [, family, socktype, proto, flags])\n\
    -&gt; list of (family, socktype, proto, canonname, sockaddr)\n\
\n\
Resolve host and port into addrinfo struct."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Python interface to getnameinfo(sa, flags). */</comment>

<comment type="block">/*ARGSUSED*/</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getnameinfo</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>sa</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>hostp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>, <decl><type ref="prev"/><name>flowinfo</name></decl>, <decl><type ref="prev"/><name>scope_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>hbuf</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>pbuf</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>addrinfo</name></type> <name>hints</name></decl>, *<decl><type ref="prev"/><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr>(<name>PyObject</name> *)<name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>flags</name> = <name>flowinfo</name> = <name>scope_id</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Oi:getnameinfo"</expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if  <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>sa</name></expr></argument>, <argument><expr>"si|ii"</expr></argument>,
			       <argument><expr>&amp;<name>hostp</name></expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>, <argument><expr>&amp;<name>flowinfo</name></expr></argument>, <argument><expr>&amp;<name>scope_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name>.<name>ai_family</name></name> = <name>AF_UNSPEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name>.<name>ai_socktype</name></name> = <name>SOCK_DGRAM</name></expr>;</expr_stmt>	<comment type="block">/* make numeric port happy */</comment>
	<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name>
	<name>ACQUIRE_GETADDRINFO_LOCK</name></type>
	<name>error</name> <init>= <expr><call><name>getaddrinfo</name><argument_list>(<argument><expr><name>hostp</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>&amp;<name>hints</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name>
	<name>RELEASE_GETADDRINFO_LOCK</name></expr></expr_stmt>  <comment type="block">/* see comment in setipaddr() */</comment>
	<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>res</name>-&gt;<name>ai_next</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
			<argument><expr>"sockaddr resolved to multiple addresses"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	}</block></then></if>
	<switch>switch <condition>(<expr><name><name>res</name>-&gt;<name>ai_family</name></name></expr>)</condition> <block>{
	<case>case <expr><name>AF_INET</name></expr>:
	    <block>{
		<decl_stmt><decl><type><name>char</name> *</type><name>t1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>t2</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>sa</name></expr></argument>, <argument><expr>"si"</expr></argument>, <argument><expr>&amp;<name>t1</name></expr></argument>, <argument><expr>&amp;<name>t2</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>,
				<argument><expr>"IPv4 sockaddr must be 2 tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>fail</name>;</goto>
		}</block></then></if>
		<break>break;</break>
	    }</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	</case><case>case <expr><name>AF_INET6</name></expr>:
	    <block>{
		<decl_stmt><decl><type>struct <name>sockaddr_in6</name> *</type><name>sin6</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>sin6</name> = (struct <name>sockaddr_in6</name> *)<name><name>res</name>-&gt;<name>ai_addr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sin6</name>-&gt;<name>sin6_flowinfo</name></name> = <name>flowinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sin6</name>-&gt;<name>sin6_scope_id</name></name> = <name>scope_id</name></expr>;</expr_stmt>
		<break>break;</break>
	    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</case>}</block></switch>
	<expr_stmt><expr><name>error</name> = <call><name>getnameinfo</name><argument_list>(<argument><expr><name><name>res</name>-&gt;<name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>ai_addrlen</name></name></expr></argument>,
			<argument><expr><name>hbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>set_gaierror</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>fail</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ss"</expr></argument>, <argument><expr><name>hbuf</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fail</name>:</label>
	<if>if <condition>(<expr><name>res</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getnameinfo_doc</name></expr></argument>,
<argument><expr>"getnameinfo(sockaddr, flags) --&gt; (host, port)\n\
\n\
Get host and port for a sockaddr."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* Python API to getting and setting the default timeout value. */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_getdefaulttimeout</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>defaulttimeout</name> &lt; 0.0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then>
	<else>else
		<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>defaulttimeout</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>getdefaulttimeout_doc</name></expr></argument>,
<argument><expr>"getdefaulttimeout() -&gt; timeout\n\
\n\
Returns the default timeout in floating seconds for new socket objects.\n\
A value of None indicates that new socket objects have no timeout.\n\
When the socket module is first imported, the default is None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>socket_setdefaulttimeout</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>double</name></type> <name>timeout</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>arg</name> == <name>Py_None</name></expr>)</condition><then>
		<expr_stmt><expr><name>timeout</name> = -1.0</expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>timeout</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>timeout</name> &lt; 0.0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
						<argument><expr>"Timeout value out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<return>return <expr><name>NULL</name></expr>;</return>
		}</block></then></if>
	}</block></else></if>

	<expr_stmt><expr><name>defaulttimeout</name> = <name>timeout</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>setdefaulttimeout_doc</name></expr></argument>,
<argument><expr>"setdefaulttimeout(timeout)\n\
\n\
Set the default timeout in floating seconds for new socket objects.\n\
A value of None indicates that new socket objects have no timeout.\n\
When the socket module is first imported, the default is None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* List of functions exported by this module. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>socket_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"gethostbyname"</expr>,	<expr><name>socket_gethostbyname</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>gethostbyname_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"gethostbyname_ex"</expr>,	<expr><name>socket_gethostbyname_ex</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>ghbn_ex_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"gethostbyaddr"</expr>,	<expr><name>socket_gethostbyaddr</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>gethostbyaddr_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"gethostname"</expr>,		<expr><name>socket_gethostname</name></expr>,
	 <expr><name>METH_NOARGS</name></expr>,  <expr><name>gethostname_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getservbyname"</expr>,	<expr><name>socket_getservbyname</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>getservbyname_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getservbyport"</expr>,	<expr><name>socket_getservbyport</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>getservbyport_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getprotobyname"</expr>,	<expr><name>socket_getprotobyname</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>getprotobyname_doc</name></expr>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_DUP</name></cpp:ifndef>
	<expr><block>{<expr>"fromfd"</expr>,		<expr><name>socket_fromfd</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>fromfd_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SOCKETPAIR</name></cpp:ifdef>
	<expr><block>{<expr>"socketpair"</expr>,		<expr><name>socket_socketpair</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>socketpair_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"ntohs"</expr>,		<expr><name>socket_ntohs</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>ntohs_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"ntohl"</expr>,		<expr><name>socket_ntohl</name></expr>,
	 <expr><name>METH_O</name></expr>, <expr><name>ntohl_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"htons"</expr>,		<expr><name>socket_htons</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>htons_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"htonl"</expr>,		<expr><name>socket_htonl</name></expr>,
	 <expr><name>METH_O</name></expr>, <expr><name>htonl_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"inet_aton"</expr>,		<expr><name>socket_inet_aton</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>inet_aton_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"inet_ntoa"</expr>,		<expr><name>socket_inet_ntoa</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>inet_ntoa_doc</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INET_PTON</name></cpp:ifdef>
	<expr><block>{<expr>"inet_pton"</expr>,		<expr><name>socket_inet_pton</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>inet_pton_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"inet_ntop"</expr>,		<expr><name>socket_inet_ntop</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>inet_ntop_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr>"getaddrinfo"</expr>,		<expr><name>socket_getaddrinfo</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>getaddrinfo_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getnameinfo"</expr>,		<expr><name>socket_getnameinfo</name></expr>,
	 <expr><name>METH_VARARGS</name></expr>, <expr><name>getnameinfo_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"getdefaulttimeout"</expr>,	<expr>(<name>PyCFunction</name>)<name>socket_getdefaulttimeout</name></expr>,
	 <expr><name>METH_NOARGS</name></expr>, <expr><name>getdefaulttimeout_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"setdefaulttimeout"</expr>,	<expr><name>socket_setdefaulttimeout</name></expr>,
	 <expr><name>METH_O</name></expr>, <expr><name>setdefaulttimeout_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>,			<expr><name>NULL</name></expr>}</block></expr>		 <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_INIT_DEFINED</name></cpp:macro></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>_kernel_swi_regs</name></type> <name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>r</name>.<name>r</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_kernel_swi</name><argument_list>(<argument><expr>0x43380</expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>taskwindow</name> = <name><name>r</name>.<name>r</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr>1</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* RISCOS */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_INIT_DEFINED</name></cpp:macro></cpp:define>

<comment type="block">/* Additional initialization and cleanup for Windows */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>os_cleanup</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>WSACleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WSADATA</name></type> <name>WSAData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><name>ret</name> = <call><name>WSAStartup</name><argument_list>(<argument><expr>0x0101</expr></argument>, <argument><expr>&amp;<name>WSAData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>ret</name></expr>)</condition> <block>{
	<case>case <expr>0</expr>:	<comment type="block">/* No error */</comment>
		<expr_stmt><expr><call><name>Py_AtExit</name><argument_list>(<argument><expr><name>os_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return> <comment type="block">/* Success */</comment>
	</case><case>case <expr><name>WSASYSNOTREADY</name></expr>:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
				<argument><expr>"WSAStartup failed: network not ready"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>WSAVERNOTSUPPORTED</name></expr>:
	</case><case>case <expr><name>WSAEINVAL</name></expr>:
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
			<argument><expr><name>PyExc_ImportError</name></expr></argument>,
			<argument><expr>"WSAStartup failed: requested version not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><default>default:
		<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			      <argument><expr>"WSAStartup failed: error code %d"</expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</default>}</block></switch>
	<return>return <expr>0</expr>;</return> <comment type="block">/* Failure */</comment>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PYOS_OS2</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_INIT_DEFINED</name></cpp:macro></cpp:define>

<comment type="block">/* Additional initialization for OS/2 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PYCC_GCC</name></cpp:ifndef>
	<decl_stmt><decl><type><name>char</name></type> <name><name>reason</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sock_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>rc</name> == 0</expr>)</condition><then> <block>{
		<return>return <expr>1</expr>;</return> <comment type="block">/* Success */</comment>
	}</block></then></if>

	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		      <argument><expr>"OS/2 TCP/IP Error# %d"</expr></argument>, <argument><expr><call><name>sock_errno</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr>0</expr>;</return>  <comment type="block">/* Failure */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* No need to initialise sockets with GCC/EMX */</comment>
	<return>return <expr>1</expr>;</return> <comment type="block">/* Success */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PYOS_OS2 */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OS_INIT_DEFINED</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<return>return <expr>1</expr>;</return> <comment type="block">/* Success */</comment>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* C API table - always add new things to the end for binary
   compatibility. */</comment>
<decl_stmt><decl><type><specifier>static</specifier>
<name>PySocketModule_APIObject</name></type> <name>PySocketModuleAPI</name> <init>=
<expr><block>{
	<expr>&amp;<name>sock_type</name></expr>,
        <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Initialize the _socket module.

   This module is actually called "_socket", and there's a wrapper
   "socket.py" which implements some additional functionality.  On some
   platforms (e.g. Windows and OS/2), socket.py also implements a
   wrapper for the socket type that provides missing functionality such
   as makefile(), dup() and fromfd().  The import of "_socket" may fail
   with an ImportError exception if os-specific initialization fails.
   On Windows, this does WINSOCK initialization.  When WINSOCK is
   initialized succesfully, a call to WSACleanup() is scheduled to be
   made at exit time.
*/</comment>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>socket_doc</name></expr></argument>,
<argument><expr>"Implementation module for socket operations.\n\
\n\
See the socket module for documentation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_socket</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>has_ipv6</name></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>os_init</name><argument_list>()</argument_list></call></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>sock_type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr><name>PySocket_MODULE_NAME</name></expr></argument>,
			   <argument><expr><name>socket_methods</name></expr></argument>,
			   <argument><expr><name>socket_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>socket_error</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"socket.error"</expr></argument>,
					  <argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>socket_error</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
        <expr_stmt><expr><name><name>PySocketModuleAPI</name>.<name>error</name></name> = <name>socket_error</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>socket_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>socket_herror</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"socket.herror"</expr></argument>,
					   <argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>socket_herror</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>socket_herror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"herror"</expr></argument>, <argument><expr><name>socket_herror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>socket_gaierror</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"socket.gaierror"</expr></argument>, <argument><expr><name>socket_error</name></expr></argument>,
	    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>socket_gaierror</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>socket_gaierror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"gaierror"</expr></argument>, <argument><expr><name>socket_gaierror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>socket_timeout</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"socket.timeout"</expr></argument>,
					    <argument><expr><name>socket_error</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>socket_timeout</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>socket_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"timeout"</expr></argument>, <argument><expr><name>socket_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>sock_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SocketType"</expr></argument>,
			       <argument><expr>(<name>PyObject</name> *)&amp;<name>sock_type</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name> *)&amp;<name>sock_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"socket"</expr></argument>,
			       <argument><expr>(<name>PyObject</name> *)&amp;<name>sock_type</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
		<return>return;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	<expr_stmt><expr><name>has_ipv6</name> = <name>Py_True</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>has_ipv6</name> = <name>Py_False</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>has_ipv6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"has_ipv6"</expr></argument>, <argument><expr><name>has_ipv6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Export C API */</comment>
	<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>PySocket_CAPI_NAME</name></expr></argument>,
	       <argument><expr><call><name>PyCObject_FromVoidPtr</name><argument_list>(<argument><expr>(<name>void</name> *)&amp;<name>PySocketModuleAPI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>
				 )</argument_list></call> != 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<comment type="block">/* Address families (we only support AF_INET and AF_UNIX) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_UNSPEC</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_UNSPEC"</expr></argument>, <argument><expr><name>AF_UNSPEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_INET"</expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_INET6</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_INET6"</expr></argument>, <argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AF_INET6 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_UNIX"</expr></argument>, <argument><expr><name>AF_UNIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AF_UNIX */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_AX25</name></cpp:ifdef>
	<comment type="block">/* Amateur Radio AX.25 */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_AX25"</expr></argument>, <argument><expr><name>AF_AX25</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_IPX</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_IPX"</expr></argument>, <argument><expr><name>AF_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Novell IPX */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_APPLETALK</name></cpp:ifdef>
	<comment type="block">/* Appletalk DDP */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_APPLETALK"</expr></argument>, <argument><expr><name>AF_APPLETALK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_NETROM</name></cpp:ifdef>
	<comment type="block">/* Amateur radio NetROM */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_NETROM"</expr></argument>, <argument><expr><name>AF_NETROM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_BRIDGE</name></cpp:ifdef>
	<comment type="block">/* Multiprotocol bridge */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_BRIDGE"</expr></argument>, <argument><expr><name>AF_BRIDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_ATMPVC</name></cpp:ifdef>
	<comment type="block">/* ATM PVCs */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ATMPVC"</expr></argument>, <argument><expr><name>AF_ATMPVC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_AAL5</name></cpp:ifdef>
	<comment type="block">/* Reserved for Werner's ATM */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_AAL5"</expr></argument>, <argument><expr><name>AF_AAL5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_X25</name></cpp:ifdef>
	<comment type="block">/* Reserved for X.25 project */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_X25"</expr></argument>, <argument><expr><name>AF_X25</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_INET6</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_INET6"</expr></argument>, <argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IP version 6 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_ROSE</name></cpp:ifdef>
	<comment type="block">/* Amateur Radio X.25 PLP */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ROSE"</expr></argument>, <argument><expr><name>AF_ROSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_DECnet</name></cpp:ifdef>
	<comment type="block">/* Reserved for DECnet project */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_DECnet"</expr></argument>, <argument><expr><name>AF_DECnet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_NETBEUI</name></cpp:ifdef>
	<comment type="block">/* Reserved for 802.2LLC project */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_NETBEUI"</expr></argument>, <argument><expr><name>AF_NETBEUI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_SECURITY</name></cpp:ifdef>
	<comment type="block">/* Security callback pseudo AF */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_SECURITY"</expr></argument>, <argument><expr><name>AF_SECURITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_KEY</name></cpp:ifdef>
	<comment type="block">/* PF_KEY key management API */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_KEY"</expr></argument>, <argument><expr><name>AF_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_NETLINK</name></cpp:ifdef>
	<comment type="block">/*  */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_NETLINK"</expr></argument>, <argument><expr><name>AF_NETLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_ROUTE"</expr></argument>, <argument><expr><name>NETLINK_ROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_SKIP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_SKIP"</expr></argument>, <argument><expr><name>NETLINK_SKIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_W1</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_W1"</expr></argument>, <argument><expr><name>NETLINK_W1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_USERSOCK"</expr></argument>, <argument><expr><name>NETLINK_USERSOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_FIREWALL"</expr></argument>, <argument><expr><name>NETLINK_FIREWALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_TCPDIAG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_TCPDIAG"</expr></argument>, <argument><expr><name>NETLINK_TCPDIAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_NFLOG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_NFLOG"</expr></argument>, <argument><expr><name>NETLINK_NFLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_XFRM</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_XFRM"</expr></argument>, <argument><expr><name>NETLINK_XFRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_ARPD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_ARPD"</expr></argument>, <argument><expr><name>NETLINK_ARPD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_ROUTE6</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_ROUTE6"</expr></argument>, <argument><expr><name>NETLINK_ROUTE6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_IP6_FW"</expr></argument>, <argument><expr><name>NETLINK_IP6_FW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_DNRTMSG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_DNRTMSG"</expr></argument>, <argument><expr><name>NETLINK_DNRTMSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NETLINK_TAPBASE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NETLINK_TAPBASE"</expr></argument>, <argument><expr><name>NETLINK_TAPBASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AF_NETLINK */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_ROUTE</name></cpp:ifdef>
	<comment type="block">/* Alias to emulate 4.4BSD */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ROUTE"</expr></argument>, <argument><expr><name>AF_ROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_ASH</name></cpp:ifdef>
	<comment type="block">/* Ash */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ASH"</expr></argument>, <argument><expr><name>AF_ASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_ECONET</name></cpp:ifdef>
	<comment type="block">/* Acorn Econet */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ECONET"</expr></argument>, <argument><expr><name>AF_ECONET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_ATMSVC</name></cpp:ifdef>
	<comment type="block">/* ATM SVCs */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_ATMSVC"</expr></argument>, <argument><expr><name>AF_ATMSVC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_SNA</name></cpp:ifdef>
	<comment type="block">/* Linux SNA Project (nutters!) */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_SNA"</expr></argument>, <argument><expr><name>AF_SNA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_IRDA</name></cpp:ifdef>
	<comment type="block">/* IRDA sockets */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_IRDA"</expr></argument>, <argument><expr><name>AF_IRDA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_PPPOX</name></cpp:ifdef>
	<comment type="block">/* PPPoX sockets */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_PPPOX"</expr></argument>, <argument><expr><name>AF_PPPOX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_WANPIPE</name></cpp:ifdef>
	<comment type="block">/* Wanpipe API Sockets */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_WANPIPE"</expr></argument>, <argument><expr><name>AF_WANPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_LLC</name></cpp:ifdef>
	<comment type="block">/* Linux LLC */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_LLC"</expr></argument>, <argument><expr><name>AF_LLC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BLUETOOTH</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_BLUETOOTH"</expr></argument>, <argument><expr><name>AF_BLUETOOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BTPROTO_L2CAP"</expr></argument>, <argument><expr><name>BTPROTO_L2CAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BTPROTO_HCI"</expr></argument>, <argument><expr><name>BTPROTO_HCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_HCI"</expr></argument>, <argument><expr><name>SOL_HCI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"HCI_FILTER"</expr></argument>, <argument><expr><name>HCI_FILTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"HCI_TIME_STAMP"</expr></argument>, <argument><expr><name>HCI_TIME_STAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"HCI_DATA_DIR"</expr></argument>, <argument><expr><name>HCI_DATA_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BTPROTO_SCO"</expr></argument>, <argument><expr><name>BTPROTO_SCO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BTPROTO_RFCOMM"</expr></argument>, <argument><expr><name>BTPROTO_RFCOMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BDADDR_ANY"</expr></argument>, <argument><expr>"00:00:00:00:00:00"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"BDADDR_LOCAL"</expr></argument>, <argument><expr>"00:00:00:FF:FF:FF"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETPACKET_PACKET_H</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_PACKET"</expr></argument>, <argument><expr><name>AF_PACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PF_PACKET"</expr></argument>, <argument><expr><name>PF_PACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_HOST"</expr></argument>, <argument><expr><name>PACKET_HOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_BROADCAST"</expr></argument>, <argument><expr><name>PACKET_BROADCAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_MULTICAST"</expr></argument>, <argument><expr><name>PACKET_MULTICAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_OTHERHOST"</expr></argument>, <argument><expr><name>PACKET_OTHERHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_OUTGOING"</expr></argument>, <argument><expr><name>PACKET_OUTGOING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_LOOPBACK"</expr></argument>, <argument><expr><name>PACKET_LOOPBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"PACKET_FASTROUTE"</expr></argument>, <argument><expr><name>PACKET_FASTROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_TIPC_H</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AF_TIPC"</expr></argument>, <argument><expr><name>AF_TIPC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for addresses */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_ADDR_NAMESEQ"</expr></argument>, <argument><expr><name>TIPC_ADDR_NAMESEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_ADDR_NAME"</expr></argument>, <argument><expr><name>TIPC_ADDR_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_ADDR_ID"</expr></argument>, <argument><expr><name>TIPC_ADDR_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_ZONE_SCOPE"</expr></argument>, <argument><expr><name>TIPC_ZONE_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_CLUSTER_SCOPE"</expr></argument>, <argument><expr><name>TIPC_CLUSTER_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_NODE_SCOPE"</expr></argument>, <argument><expr><name>TIPC_NODE_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for setsockopt() */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_TIPC"</expr></argument>, <argument><expr><name>SOL_TIPC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_IMPORTANCE"</expr></argument>, <argument><expr><name>TIPC_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SRC_DROPPABLE"</expr></argument>, <argument><expr><name>TIPC_SRC_DROPPABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_DEST_DROPPABLE"</expr></argument>,
			<argument><expr><name>TIPC_DEST_DROPPABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_CONN_TIMEOUT"</expr></argument>, <argument><expr><name>TIPC_CONN_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_LOW_IMPORTANCE"</expr></argument>,
			<argument><expr><name>TIPC_LOW_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_MEDIUM_IMPORTANCE"</expr></argument>,
			<argument><expr><name>TIPC_MEDIUM_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_HIGH_IMPORTANCE"</expr></argument>,
			<argument><expr><name>TIPC_HIGH_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_CRITICAL_IMPORTANCE"</expr></argument>,
			<argument><expr><name>TIPC_CRITICAL_IMPORTANCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for subscriptions */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SUB_PORTS"</expr></argument>, <argument><expr><name>TIPC_SUB_PORTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SUB_SERVICE"</expr></argument>, <argument><expr><name>TIPC_SUB_SERVICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TIPC_SUB_CANCEL</name></cpp:ifdef>
	<comment type="block">/* doesn't seem to be available everywhere */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SUB_CANCEL"</expr></argument>, <argument><expr><name>TIPC_SUB_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_WAIT_FOREVER"</expr></argument>, <argument><expr><name>TIPC_WAIT_FOREVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_PUBLISHED"</expr></argument>, <argument><expr><name>TIPC_PUBLISHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_WITHDRAWN"</expr></argument>, <argument><expr><name>TIPC_WITHDRAWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_SUBSCR_TIMEOUT"</expr></argument>, <argument><expr><name>TIPC_SUBSCR_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_CFG_SRV"</expr></argument>, <argument><expr><name>TIPC_CFG_SRV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TIPC_TOP_SRV"</expr></argument>, <argument><expr><name>TIPC_TOP_SRV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Socket types */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_STREAM"</expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_DGRAM"</expr></argument>, <argument><expr><name>SOCK_DGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__BEOS__</name></cpp:ifndef>
<comment type="block">/* We have incomplete socket support. */</comment>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_RAW"</expr></argument>, <argument><expr><name>SOCK_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_SEQPACKET"</expr></argument>, <argument><expr><name>SOCK_SEQPACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOCK_RDM</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOCK_RDM"</expr></argument>, <argument><expr><name>SOCK_RDM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_DEBUG"</expr></argument>, <argument><expr><name>SO_DEBUG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_ACCEPTCONN</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_ACCEPTCONN"</expr></argument>, <argument><expr><name>SO_ACCEPTCONN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_REUSEADDR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_REUSEADDR"</expr></argument>, <argument><expr><name>SO_REUSEADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SO_EXCLUSIVEADDRUSE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_EXCLUSIVEADDRUSE"</expr></argument>, <argument><expr><name>SO_EXCLUSIVEADDRUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_KEEPALIVE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_KEEPALIVE"</expr></argument>, <argument><expr><name>SO_KEEPALIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_DONTROUTE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_DONTROUTE"</expr></argument>, <argument><expr><name>SO_DONTROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_BROADCAST</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_BROADCAST"</expr></argument>, <argument><expr><name>SO_BROADCAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_USELOOPBACK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_USELOOPBACK"</expr></argument>, <argument><expr><name>SO_USELOOPBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_LINGER</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_LINGER"</expr></argument>, <argument><expr><name>SO_LINGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_OOBINLINE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_OOBINLINE"</expr></argument>, <argument><expr><name>SO_OOBINLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_REUSEPORT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_REUSEPORT"</expr></argument>, <argument><expr><name>SO_REUSEPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_SNDBUF</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_SNDBUF"</expr></argument>, <argument><expr><name>SO_SNDBUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_RCVBUF</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_RCVBUF"</expr></argument>, <argument><expr><name>SO_RCVBUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_SNDLOWAT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_SNDLOWAT"</expr></argument>, <argument><expr><name>SO_SNDLOWAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_RCVLOWAT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_RCVLOWAT"</expr></argument>, <argument><expr><name>SO_RCVLOWAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_SNDTIMEO</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_SNDTIMEO"</expr></argument>, <argument><expr><name>SO_SNDTIMEO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_RCVTIMEO</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_RCVTIMEO"</expr></argument>, <argument><expr><name>SO_RCVTIMEO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_ERROR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_ERROR"</expr></argument>, <argument><expr><name>SO_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SO_TYPE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SO_TYPE"</expr></argument>, <argument><expr><name>SO_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Maximum number of connections for "listen" */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOMAXCONN</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOMAXCONN"</expr></argument>, <argument><expr><name>SOMAXCONN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOMAXCONN"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Common value */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Flags for send, recv */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_OOB</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_OOB"</expr></argument>, <argument><expr><name>MSG_OOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_PEEK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_PEEK"</expr></argument>, <argument><expr><name>MSG_PEEK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_DONTROUTE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_DONTROUTE"</expr></argument>, <argument><expr><name>MSG_DONTROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_DONTWAIT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_DONTWAIT"</expr></argument>, <argument><expr><name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_EOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_EOR"</expr></argument>, <argument><expr><name>MSG_EOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_TRUNC</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_TRUNC"</expr></argument>, <argument><expr><name>MSG_TRUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_CTRUNC</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_CTRUNC"</expr></argument>, <argument><expr><name>MSG_CTRUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_WAITALL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_WAITALL"</expr></argument>, <argument><expr><name>MSG_WAITALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_BTAG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_BTAG"</expr></argument>, <argument><expr><name>MSG_BTAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>MSG_ETAG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"MSG_ETAG"</expr></argument>, <argument><expr><name>MSG_ETAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Protocol level and numbers, usable for [gs]etsockopt */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_SOCKET</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_SOCKET"</expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_IP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_IP"</expr></argument>, <argument><expr><name>SOL_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_IP"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_IPX</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_IPX"</expr></argument>, <argument><expr><name>SOL_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_AX25</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_AX25"</expr></argument>, <argument><expr><name>SOL_AX25</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_ATALK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_ATALK"</expr></argument>, <argument><expr><name>SOL_ATALK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_NETROM</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_NETROM"</expr></argument>, <argument><expr><name>SOL_NETROM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_ROSE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_ROSE"</expr></argument>, <argument><expr><name>SOL_ROSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_TCP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_TCP"</expr></argument>, <argument><expr><name>SOL_TCP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_TCP"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SOL_UDP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_UDP"</expr></argument>, <argument><expr><name>SOL_UDP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SOL_UDP"</expr></argument>, <argument><expr>17</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_IP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IP"</expr></argument>, <argument><expr><name>IPPROTO_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IP"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_HOPOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_HOPOPTS"</expr></argument>, <argument><expr><name>IPPROTO_HOPOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_ICMP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ICMP"</expr></argument>, <argument><expr><name>IPPROTO_ICMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ICMP"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_IGMP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IGMP"</expr></argument>, <argument><expr><name>IPPROTO_IGMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_GGP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_GGP"</expr></argument>, <argument><expr><name>IPPROTO_GGP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_IPV4</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPV4"</expr></argument>, <argument><expr><name>IPPROTO_IPV4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_IPV6</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPV6"</expr></argument>, <argument><expr><name>IPPROTO_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_IPIP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPIP"</expr></argument>, <argument><expr><name>IPPROTO_IPIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_TCP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_TCP"</expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_TCP"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_EGP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_EGP"</expr></argument>, <argument><expr><name>IPPROTO_EGP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_PUP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_PUP"</expr></argument>, <argument><expr><name>IPPROTO_PUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_UDP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_UDP"</expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_UDP"</expr></argument>, <argument><expr>17</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_IDP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IDP"</expr></argument>, <argument><expr><name>IPPROTO_IDP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_HELLO</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_HELLO"</expr></argument>, <argument><expr><name>IPPROTO_HELLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_ND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ND"</expr></argument>, <argument><expr><name>IPPROTO_ND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_TP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_TP"</expr></argument>, <argument><expr><name>IPPROTO_TP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_IPV6</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPV6"</expr></argument>, <argument><expr><name>IPPROTO_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_ROUTING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ROUTING"</expr></argument>, <argument><expr><name>IPPROTO_ROUTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_FRAGMENT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_FRAGMENT"</expr></argument>, <argument><expr><name>IPPROTO_FRAGMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_RSVP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_RSVP"</expr></argument>, <argument><expr><name>IPPROTO_RSVP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_GRE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_GRE"</expr></argument>, <argument><expr><name>IPPROTO_GRE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_ESP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ESP"</expr></argument>, <argument><expr><name>IPPROTO_ESP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_AH</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_AH"</expr></argument>, <argument><expr><name>IPPROTO_AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_MOBILE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_MOBILE"</expr></argument>, <argument><expr><name>IPPROTO_MOBILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_ICMPV6</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_ICMPV6"</expr></argument>, <argument><expr><name>IPPROTO_ICMPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_NONE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_NONE"</expr></argument>, <argument><expr><name>IPPROTO_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_DSTOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_DSTOPTS"</expr></argument>, <argument><expr><name>IPPROTO_DSTOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_XTP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_XTP"</expr></argument>, <argument><expr><name>IPPROTO_XTP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_EON</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_EON"</expr></argument>, <argument><expr><name>IPPROTO_EON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_PIM</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_PIM"</expr></argument>, <argument><expr><name>IPPROTO_PIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_IPCOMP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_IPCOMP"</expr></argument>, <argument><expr><name>IPPROTO_IPCOMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_VRRP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_VRRP"</expr></argument>, <argument><expr><name>IPPROTO_VRRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_BIP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_BIP"</expr></argument>, <argument><expr><name>IPPROTO_BIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/**/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_RAW</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_RAW"</expr></argument>, <argument><expr><name>IPPROTO_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_RAW"</expr></argument>, <argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPROTO_MAX</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPROTO_MAX"</expr></argument>, <argument><expr><name>IPPROTO_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Some port configuration */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPORT_RESERVED</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPORT_RESERVED"</expr></argument>, <argument><expr><name>IPPORT_RESERVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPORT_RESERVED"</expr></argument>, <argument><expr>1024</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPPORT_USERRESERVED</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPORT_USERRESERVED"</expr></argument>, <argument><expr><name>IPPORT_USERRESERVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPPORT_USERRESERVED"</expr></argument>, <argument><expr>5000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Some reserved IP v.4 addresses */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>INADDR_ANY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_ANY"</expr></argument>, <argument><expr><name>INADDR_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_ANY"</expr></argument>, <argument><expr>0x00000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>INADDR_BROADCAST</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_BROADCAST"</expr></argument>, <argument><expr><name>INADDR_BROADCAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_BROADCAST"</expr></argument>, <argument><expr>0xffffffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>INADDR_LOOPBACK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_LOOPBACK"</expr></argument>, <argument><expr><name>INADDR_LOOPBACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_LOOPBACK"</expr></argument>, <argument><expr>0x7F000001</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>INADDR_UNSPEC_GROUP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_UNSPEC_GROUP"</expr></argument>, <argument><expr><name>INADDR_UNSPEC_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_UNSPEC_GROUP"</expr></argument>, <argument><expr>0xe0000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>INADDR_ALLHOSTS_GROUP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_ALLHOSTS_GROUP"</expr></argument>,
				<argument><expr><name>INADDR_ALLHOSTS_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_ALLHOSTS_GROUP"</expr></argument>, <argument><expr>0xe0000001</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>INADDR_MAX_LOCAL_GROUP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_MAX_LOCAL_GROUP"</expr></argument>,
				<argument><expr><name>INADDR_MAX_LOCAL_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_MAX_LOCAL_GROUP"</expr></argument>, <argument><expr>0xe00000ff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>INADDR_NONE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_NONE"</expr></argument>, <argument><expr><name>INADDR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"INADDR_NONE"</expr></argument>, <argument><expr>0xffffffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* IPv4 [gs]etsockopt options */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_OPTIONS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_OPTIONS"</expr></argument>, <argument><expr><name>IP_OPTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_HDRINCL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_HDRINCL"</expr></argument>, <argument><expr><name>IP_HDRINCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_TOS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_TOS"</expr></argument>, <argument><expr><name>IP_TOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_TTL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_TTL"</expr></argument>, <argument><expr><name>IP_TTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_RECVOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_RECVOPTS"</expr></argument>, <argument><expr><name>IP_RECVOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_RECVRETOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_RECVRETOPTS"</expr></argument>, <argument><expr><name>IP_RECVRETOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_RECVDSTADDR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_RECVDSTADDR"</expr></argument>, <argument><expr><name>IP_RECVDSTADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_RETOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_RETOPTS"</expr></argument>, <argument><expr><name>IP_RETOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_MULTICAST_IF</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_MULTICAST_IF"</expr></argument>, <argument><expr><name>IP_MULTICAST_IF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_MULTICAST_TTL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_MULTICAST_TTL"</expr></argument>, <argument><expr><name>IP_MULTICAST_TTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_MULTICAST_LOOP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_MULTICAST_LOOP"</expr></argument>, <argument><expr><name>IP_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_ADD_MEMBERSHIP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_ADD_MEMBERSHIP"</expr></argument>, <argument><expr><name>IP_ADD_MEMBERSHIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_DROP_MEMBERSHIP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_DROP_MEMBERSHIP"</expr></argument>, <argument><expr><name>IP_DROP_MEMBERSHIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_DEFAULT_MULTICAST_TTL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_DEFAULT_MULTICAST_TTL"</expr></argument>,
				<argument><expr><name>IP_DEFAULT_MULTICAST_TTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_DEFAULT_MULTICAST_LOOP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_DEFAULT_MULTICAST_LOOP"</expr></argument>,
				<argument><expr><name>IP_DEFAULT_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IP_MAX_MEMBERSHIPS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IP_MAX_MEMBERSHIPS"</expr></argument>, <argument><expr><name>IP_MAX_MEMBERSHIPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* IPv6 [gs]etsockopt options, defined in RFC2553 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPV6_JOIN_GROUP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_JOIN_GROUP"</expr></argument>, <argument><expr><name>IPV6_JOIN_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPV6_LEAVE_GROUP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_LEAVE_GROUP"</expr></argument>, <argument><expr><name>IPV6_LEAVE_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPV6_MULTICAST_HOPS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_MULTICAST_HOPS"</expr></argument>, <argument><expr><name>IPV6_MULTICAST_HOPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPV6_MULTICAST_IF</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_MULTICAST_IF"</expr></argument>, <argument><expr><name>IPV6_MULTICAST_IF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPV6_MULTICAST_LOOP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_MULTICAST_LOOP"</expr></argument>, <argument><expr><name>IPV6_MULTICAST_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPV6_UNICAST_HOPS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_UNICAST_HOPS"</expr></argument>, <argument><expr><name>IPV6_UNICAST_HOPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Additional IPV6 socket options, defined in RFC 3493 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_V6ONLY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_V6ONLY"</expr></argument>, <argument><expr><name>IPV6_V6ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Advanced IPV6 socket options, from RFC 3542 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_CHECKSUM</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_CHECKSUM"</expr></argument>, <argument><expr><name>IPV6_CHECKSUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_DONTFRAG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_DONTFRAG"</expr></argument>, <argument><expr><name>IPV6_DONTFRAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_DSTOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_DSTOPTS"</expr></argument>, <argument><expr><name>IPV6_DSTOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_HOPLIMIT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_HOPLIMIT"</expr></argument>, <argument><expr><name>IPV6_HOPLIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_HOPOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_HOPOPTS"</expr></argument>, <argument><expr><name>IPV6_HOPOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_NEXTHOP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_NEXTHOP"</expr></argument>, <argument><expr><name>IPV6_NEXTHOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_PATHMTU</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_PATHMTU"</expr></argument>, <argument><expr><name>IPV6_PATHMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_PKTINFO</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_PKTINFO"</expr></argument>, <argument><expr><name>IPV6_PKTINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RECVDSTOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVDSTOPTS"</expr></argument>, <argument><expr><name>IPV6_RECVDSTOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RECVHOPLIMIT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVHOPLIMIT"</expr></argument>, <argument><expr><name>IPV6_RECVHOPLIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RECVHOPOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVHOPOPTS"</expr></argument>, <argument><expr><name>IPV6_RECVHOPOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RECVPKTINFO</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVPKTINFO"</expr></argument>, <argument><expr><name>IPV6_RECVPKTINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RECVRTHDR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVRTHDR"</expr></argument>, <argument><expr><name>IPV6_RECVRTHDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RECVTCLASS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVTCLASS"</expr></argument>, <argument><expr><name>IPV6_RECVTCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RTHDR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RTHDR"</expr></argument>, <argument><expr><name>IPV6_RTHDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RTHDRDSTOPTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RTHDRDSTOPTS"</expr></argument>, <argument><expr><name>IPV6_RTHDRDSTOPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RTHDR_TYPE_0</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RTHDR_TYPE_0"</expr></argument>, <argument><expr><name>IPV6_RTHDR_TYPE_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_RECVPATHMTU</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_RECVPATHMTU"</expr></argument>, <argument><expr><name>IPV6_RECVPATHMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_TCLASS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_TCLASS"</expr></argument>, <argument><expr><name>IPV6_TCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPV6_USE_MIN_MTU</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPV6_USE_MIN_MTU"</expr></argument>, <argument><expr><name>IPV6_USE_MIN_MTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* TCP options */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_NODELAY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_NODELAY"</expr></argument>, <argument><expr><name>TCP_NODELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_MAXSEG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_MAXSEG"</expr></argument>, <argument><expr><name>TCP_MAXSEG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_CORK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_CORK"</expr></argument>, <argument><expr><name>TCP_CORK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_KEEPIDLE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_KEEPIDLE"</expr></argument>, <argument><expr><name>TCP_KEEPIDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_KEEPINTVL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_KEEPINTVL"</expr></argument>, <argument><expr><name>TCP_KEEPINTVL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_KEEPCNT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_KEEPCNT"</expr></argument>, <argument><expr><name>TCP_KEEPCNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_SYNCNT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_SYNCNT"</expr></argument>, <argument><expr><name>TCP_SYNCNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_LINGER2</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_LINGER2"</expr></argument>, <argument><expr><name>TCP_LINGER2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_DEFER_ACCEPT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_DEFER_ACCEPT"</expr></argument>, <argument><expr><name>TCP_DEFER_ACCEPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_WINDOW_CLAMP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_WINDOW_CLAMP"</expr></argument>, <argument><expr><name>TCP_WINDOW_CLAMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_INFO</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_INFO"</expr></argument>, <argument><expr><name>TCP_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_QUICKACK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"TCP_QUICKACK"</expr></argument>, <argument><expr><name>TCP_QUICKACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


	<comment type="block">/* IPX options */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>IPX_TYPE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"IPX_TYPE"</expr></argument>, <argument><expr><name>IPX_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* get{addr,name}info parameters */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_ADDRFAMILY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_ADDRFAMILY"</expr></argument>, <argument><expr><name>EAI_ADDRFAMILY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_AGAIN</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_AGAIN"</expr></argument>, <argument><expr><name>EAI_AGAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_BADFLAGS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_BADFLAGS"</expr></argument>, <argument><expr><name>EAI_BADFLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_FAIL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_FAIL"</expr></argument>, <argument><expr><name>EAI_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_FAMILY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_FAMILY"</expr></argument>, <argument><expr><name>EAI_FAMILY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_MEMORY</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_MEMORY"</expr></argument>, <argument><expr><name>EAI_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_NODATA</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_NODATA"</expr></argument>, <argument><expr><name>EAI_NODATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_NONAME</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_NONAME"</expr></argument>, <argument><expr><name>EAI_NONAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_OVERFLOW</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_OVERFLOW"</expr></argument>, <argument><expr><name>EAI_OVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_SERVICE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_SERVICE"</expr></argument>, <argument><expr><name>EAI_SERVICE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_SOCKTYPE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_SOCKTYPE"</expr></argument>, <argument><expr><name>EAI_SOCKTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_SYSTEM</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_SYSTEM"</expr></argument>, <argument><expr><name>EAI_SYSTEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_BADHINTS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_BADHINTS"</expr></argument>, <argument><expr><name>EAI_BADHINTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_PROTOCOL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_PROTOCOL"</expr></argument>, <argument><expr><name>EAI_PROTOCOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAI_MAX</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EAI_MAX"</expr></argument>, <argument><expr><name>EAI_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_PASSIVE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_PASSIVE"</expr></argument>, <argument><expr><name>AI_PASSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_CANONNAME</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_CANONNAME"</expr></argument>, <argument><expr><name>AI_CANONNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_NUMERICHOST</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_NUMERICHOST"</expr></argument>, <argument><expr><name>AI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_NUMERICSERV</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_NUMERICSERV"</expr></argument>, <argument><expr><name>AI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_MASK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_MASK"</expr></argument>, <argument><expr><name>AI_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_ALL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_ALL"</expr></argument>, <argument><expr><name>AI_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_V4MAPPED_CFG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_V4MAPPED_CFG"</expr></argument>, <argument><expr><name>AI_V4MAPPED_CFG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_ADDRCONFIG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_ADDRCONFIG"</expr></argument>, <argument><expr><name>AI_ADDRCONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_V4MAPPED</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_V4MAPPED"</expr></argument>, <argument><expr><name>AI_V4MAPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_DEFAULT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"AI_DEFAULT"</expr></argument>, <argument><expr><name>AI_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NI_MAXHOST</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_MAXHOST"</expr></argument>, <argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NI_MAXSERV</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_MAXSERV"</expr></argument>, <argument><expr><name>NI_MAXSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NI_NOFQDN</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_NOFQDN"</expr></argument>, <argument><expr><name>NI_NOFQDN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NI_NUMERICHOST</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_NUMERICHOST"</expr></argument>, <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NI_NAMEREQD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_NAMEREQD"</expr></argument>, <argument><expr><name>NI_NAMEREQD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NI_NUMERICSERV</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_NUMERICSERV"</expr></argument>, <argument><expr><name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NI_DGRAM</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NI_DGRAM"</expr></argument>, <argument><expr><name>NI_DGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* shutdown() parameters */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHUT_RD</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RD"</expr></argument>, <argument><expr><name>SHUT_RD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SD_RECEIVE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RD"</expr></argument>, <argument><expr><name>SD_RECEIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RD"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHUT_WR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_WR"</expr></argument>, <argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SD_SEND</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_WR"</expr></argument>, <argument><expr><name>SD_SEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_WR"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHUT_RDWR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RDWR"</expr></argument>, <argument><expr><name>SHUT_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SD_BOTH</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RDWR"</expr></argument>, <argument><expr><name>SD_BOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SHUT_RDWR"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIO_RCVALL</name></cpp:ifdef>
	<block>{
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>tmp</name> = <call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>SIO_RCVALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
			<return>return;</return></then></if>
		<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"SIO_RCVALL"</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_OFF"</expr></argument>, <argument><expr><name>RCVALL_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_ON"</expr></argument>, <argument><expr><name>RCVALL_ON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_SOCKETLEVELONLY"</expr></argument>, <argument><expr><name>RCVALL_SOCKETLEVELONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RCVALL_IPLEVEL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_IPLEVEL"</expr></argument>, <argument><expr><name>RCVALL_IPLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RCVALL_MAX</name></cpp:ifdef>
	<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"RCVALL_MAX"</expr></argument>, <argument><expr><name>RCVALL_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _MSTCPIP_ */</comment>

	<comment type="block">/* Initialize gethostbyname lock */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETHOSTBYNAME_LOCK</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>USE_GETADDRINFO_LOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>netdb_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_INET_PTON</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NTDDI_VERSION</name></expr></argument>)</argument_list></call> || (<name>NTDDI_VERSION</name> &lt; <name>NTDDI_LONGHORN</name>)</expr></cpp:if>

<comment type="block">/* Simplistic emulation code for inet_pton that only works for IPv4 */</comment>
<comment type="block">/* These are not exposed because they do not set errno properly */</comment>

<function><type><name>int</name></type>
<name>inet_pton</name><parameter_list>(<param><decl><type><name>int</name></type> <name>af</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dst</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>af</name> == <name>AF_INET</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>long</name></type> <name>packed_addr</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>packed_addr</name> = <call><name>inet_addr</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>packed_addr</name> == <name>INADDR_NONE</name></expr>)</condition><then>
			<return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>&amp;<name>packed_addr</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<comment type="block">/* Should set errno to EAFNOSUPPORT */</comment>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>inet_ntop</name><parameter_list>(<param><decl><type><name>int</name></type> <name>af</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>src</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>socklen_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>af</name> == <name>AF_INET</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type>struct <name>in_addr</name></type> <name>packed_addr</name></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>size</name> &lt; 16</expr>)</condition><then>
			<comment type="block">/* Should set errno to ENOSPC. */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>packed_addr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>strncpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><call><name>inet_ntoa</name><argument_list>(<argument><expr><name>packed_addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
	<comment type="block">/* Should set errno to EAFNOSUPPORT */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function></block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
