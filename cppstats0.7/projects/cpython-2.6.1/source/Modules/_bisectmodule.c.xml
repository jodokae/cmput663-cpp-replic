<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/_bisectmodule.c"><comment type="block">/* Bisection algorithms. Drop in replacement for bisect.py

Converted to C by Dmitry Vasiliev (dima at hlabs.spb.ru).
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>internal_bisect_right</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>lo</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>hi</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>litem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mid</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>lo</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"lo must be non-negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>hi</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hi</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hi</name> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<while>while <condition>(<expr><name>lo</name> &lt; <name>hi</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>mid</name> = (<name>lo</name> + <name>hi</name>) / 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>litem</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>litem</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>litem</name></expr></argument>, <argument><expr><name>Py_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>litem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>res</name></expr>)</condition><then>
			<expr_stmt><expr><name>hi</name> = <name>mid</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>lo</name> = <name>mid</name> + 1</expr>;</expr_stmt></else></if>
	}</block></while>
	<return>return <expr><name>lo</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bisect_right</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>hi</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"a"</expr>, <expr>"x"</expr>, <expr>"lo"</expr>, <expr>"hi"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"OO|nn:bisect_right"</expr></argument>,
		<argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>, <argument><expr>&amp;<name>lo</name></expr></argument>, <argument><expr>&amp;<name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>index</name> = <call><name>internal_bisect_right</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bisect_right_doc</name></expr></argument>,
<argument><expr>"bisect_right(a, x[, lo[, hi]]) -&gt; index\n\
\n\
Return the index where to insert item x in list a, assuming a is sorted.\n\
\n\
The return value i is such that all e in a[:i] have e &lt;= x, and all e in\n\
a[i:] have e &gt; x.  So if x already appears in the list, i points just\n\
beyond the rightmost x already there\n\
\n\
Optional args lo (default 0) and hi (default len(a)) bound the\n\
slice of a to be searched.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>insort_right</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>hi</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"a"</expr>, <expr>"x"</expr>, <expr>"lo"</expr>, <expr>"hi"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"OO|nn:insort_right"</expr></argument>,
		<argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>, <argument><expr>&amp;<name>lo</name></expr></argument>, <argument><expr>&amp;<name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>index</name> = <call><name>internal_bisect_right</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyList_Insert</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>"insert"</expr></argument>, <argument><expr>"nO"</expr></argument>,
					     <argument><expr><name>index</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>insort_right_doc</name></expr></argument>,
<argument><expr>"insort_right(a, x[, lo[, hi]])\n\
\n\
Insert item x in list a, and keep it sorted assuming a is sorted.\n\
\n\
If x is already in a, insert it to the right of the rightmost x.\n\
\n\
Optional args lo (default 0) and hi (default len(a)) bound the\n\
slice of a to be searched.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>internal_bisect_left</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>item</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>lo</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>hi</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>litem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>mid</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>lo</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"lo must be non-negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name>hi</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>hi</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hi</name> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
	}</block></then></if>
	<while>while <condition>(<expr><name>lo</name> &lt; <name>hi</name></expr>)</condition> <block>{
		<expr_stmt><expr><name>mid</name> = (<name>lo</name> + <name>hi</name>) / 2</expr>;</expr_stmt>
		<expr_stmt><expr><name>litem</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>litem</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>res</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name>litem</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>Py_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>litem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
			<return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>res</name></expr>)</condition><then>
			<expr_stmt><expr><name>lo</name> = <name>mid</name> + 1</expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>hi</name> = <name>mid</name></expr>;</expr_stmt></else></if>
	}</block></while>
	<return>return <expr><name>lo</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bisect_left</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>hi</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"a"</expr>, <expr>"x"</expr>, <expr>"lo"</expr>, <expr>"hi"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"OO|nn:bisect_left"</expr></argument>,
		<argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>, <argument><expr>&amp;<name>lo</name></expr></argument>, <argument><expr>&amp;<name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>index</name> = <call><name>internal_bisect_left</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bisect_left_doc</name></expr></argument>,
<argument><expr>"bisect_left(a, x[, lo[, hi]]) -&gt; index\n\
\n\
Return the index where to insert item x in list a, assuming a is sorted.\n\
\n\
The return value i is such that all e in a[:i] have e &lt; x, and all e in\n\
a[i:] have e &gt;= x.  So if x already appears in the list, i points just\n\
before the leftmost x already there.\n\
\n\
Optional args lo (default 0) and hi (default len(a)) bound the\n\
slice of a to be searched.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>insort_left</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>lo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>hi</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{<expr>"a"</expr>, <expr>"x"</expr>, <expr>"lo"</expr>, <expr>"hi"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr>"OO|nn:insort_left"</expr></argument>,
		<argument><expr><name>keywords</name></expr></argument>, <argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>&amp;<name>item</name></expr></argument>, <argument><expr>&amp;<name>lo</name></expr></argument>, <argument><expr>&amp;<name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>index</name> = <call><name>internal_bisect_left</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyList_Insert</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>"insert"</expr></argument>, <argument><expr>"iO"</expr></argument>,
					     <argument><expr><name>index</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>insort_left_doc</name></expr></argument>,
<argument><expr>"insort_left(a, x[, lo[, hi]])\n\
\n\
Insert item x in list a, and keep it sorted assuming a is sorted.\n\
\n\
If x is already in a, insert it to the left of the leftmost x.\n\
\n\
Optional args lo (default 0) and hi (default len(a)) bound the\n\
slice of a to be searched.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>bisect_doc</name></expr></argument>, <argument><expr>"Alias for bisect_right().\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>insort_doc</name></expr></argument>, <argument><expr>"Alias for insort_right().\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>bisect_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr>"bisect_right"</expr>, <expr>(<name>PyCFunction</name>)<name>bisect_right</name></expr>,
		<expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>bisect_right_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"bisect"</expr>, <expr>(<name>PyCFunction</name>)<name>bisect_right</name></expr>,
		<expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>bisect_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"insort_right"</expr>, <expr>(<name>PyCFunction</name>)<name>insort_right</name></expr>,
		<expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>insort_right_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"insort"</expr>, <expr>(<name>PyCFunction</name>)<name>insort_right</name></expr>,
		<expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>insort_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"bisect_left"</expr>, <expr>(<name>PyCFunction</name>)<name>bisect_left</name></expr>,
		<expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>bisect_left_doc</name></expr>}</block></expr>,
	<expr><block>{<expr>"insort_left"</expr>, <expr>(<name>PyCFunction</name>)<name>insort_left</name></expr>,
		<expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>insort_left_doc</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr> <comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"Bisection algorithms.\n\
\n\
This module provides support for maintaining a list in sorted order without\n\
having to sort the list after each insertion. For long lists of items with\n\
expensive comparison operations, this can be an improvement over the more\n\
common approach.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_bisect</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_bisect"</expr></argument>, <argument><expr><name>bisect_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
