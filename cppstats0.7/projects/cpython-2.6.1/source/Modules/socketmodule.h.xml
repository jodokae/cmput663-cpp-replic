<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/socketmodule.h"><comment type="block">/* Socket module header file */</comment>

<comment type="block">/* Includes needed for the sockaddr_* symbols below */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;socket.h&gt;</cpp:file></cpp:include>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:if># <cpp:directive>if</cpp:directive> <expr>!(<call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> || (<call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call>))</expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* MS_WINDOWS */</comment>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;ws2tcpip.h&gt;</cpp:file></cpp:include>
<comment type="block">/* VC6 is shipped with old platform headers, and does not have MSTcpIP.h
 * Separate SDKs have all the functions we want, but older ones don't have
 * any version information. 
 * I use SIO_GET_MULTICAST_FILTER to detect a decent SDK.
 */</comment>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>SIO_GET_MULTICAST_FILTER</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;MSTcpIP.h&gt;</cpp:file></cpp:include> <comment type="block">/* for SIO_RCVALL */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_ADDRINFO</name></cpp:macro></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SOCKADDR_STORAGE</name></cpp:macro></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETADDRINFO</name></cpp:macro></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_GETNAMEINFO</name></cpp:macro></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_IPV6</name></cpp:macro></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>int</name></type> <name>socklen_t</name>;</typedef>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* IPPROTO_IPV6 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_UN_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/un.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>AF_UNIX</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_NETLINK_H</name></cpp:ifdef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>HAVE_ASM_TYPES_H</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;asm/types.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/netlink.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>AF_NETLINK</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BLUETOOTH_BLUETOOTH_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bluetooth/bluetooth.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bluetooth/rfcomm.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bluetooth/l2cap.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bluetooth/sco.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bluetooth/hci.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BLUETOOTH_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bluetooth.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETPACKET_PACKET_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;net/if.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;netpacket/packet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_TIPC_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/tipc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py__SOCKET_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py__SOCKET_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Python module and C API name */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySocket_MODULE_NAME</name></cpp:macro>	<cpp:value>"_socket"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySocket_CAPI_NAME</name></cpp:macro>	<cpp:value>"CAPI"</cpp:value></cpp:define>

<comment type="block">/* Abstract the socket file descriptor type */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<typedef>typedef <type><name>SOCKET</name></type> <name>SOCKET_T</name>;</typedef>
<cpp:ifdef>#	<cpp:directive>ifdef</cpp:directive> <name>MS_WIN64</name></cpp:ifdef>
<cpp:define>#		<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_SOCKET_T</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:else>#	<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#		<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_SOCKET_T</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#	<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>int</name></type> <name>SOCKET_T</name>;</typedef>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_SOCKET_T</name></cpp:macro> <cpp:value>SIZEOF_INT</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Socket address */</comment>
<typedef>typedef <type><union>union <name>sock_addr</name> <block>{
	<decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>in</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_UNIX</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>sockaddr_un</name></type> <name>un</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_NETLINK</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>sockaddr_nl</name></type> <name>nl</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IPV6</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>sockaddr_in6</name></type> <name>in6</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>sockaddr_storage</name></type> <name>storage</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BLUETOOTH_BLUETOOTH_H</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>sockaddr_l2</name></type> <name>bt_l2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>sockaddr_rc</name></type> <name>bt_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>sockaddr_sco</name></type> <name>bt_sco</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>sockaddr_hci</name></type> <name>bt_hci</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETPACKET_PACKET_H</name></cpp:ifdef>
	<decl_stmt><decl><type>struct <name>sockaddr_ll</name></type> <name>ll</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></union></type> <name>sock_addr_t</name>;</typedef>

<comment type="block">/* The object holding a socket.  It holds some extra information,
   like the address family, which is used to decode socket address
   arguments properly. */</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>SOCKET_T</name></type> <name>sock_fd</name></decl>;</decl_stmt>	<comment type="block">/* Socket file descriptor */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>sock_family</name></decl>;</decl_stmt>	<comment type="block">/* Address family, e.g., AF_INET */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>sock_type</name></decl>;</decl_stmt>		<comment type="block">/* Socket type, e.g., SOCK_STREAM */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>sock_proto</name></decl>;</decl_stmt>		<comment type="block">/* Protocol type, usually 0 */</comment>
	<function_decl><type><name>PyObject</name> *</type>(*<name>errorhandler</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Error handler; checks
					    errno, returns NULL and
					    sets a Python exception */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>sock_timeout</name></decl>;</decl_stmt>		 <comment type="block">/* Operation timeout in seconds;
					    0.0 means non-blocking */</comment>
}</block></struct></type> <name>PySocketSockObject</name>;</typedef>

<comment type="block">/* --- C API ----------------------------------------------------*/</comment>

<comment type="block">/* Short explanation of what this C API export mechanism does
   and how it works:

    The _ssl module needs access to the type object defined in 
    the _socket module. Since cross-DLL linking introduces a lot of
    problems on many platforms, the "trick" is to wrap the
    C API of a module in a struct which then gets exported to
    other modules via a PyCObject.

    The code in socketmodule.c defines this struct (which currently
    only contains the type object reference, but could very
    well also include other C APIs needed by other modules)
    and exports it as PyCObject via the module dictionary
    under the name "CAPI".

    Other modules can now include the socketmodule.h file
    which defines the needed C APIs to import and set up
    a static copy of this struct in the importing module.

    After initialization, the importing module can then
    access the C APIs from the _socket module by simply
    referring to the static struct, e.g.

    Load _socket module and its C API; this sets up the global
    PySocketModule:
    
	if (PySocketModule_ImportModuleAndAPI())
	    return;


    Now use the C API as if it were defined in the using
    module:

        if (!PyArg_ParseTuple(args, "O!|zz:ssl",

			      PySocketModule.Sock_Type,

			      (PyObject*)&amp;Sock,
			      &amp;key_file, &amp;cert_file))
	    return NULL;

    Support could easily be extended to export more C APIs/symbols
    this way. Currently, only the type object is exported, 
    other candidates would be socket constructors and socket
    access functions.

*/</comment>

<comment type="block">/* C API for usage by other Python modules */</comment>
<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name>Sock_Type</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>error</name></decl>;</decl_stmt>
}</block></struct></type> <name>PySocketModule_APIObject</name>;</typedef>

<comment type="block">/* XXX The net effect of the following appears to be to define a function
   XXX named PySocketModule_APIObject in _ssl.c.  It's unclear why it isn't
   XXX defined there directly. 

   &gt;&gt;&gt; It's defined here because other modules might also want to use
   &gt;&gt;&gt; the C API.

*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PySocket_BUILDING_SOCKET</name></cpp:ifndef>

<comment type="block">/* --- C API ----------------------------------------------------*/</comment>

<comment type="block">/* Interfacestructure to C API for other modules.
   Call PySocketModule_ImportModuleAndAPI() to initialize this
   structure. After that usage is simple:

   if (!PyArg_ParseTuple(args, "O!|zz:ssl",
                         &amp;PySocketModule.Sock_Type, (PyObject*)&amp;Sock,
	 		 &amp;key_file, &amp;cert_file))
 	 return NULL;
   ...
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier>
<name>PySocketModule_APIObject</name></type> <name>PySocketModule</name></decl>;</decl_stmt>

<comment type="block">/* You *must* call this before using any of the functions in
   PySocketModule and check its outcome; otherwise all accesses will
   result in a segfault. Returns 0 on success. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DPRINTF</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DPRINTF</name></cpp:macro> <cpp:value>if (0) printf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier>
<name>int</name></type> <name>PySocketModule_ImportModuleAndAPI</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name> <init>= <expr>0</expr></init>, *<name>v</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>apimodule</name> <init>= <expr><name>PySocket_MODULE_NAME</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>apiname</name> <init>= <expr><name>PySocket_CAPI_NAME</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> *</type><name>api</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr>"Importing the %s C API...\n"</expr></argument>, <argument><expr><name>apimodule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mod</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr><name>apimodule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr>" %s package found\n"</expr></argument>, <argument><expr><name>apimodule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>apiname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr>" API object %s found\n"</expr></argument>, <argument><expr><name>apiname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>api</name> = <call><name>PyCObject_AsVoidPtr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>api</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>onError</name>;</goto></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>PySocketModule</name></expr></argument>, <argument><expr><name>api</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PySocketModule</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr>" API object loaded and initialized.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>

 <label><name>onError</name>:</label>
	<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr>" not found.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !PySocket_BUILDING_SOCKET */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py__SOCKET_H */</comment>
</unit>
