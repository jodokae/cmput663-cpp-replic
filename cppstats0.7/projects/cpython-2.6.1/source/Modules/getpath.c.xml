<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Modules/getpath.c"><comment type="block">/* Return the initial module search path. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/dyld.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Search in some common locations for the associated Python libraries.
 *
 * Two directories must be found, the platform independent directory
 * (prefix), containing the common .py and .pyc files, and the platform
 * dependent directory (exec_prefix), containing the shared library
 * modules.  Note that prefix and exec_prefix can be the same directory,
 * but for some installations, they are different.
 *
 * Py_GetPath() carries out separate searches for prefix and exec_prefix.
 * Each search tries a number of different locations until a ``landmark''
 * file or directory is found.  If no prefix or exec_prefix is found, a
 * warning message is issued and the preprocessor defined PREFIX and
 * EXEC_PREFIX are used (even though they will not work); python carries on
 * as best as is possible, but most imports will fail.
 *
 * Before any searches are done, the location of the executable is
 * determined.  If argv[0] has one or more slashes in it, it is used
 * unchanged.  Otherwise, it must have been invoked from the shell's path,
 * so we search $PATH for the named executable and use that.  If the
 * executable was not found on $PATH (or there was no $PATH environment
 * variable), the original argv[0] string is used.
 *
 * Next, the executable location is examined to see if it is a symbolic
 * link.  If so, the link is chased (correctly interpreting a relative
 * pathname if one is found) and the directory of the link target is used.
 *
 * Finally, argv0_path is set to the directory containing the executable
 * (i.e. the last component is stripped).
 *
 * With argv0_path in hand, we perform a number of steps.  The same steps
 * are performed for prefix and for exec_prefix, but with a different
 * landmark.
 *
 * Step 1. Are we running python out of the build directory?  This is
 * checked by looking for a different kind of landmark relative to
 * argv0_path.  For prefix, the landmark's path is derived from the VPATH
 * preprocessor variable (taking into account that its value is almost, but
 * not quite, what we need).  For exec_prefix, the landmark is
 * Modules/Setup.  If the landmark is found, we're done.
 *
 * For the remaining steps, the prefix landmark will always be
 * lib/python$VERSION/os.py and the exec_prefix will always be
 * lib/python$VERSION/lib-dynload, where $VERSION is Python's version
 * number as supplied by the Makefile.  Note that this means that no more
 * build directory checking is performed; if the first step did not find
 * the landmarks, the assumption is that python is running from an
 * installed setup.
 *
 * Step 2. See if the $PYTHONHOME environment variable points to the
 * installed location of the Python libraries.  If $PYTHONHOME is set, then
 * it points to prefix and exec_prefix.  $PYTHONHOME can be a single
 * directory, which is used for both, or the prefix and exec_prefix
 * directories separated by a colon.
 *
 * Step 3. Try to find prefix and exec_prefix relative to argv0_path,
 * backtracking up the path until it is exhausted.  This is the most common
 * step to succeed.  Note that if prefix and exec_prefix are different,
 * exec_prefix is more likely to be found; however if exec_prefix is a
 * subdirectory of prefix, both will be found.
 *
 * Step 4. Search the directories pointed to by the preprocessor variables
 * PREFIX and EXEC_PREFIX.  These are supplied by the Makefile but can be
 * passed in as options to the configure script.
 *
 * That's it!
 *
 * Well, almost.  Once we have determined prefix and exec_prefix, the
 * preprocessor variable PYTHONPATH is used to construct a path.  Each
 * relative path on PYTHONPATH is prefixed with prefix.  Then the directory
 * containing the shared library modules is appended.  The environment
 * variable $PYTHONPATH is inserted in front of it all.  Finally, the
 * prefix and exec_prefix globals are tweaked so they reflect the values
 * expected by other code, by stripping the "lib/python$VERSION/..." stuff
 * off.  If either points to the build directory, the globals are reset to
 * the corresponding preprocessor variables (so sys.prefix will reflect the
 * installation location, even though sys.path points into the build
 * directory).  This seems to make more sense given that currently the only
 * known use of sys.prefix and sys.exec_prefix is for the ILU installation
 * process to find the installed Python tree.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
 <extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>VERSION</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION</name></cpp:macro> <cpp:value>"2.1"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>VPATH</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VPATH</name></cpp:macro> <cpp:value>"."</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PREFIX</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name></cpp:macro> <cpp:value>"/usr/local"</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_PREFIX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_PREFIX</name></cpp:macro> <cpp:value>PREFIX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PYTHONPATH</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYTHONPATH</name></cpp:macro> <cpp:value>PREFIX "/lib/python" VERSION ":" \
              EXEC_PREFIX "/lib/python" VERSION "/lib-dynload"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LANDMARK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANDMARK</name></cpp:macro> <cpp:value>"os.py"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>prefix</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>exec_prefix</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>progpath</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>module_search_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lib_python</name><index>[]</index></name> <init>= <expr>"lib/python" <name>VERSION</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>reduce</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>dir</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name> != <name>SEP</name></expr>)</condition>
        <expr_stmt><expr>--<name>i</name></expr>;</expr_stmt></while>
    <expr_stmt><expr><name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>isfile</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>          <comment type="block">/* Is file, not directory */</comment>
<block>{
    <decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>ismodule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>        <comment type="block">/* Is module -- check for .pyc/.pyo too */</comment>
<block>{
    <if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>1</expr>;</return></then></if>

    <comment type="block">/* Check for the compiled version of prefix. */</comment>
    <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> &lt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Py_OptimizeFlag</name> ? "o" : "c"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>1</expr>;</return></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>isxfile</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>         <comment type="block">/* Is executable file */</comment>
<block>{
    <decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr>(<name><name>buf</name>.<name>st_mode</name></name> &amp; 0111) == 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>isdir</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list>                   <comment type="block">/* Is directory */</comment>
<block>{
    <decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>


<comment type="block">/* Add a path component, by appending stuff to buffer.
   buffer must have at least MAXPATHLEN + 1 bytes allocated, and contain a
   NUL-terminated string with no more than MAXPATHLEN characters (not counting
   the trailing NUL).  It's a fatal error if it contains a string longer than
   that (callers must be careful!).  If these requirements are met, it's
   guaranteed that buffer will still be a NUL-terminated string with no more
   than MAXPATHLEN characters at exit.  If stuff is too long, only as much of
   stuff as fits will be appended.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>joinpath</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>char</name> *</type><name>stuff</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>stuff</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
        <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
    <else>else <block>{
        <expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; <name><name>buffer</name><index>[<expr><name>n</name>-1</expr>]</index></name> != <name>SEP</name> &amp;&amp; <name>n</name> &lt; <name>MAXPATHLEN</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
    }</block></else></if>
    <if>if <condition>(<expr><name>n</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
    	<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"buffer overflow in getpath.c's joinpath()"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>k</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>stuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>n</name> + <name>k</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
        <expr_stmt><expr><name>k</name> = <name>MAXPATHLEN</name> - <name>n</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name>+<name>n</name></expr></argument>, <argument><expr><name>stuff</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>+<name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* copy_absolute requires that path be allocated at least
   MAXPATHLEN + 1 bytes and that p be no more than MAXPATHLEN bytes. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_absolute</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>getcwd</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <name><name>p</name><index>[<expr>1</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
            <expr_stmt><expr><name>p</name> += 2</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/* absolutize() requires that path be allocated at least MAXPATHLEN+1 bytes. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>absolutize</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>MAXPATHLEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>path</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><call><name>copy_absolute</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* search_for_prefix requires that argv0_path be no more than MAXPATHLEN
   bytes long.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>search_for_prefix</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>argv0_path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>home</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>vpath</name></decl>;</decl_stmt>

    <comment type="block">/* If PYTHONHOME is set, we believe it unconditionally */</comment>
    <if>if <condition>(<expr><name>home</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>delim</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>delim</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>delim</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>delim</name> = '\0'</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Check to see if argv[0] is in the build directory */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"Modules/Setup"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Check VPATH to see if argv0_path is in the build directory. */</comment>
        <expr_stmt><expr><name>vpath</name> = <name>VPATH</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>vpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"Lib"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>ismodule</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
    }</block></then></if>

    <comment type="block">/* Search from argv0_path, until root is found */</comment>
    <expr_stmt><expr><call><name>copy_absolute</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{
        <expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>ismodule</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>1</expr>;</return></then></if>
        <expr_stmt><expr><name><name>prefix</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name><name>prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition>;</do>

    <comment type="block">/* Look at configure's PREFIX */</comment>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ismodule</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>1</expr>;</return></then></if>

    <comment type="block">/* Fail */</comment>
    <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* search_for_exec_prefix requires that argv0_path be no more than
   MAXPATHLEN bytes long.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>search_for_exec_prefix</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>argv0_path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>home</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>

    <comment type="block">/* If PYTHONHOME is set, we believe it unconditionally */</comment>
    <if>if <condition>(<expr><name>home</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>delim</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>delim</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>home</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>delim</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>delim</name>+1</expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"lib-dynload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Check to see if argv[0] is in the build directory */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"Modules/Setup"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Search from argv0_path, until root is found */</comment>
    <expr_stmt><expr><call><name>copy_absolute</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{
        <expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"lib-dynload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>1</expr>;</return></then></if>
        <expr_stmt><expr><name><name>exec_prefix</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name><name>exec_prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition>;</do>

    <comment type="block">/* Look at configure's EXEC_PREFIX */</comment>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>EXEC_PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"lib-dynload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>1</expr>;</return></then></if>

    <comment type="block">/* Fail */</comment>
    <return>return <expr>0</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>calculate_path</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>Py_GetProgramName</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>delimiter</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr><name>DELIM</name></expr>, <expr>'\0'</expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>separator</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr><name>SEP</name></expr>, <expr>'\0'</expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>pythonpath</name> <init>= <expr><name>PYTHONPATH</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>rtpypath</name> <init>= <expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONPATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>home</name> <init>= <expr><call><name>Py_GetPythonHome</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"PATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>prog</name> <init>= <expr><call><name>Py_GetProgramName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>argv0_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zip_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pfound</name></decl>, <decl><type ref="prev"/><name>efound</name></decl>;</decl_stmt> <comment type="block">/* 1 if found; -1 if found build directory */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bufsz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>prefixsz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>defpath</name> <init>= <expr><name>pythonpath</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_NEXT_FRAMEWORK</name></cpp:ifdef>
    <decl_stmt><decl><type><name>NSModule</name></type> <name>pythonModule</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAC_OS_X_VERSION_MAX_ALLOWED</name> &gt;= <name>MAC_OS_X_VERSION_10_4</name></expr></cpp:if>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nsexeclength</name> <init>= <expr><name>MAXPATHLEN</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>nsexeclength</name> <init>= <expr><name>MAXPATHLEN</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* If there is no slash in the argv0 path, then we have to
	 * assume python is on the user's $PATH, since there's no
	 * other way to find a directory to start the search from.  If
	 * $PATH isn't exported, you lose.
	 */</comment>
	<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
     <comment type="block">/* On Mac OS X, if a script uses an interpreter of the form
      * "#!/opt/python2.3/bin/python", the kernel only passes "python"
      * as argv[0], which falls through to the $PATH search below.
      * If /opt/python2.3/bin isn't in your path, or is near the end,
      * this algorithm may incorrectly find /usr/bin/python. To work
      * around this, we can use _NSGetExecutablePath to get a better
      * hint of what the intended interpreter was, although this
      * will fail if a relative path was used. but in that case,
      * absolutize() should help us out below
      */</comment>
     <else>else <if>if<condition>(<expr>0 == <call><name>_NSGetExecutablePath</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr>&amp;<name>nsexeclength</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>progpath</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
       <empty_stmt>;</empty_stmt></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __APPLE__ */</comment>
	<else>else <if>if <condition>(<expr><name>path</name></expr>)</condition><then> <block>{
		<while>while <condition>(<expr>1</expr>)</condition> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if>if <condition>(<expr><name>delim</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>delim</name> - <name>path</name></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>len</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
					<expr_stmt><expr><name>len</name> = <name>MAXPATHLEN</name></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>*(<name>progpath</name> + <name>len</name>) = '\0'</expr>;</expr_stmt>
			}</block></then>
			<else>else
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

			<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>isxfile</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<break>break;</break></then></if>

			<if>if <condition>(<expr>!<name>delim</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<expr_stmt><expr><name>path</name> = <name>delim</name> + 1</expr>;</expr_stmt>
		}</block></while>
	}</block></then>
	<else>else
		<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></else></if></else></if></else></if>
	<if>if <condition>(<expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> != <name>SEP</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>absolutize</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argv0_path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_NEXT_FRAMEWORK</name></cpp:ifdef>
	<comment type="block">/* On Mac OS X we have a special case if we're running from a framework.
	** This is because the python home should be set relative to the library,
	** which is in the framework, not relative to the executable, which may
	** be outside of the framework. Except when we're in the build directory...
	*/</comment>
    <expr_stmt><expr><name>pythonModule</name> = <call><name>NSModuleForSymbol</name><argument_list>(<argument><expr><call><name>NSLookupAndBindSymbol</name><argument_list>(<argument><expr>"_Py_Initialize"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Use dylib functions to find out where the framework was loaded from */</comment>
    <expr_stmt><expr><name>buf</name> = (<name>char</name> *)<call><name>NSLibraryNameForModule</name><argument_list>(<argument><expr><name>pythonModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>buf</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* We're in a framework. */</comment>
        <comment type="block">/* See if we might be in the build directory. The framework in the
        ** build directory is incomplete, it only has the .dylib and a few
        ** needed symlinks, it doesn't have the Lib directories and such.
        ** If we're running with the framework from the build directory we must
        ** be running the interpreter in the build directory, so we use the
        ** build-directory-specific logic to find Lib and such.
        */</comment>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>ismodule</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* We are in the build directory so use the name of the
                   executable - we know that the absolute path is passed */</comment>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
                <comment type="block">/* Use the location of the library as the progpath */</comment>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_READLINK</name></expr></cpp:if>
    <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>tmpbuffer</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>linklen</name> <init>= <expr><call><name>readlink</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>tmpbuffer</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>linklen</name> != -1</expr>)</condition> <block>{
            <comment type="block">/* It's not null terminated! */</comment>
            <expr_stmt><expr><name><name>tmpbuffer</name><index>[<expr><name>linklen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>tmpbuffer</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
                <comment type="block">/* tmpbuffer should never be longer than MAXPATHLEN,
                   but extra check does not hurt */</comment>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>tmpbuffer</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <block>{
                <comment type="block">/* Interpret relative to progpath */</comment>
                <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>tmpbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>linklen</name> = <call><name>readlink</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>tmpbuffer</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_READLINK */</comment>

    <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* At this point, argv0_path is guaranteed to be less than
       MAXPATHLEN bytes long.
    */</comment>

    <if>if <condition>(<expr>!(<name>pfound</name> = <call><name>search_for_prefix</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>home</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>Py_FrozenFlag</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr>"Could not find platform independent libraries &lt;prefix&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pfound</name> &gt; 0</expr>)</condition><then> <block>{ <comment type="block">/* Use the reduced prefix returned by Py_GetPrefix() */</comment>
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr>"lib/python00.zip"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufsz</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Replace "00" with version */</comment>
    <expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>bufsz</name> - 6</expr>]</index></name> = <name><name>VERSION</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>bufsz</name> - 5</expr>]</index></name> = <name><name>VERSION</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>

    <if>if <condition>(<expr>!(<name>efound</name> = <call><name>search_for_exec_prefix</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>home</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>Py_FrozenFlag</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr>"Could not find platform dependent libraries &lt;exec_prefix&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>EXEC_PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"lib/lib-dynload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* If we found EXEC_PREFIX do *not* reduce it!  (Yet.) */</comment>

    <if>if <condition>(<expr>(!<name>pfound</name> || !<name>efound</name>) &amp;&amp; !<name>Py_FrozenFlag</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                <argument><expr>"Consider setting $PYTHONHOME to &lt;prefix&gt;[:&lt;exec_prefix&gt;]\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Calculate size of return buffer.
     */</comment>
    <expr_stmt><expr><name>bufsz</name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>rtpypath</name></expr>)</condition><then>
        <expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>rtpypath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>prefixsz</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>

    <while>while <condition>(<expr>1</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>defpath</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>defpath</name><index>[<expr>0</expr>]</index></name> != <name>SEP</name></expr>)</condition><then>
            <comment type="block">/* Paths are relative to prefix */</comment>
            <expr_stmt><expr><name>bufsz</name> += <name>prefixsz</name></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><name>delim</name></expr>)</condition><then>
            <expr_stmt><expr><name>bufsz</name> += <name>delim</name> - <name>defpath</name> + 1</expr>;</expr_stmt></then>
        <else>else <block>{
            <expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>defpath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
            <break>break;</break>
        }</block></else></if>
        <expr_stmt><expr><name>defpath</name> = <name>delim</name> + 1</expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>

    <comment type="block">/* This is the only malloc call in this file */</comment>
    <expr_stmt><expr><name>buf</name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* We can't exit, so print a warning and limp along */</comment>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Not enough memory for dynamic PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Using default static PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>module_search_path</name> = <name>PYTHONPATH</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* Run-time value of $PYTHONPATH goes first */</comment>
        <if>if <condition>(<expr><name>rtpypath</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtpypath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
            <expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></else></if>

        <comment type="block">/* Next is the default zip path */</comment>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Next goes merge of compile-time $PYTHONPATH with
         * dynamically located prefix.
         */</comment>
        <expr_stmt><expr><name>defpath</name> = <name>pythonpath</name></expr>;</expr_stmt>
        <while>while <condition>(<expr>1</expr>)</condition> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>defpath</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name><name>defpath</name><index>[<expr>0</expr>]</index></name> != <name>SEP</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>delim</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>delim</name> - <name>defpath</name> + 1</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>end</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> + <name>len</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>defpath</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*(<name>buf</name> + <name>end</name>) = '\0'</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>defpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></else></if>
            <expr_stmt><expr><name>defpath</name> = <name>delim</name> + 1</expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Finally, on goes the directory for dynamic-load modules */</comment>
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* And publish the results */</comment>
        <expr_stmt><expr><name>module_search_path</name> = <name>buf</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Reduce prefix and exec_prefix to their essence,
     * e.g. /usr/local/lib/python1.5 is reduced to /usr/local.
     * If we're loading relative to the build directory,
     * return the compiled-in defaults instead.
     */</comment>
    <if>if <condition>(<expr><name>pfound</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The prefix is the root directory, but reduce() chopped
	 * off the "/". */</comment>
	<if>if <condition>(<expr>!<name><name>prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>efound</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name><name>exec_prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>EXEC_PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>


<comment type="block">/* External interface */</comment>

<function><type><name>char</name> *</type>
<name>Py_GetPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>module_search_path</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>prefix</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetExecPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>exec_prefix</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type>
<name>Py_GetProgramFullPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>progpath</name></expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
