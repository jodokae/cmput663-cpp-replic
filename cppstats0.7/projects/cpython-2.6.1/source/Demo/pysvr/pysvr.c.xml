<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Demo/pysvr/pysvr.c"><comment type="block">/* A multi-threaded telnet-like server that gives a Python prompt.

Usage: pysvr [port]

For security reasons, it only accepts requests from the current host.
This can still be insecure, but restricts violations from people who
can log in on your machine.  Use with caution!

*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>

<comment type="block">/* XXX Umpfh.
   Python.h defines a typedef destructor, which conflicts with pthread.h.
   So Python.h must be included after pthread.h. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>Py_VerboseFlag</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PORT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PORT</name></cpp:macro> <cpp:value>4000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>workorder</name> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>addr</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_python</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>oprogname</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>main_thread</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_thread</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type>struct</type> <name>sockaddr_in</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> *</type><name>service_thread</name><parameter_list>(<param><decl><type>struct</type> <name>workorder</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_interpreter</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>run_command</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ps</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>progname</name> <init>= <expr>"pysvr"</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyThreadState</name> *</type><name>gtstate</name></decl>;</decl_stmt>

<function><name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><name>PORT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>argc</name> &gt; 0 &amp;&amp; <name><name>argv</name><index>[<expr>0</expr>]</index></name> != <name>NULL</name> &amp;&amp; <name><name>argv</name><index>[<expr>0</expr>]</index><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then>
		<expr_stmt><expr><name>progname</name> = <name><name>argv</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></then></if>

	<while>while <condition>(<expr>(<name>c</name> = <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr>"v"</expr></argument>)</argument_list></call>) != <name>EOF</name></expr>)</condition> <block>{
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
		<case>case <expr>'v'</expr>:
			<expr_stmt><expr><name>Py_VerboseFlag</name>++</expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</default>}</block></switch>
	}</block></while>

	<if>if <condition>(<expr><name>optind</name> &lt; <name>argc</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>optind</name>+1 &lt; <name>argc</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"too many arguments\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>port</name> = <call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>port</name> &lt;= 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"bad port (%s)\n"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><call><name>main_thread</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Bye.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>usage_line</name><index>[]</index></name> <init>= <expr>"usage: %s [port]\n"</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>usage_line</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>main_thread</name><parameter_list>(<param><decl><type><name>int</name></type> <name>port</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>sock</name></decl>, <decl><type ref="prev"/><name>conn</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>sockaddr_in</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>clientaddr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sock</name> = <call><name>socket</name><argument_list>(<argument><expr><name>PF_INET</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sock</name> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't create socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SO_REUSEADDR</name></cpp:ifdef>
	<expr_stmt><expr><name>i</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setsockopt</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_REUSEADDR</name></expr></argument>, <argument><expr>(<name>char</name> *) &amp;<name>i</name></expr></argument>, <argument><expr>sizeof <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr>sizeof <name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>addr</name>.<name>sin_family</name></name> = <name>AF_INET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>addr</name>.<name>sin_port</name></name> = <call><name>htons</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>addr</name>.<name>sin_addr</name>.<name>s_addr</name></name> = 0L</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>bind</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr>sizeof <name>addr</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't bind socket to address"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>listen</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't listen on socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Listening on port %d...\n"</expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>size</name> = sizeof <name>clientaddr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>char</name> *) &amp;<name>clientaddr</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>conn</name> = <call><name>accept</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *) &amp;<name>clientaddr</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>conn</name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't accept connection from socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<expr_stmt><expr><name>size</name> = sizeof <name>addr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>char</name> *) &amp;<name>addr</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr>(struct <name>sockaddr</name> *)&amp;<name>addr</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't get socket name of connection"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>clientaddr</name>.<name>sin_addr</name>.<name>s_addr</name></name> != <name><name>addr</name>.<name>sin_addr</name>.<name>s_addr</name></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"connection from non-local host refused"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"(addr=%lx, clientaddr=%lx)\n"</expr></argument>,
				<argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>addr</name>.<name>sin_addr</name>.<name>s_addr</name></name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>clientaddr</name>.<name>sin_addr</name>.<name>s_addr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		}</block></then></if>
		<if>if <condition>(<expr><name>i</name> == 4</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then></if>
		<expr_stmt><expr><call><name>create_thread</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr>&amp;<name>clientaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>gtstate</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyEval_AcquireThread</name><argument_list>(<argument><expr><name>gtstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gtstate</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_Finalize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* And a second time, just because we can. */</comment>
		<expr_stmt><expr><call><name>Py_Finalize</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* This should be harmless. */</comment>
	}</block></then></if>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_thread</name><parameter_list>(<param><decl><type><name>int</name></type> <name>conn</name></decl></param>, <param><decl><type>struct <name>sockaddr_in</name> *</type><name>addr</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>workorder</name> *</type><name>work</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_t</name></type> <name>tdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>work</name> = <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>workorder</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>work</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"out of memory for thread.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>work</name>-&gt;<name>conn</name></name> = <name>conn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work</name>-&gt;<name>addr</name></name> = *<name>addr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_python</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>pthread_create</name><argument_list>(<argument><expr>&amp;<name>tdata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>service_thread</name></expr></argument>, <argument><expr><name>work</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't create new thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>pthread_detach</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't detach from thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyThreadState</name> *</type><name>the_tstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyInterpreterState</name> *</type><name>the_interp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>the_builtins</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_python</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name>gtstate</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_Initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Initialize the interpreter */</comment>
	<expr_stmt><expr><call><name>PyEval_InitThreads</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Create (and acquire) the interpreter lock */</comment>
	<expr_stmt><expr><name>gtstate</name> = <call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Release the thread state */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type>
<name>service_thread</name><parameter_list>(<param><decl><type>struct <name>workorder</name> *</type><name>work</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>FILE</name> *</type><name>input</name></decl>, *<decl><type ref="prev"/><name>output</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Start thread for connection %d.\n"</expr></argument>, <argument><expr><name><name>work</name>-&gt;<name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ps</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>input</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>work</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>input</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't create input stream"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><name>output</name> = <call><name>fdopen</name><argument_list>(<argument><expr><name><name>work</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>output</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>oprogname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"can't create output stream"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	}</block></then></if>

	<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>run_interpreter</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>done</name>:</label>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"End thread for connection %d.\n"</expr></argument>, <argument><expr><name><name>work</name>-&gt;<name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>work</name>-&gt;<name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>oprogname</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>save</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: "</expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> = <name>save</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_interpreter</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>input</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>output</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>new_stdin</name></decl>, *<decl><type ref="prev"/><name>new_stdout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mainmod</name></decl>, *<decl><type ref="prev"/><name>globals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyEval_AcquireLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tstate</name> = <call><name>Py_NewInterpreter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tstate</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr>"Sorry -- can't create an interpreter\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>

	<expr_stmt><expr><name>mainmod</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr>"__main__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>globals</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mainmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_stdin</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr>"&lt;socket-in&gt;"</expr></argument>, <argument><expr>"r"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_stdout</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr>"&lt;socket-out&gt;"</expr></argument>, <argument><expr>"w"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"stdin"</expr></argument>, <argument><expr><name>new_stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"stdout"</expr></argument>, <argument><expr><name>new_stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PySys_SetObject</name><argument_list>(<argument><expr>"stderr"</expr></argument>, <argument><expr><name>new_stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for (<init><expr><name>n</name> = 1</expr>;</init> <condition><expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
		<name>fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr>"%d&gt; "</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></decl>;</decl_stmt>
		<expr_stmt><expr><name>p</name> = <call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>sizeof <name>buffer</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>Py_END_ALLOW_THREADS</name></macro>

		<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
			<break>break;</break></then></if>
		<if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == '\377' &amp;&amp; <name><name>p</name><index>[<expr>1</expr>]</index></name> == '\354'</expr>)</condition><then>
			<break>break;</break></then></if>

		<expr_stmt><expr><name>q</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>'\r'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>q</name> &amp;&amp; <name><name>q</name><index>[<expr>1</expr>]</index></name> == '\n' &amp;&amp; <name><name>q</name><index>[<expr>2</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>q</name>++ = '\n'</expr>;</expr_stmt>
			<expr_stmt><expr>*<name>q</name>++ = '\0'</expr>;</expr_stmt>
		}</block></then></if>

		<while>while <condition>(<expr>*<name>p</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
			<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt></while>
		<if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == '#' || <name><name>p</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
			<continue>continue;</continue></then></if>

		<expr_stmt><expr><name>end</name> = <call><name>run_command</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr><name>end</name></expr>)</condition><then>
			<break>break;</break></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>new_stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>new_stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_EndInterpreter</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyEval_ReleaseLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr>"Goodbye!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>run_command</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"run_command: %s"</expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>PyRun_String</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>Py_single_input</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call> == <name>PyExc_SystemExit</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>0</expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ps</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		      <argument><expr>"ps -l -p %d &lt;/dev/null | sed 1d\n"</expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>system</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
