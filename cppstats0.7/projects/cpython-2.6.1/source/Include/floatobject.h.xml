<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/floatobject.h">
<comment type="block">/* Float object interface */</comment>

<comment type="block">/*
PyFloatObject represents a (double precision) floating point number.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_FLOATOBJECT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_FLOATOBJECT_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>PyObject_HEAD</name>
    <name>double</name></type> <name>ob_fval</name></decl>;</decl_stmt>
}</block></struct></type> <name>PyFloatObject</name>;</typedef>

<macro><name>PyAPI_DATA</name><argument_list>(<argument>PyTypeObject</argument>)</argument_list></macro> <expr_stmt><expr><name>PyFloat_Type</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyFloat_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_TypeCheck(op, &amp;PyFloat_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyFloat_CheckExact</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PyFloat_Type)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_NAN</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_RETURN_NAN</name></cpp:macro> <cpp:value>return PyFloat_FromDouble(Py_NAN)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_RETURN_INF</name><parameter_list>(<param><type><name>sign</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do					\
	if (copysign(1., sign) == 1.) {				\
		return PyFloat_FromDouble(Py_HUGE_VAL);	\
	} else {						\
		return PyFloat_FromDouble(-Py_HUGE_VAL);	\
	} while(0)</cpp:value></cpp:define>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>double</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_GetMax</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>double</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_GetMin</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_GetInfo</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Return Python float from string PyObject.  Second argument ignored on
   input, and, if non-NULL, NULL is stored into *junk (this tried to serve a
   purpose once but can't be made to work as intended). */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_FromString</name><argument_list>(<argument><expr><name>PyObject</name>*</expr></argument>, <argument><expr><name>char</name>** <name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Return Python float from C double. */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Extract C double from Python float.  The macro version trades safety for
   speed. */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>double</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyFloat_AS_DOUBLE</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((PyFloatObject *)(op))-&gt;ob_fval)</cpp:value></cpp:define>

<comment type="block">/* Write repr(v) into the char buffer argument, followed by null byte.  The
   buffer must be "big enough"; &gt;= 100 is very safe.
   PyFloat_AsReprString(buf, x) strives to print enough digits so that
   PyFloat_FromString(buf) then reproduces x exactly. */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_AsReprString</name><argument_list>(<argument><expr><name>char</name>*</expr></argument>, <argument><expr><name>PyFloatObject</name> *<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Write str(v) into the char buffer argument, followed by null byte.  The
   buffer must be "big enough"; &gt;= 100 is very safe.  Note that it's
   unusual to be able to get back the float you started with from
   PyFloat_AsString's result -- use PyFloat_AsReprString() if you want to
   preserve precision across conversions. */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_AsString</name><argument_list>(<argument><expr><name>char</name>*</expr></argument>, <argument><expr><name>PyFloatObject</name> *<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* _PyFloat_{Pack,Unpack}{4,8}
 *
 * The struct and pickle (at least) modules need an efficient platform-
 * independent way to store floating-point values as byte strings.
 * The Pack routines produce a string from a C double, and the Unpack
 * routines produce a C double from such a string.  The suffix (4 or 8)
 * specifies the number of bytes in the string.
 *
 * On platforms that appear to use (see _PyFloat_Init()) IEEE-754 formats
 * these functions work by copying bits.  On other platforms, the formats the
 * 4- byte format is identical to the IEEE-754 single precision format, and
 * the 8-byte format to the IEEE-754 double precision format, although the
 * packing of INFs and NaNs (if such things exist on the platform) isn't
 * handled correctly, and attempting to unpack a string containing an IEEE
 * INF or NaN will raise an exception.
 *
 * On non-IEEE platforms with more precision, or larger dynamic range, than
 * 754 supports, not all values can be packed; on non-IEEE platforms with less
 * precision, or smaller dynamic range, not all values can be unpacked.  What
 * happens in such cases is partly accidental (alas).
 */</comment>

<comment type="block">/* The pack routines write 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if you want the string in little-endian format (exponent
 * last, at p+3 or p+7), false if you want big-endian format (exponent
 * first, at p).
 * Return value:  0 if all is OK, -1 if error (and an exception is
 * set, most likely OverflowError).
 * There are two problems on non-IEEE platforms:
 * 1):  What this does is undefined if x is a NaN or infinity.
 * 2):  -0.0 and +0.0 produce the same string.
 */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyFloat_Pack4</name><argument_list>(<argument>double x</argument>, <argument>unsigned char *p</argument>, <argument>int le</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyFloat_Pack8</name><argument_list>(<argument>double x</argument>, <argument>unsigned char *p</argument>, <argument>int le</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Used to get the important decimal digits of a double */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyFloat_Digits</name><argument_list>(<argument>char *buf</argument>, <argument>double v</argument>, <argument>int *signum</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyFloat_DigitsInit</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* The unpack routines read 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if the string is in little-endian format (exponent
 * last, at p+3 or p+7), false if big-endian (exponent first, at p).
 * Return value:  The unpacked double.  On error, this is -1.0 and
 * PyErr_Occurred() is true (and an exception is set, most likely
 * OverflowError).  Note that on a non-IEEE platform this will refuse
 * to unpack a string that represents a NaN or infinity.
 */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>double</argument>)</argument_list></macro> <macro><name>_PyFloat_Unpack4</name><argument_list>(<argument>const unsigned char *p</argument>, <argument>int le</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>double</argument>)</argument_list></macro> <macro><name>_PyFloat_Unpack8</name><argument_list>(<argument>const unsigned char *p</argument>, <argument>int le</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* free list api */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyFloat_ClearFreeList</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>_PyFloat_FormatAdvanced</name><argument_list>(<argument>PyObject *obj</argument>,
					       <argument>char *format_spec</argument>,
					       <argument>Py_ssize_t format_spec_len</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_FLOATOBJECT_H */</comment>
</unit>
