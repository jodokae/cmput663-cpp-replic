<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/sliceobject.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_SLICEOBJECT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_SLICEOBJECT_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The unique ellipsis object "..." */</comment>

<macro><name>PyAPI_DATA</name><argument_list>(<argument>PyObject</argument>)</argument_list></macro> <expr_stmt><expr><name>_Py_EllipsisObject</name></expr>;</expr_stmt> <comment type="block">/* Don't use this directly */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_Ellipsis</name></cpp:macro> <cpp:value>(&amp;_Py_EllipsisObject)</cpp:value></cpp:define>

<comment type="block">/* Slice object interface */</comment>

<comment type="block">/*

A slice object containing start, stop, and step data members (the
names are from range).  After much talk with Guido, it was decided to
let these be any arbitrary python type.  Py_None stands for omitted values.
*/</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>PyObject_HEAD</name>
    <name>PyObject</name> *</type><name>start</name></decl>, *<name>stop</name>, *<name>step</name>;</decl_stmt>	<comment type="block">/* not NULL */</comment>
}</block></struct></type> <name>PySliceObject</name>;</typedef>

<macro><name>PyAPI_DATA</name><argument_list>(<argument>PyTypeObject</argument>)</argument_list></macro> <expr_stmt><expr><name>PySlice_Type</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySlice_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PySlice_Type)</cpp:value></cpp:define>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySlice_New</name><argument_list>(<argument><expr><name>PyObject</name>* <name>start</name></expr></argument>, <argument><expr><name>PyObject</name>* <name>stop</name></expr></argument>,
                                  <argument><expr><name>PyObject</name>* <name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>_PySlice_FromIndices</name><argument_list>(<argument>Py_ssize_t start</argument>, <argument>Py_ssize_t stop</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PySlice_GetIndices</name><argument_list>(<argument>PySliceObject *r</argument>, <argument>Py_ssize_t length</argument>,
                                  <argument>Py_ssize_t *start</argument>, <argument>Py_ssize_t *stop</argument>, <argument>Py_ssize_t *step</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PySlice_GetIndicesEx</name><argument_list>(<argument>PySliceObject *r</argument>, <argument>Py_ssize_t length</argument>,
				    <argument>Py_ssize_t *start</argument>, <argument>Py_ssize_t *stop</argument>, 
				    <argument>Py_ssize_t *step</argument>, <argument>Py_ssize_t *slicelength</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_SLICEOBJECT_H */</comment>
</unit>
