<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/unicodeobject.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODEOBJECT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODEOBJECT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<comment type="block">/*

Unicode implementation based on original code by Fredrik Lundh,
modified by Marc-Andre Lemburg (mal@lemburg.com) according to the
Unicode Integration Proposal (see file Misc/unicode.txt).

Copyright (c) Corporation for National Research Initiatives.


 Original header:
 --------------------------------------------------------------------

 * Yet another Unicode string type for Python.  This type supports the
 * 16-bit Basic Multilingual Plane (BMP) only.
 *
 * Written by Fredrik Lundh, January 1999.
 *
 * Copyright (c) 1999 by Secret Labs AB.
 * Copyright (c) 1999 by Fredrik Lundh.
 *
 * fredrik@pythonware.com
 * http://www.pythonware.com
 *
 * --------------------------------------------------------------------
 * This Unicode String Type is
 * 
 * Copyright (c) 1999 by Secret Labs AB
 * Copyright (c) 1999 by Fredrik Lundh
 * 
 * By obtaining, using, and/or copying this software and/or its
 * associated documentation, you agree that you have read, understood,
 * and will comply with the following terms and conditions:
 * 
 * Permission to use, copy, modify, and distribute this software and its
 * associated documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appears in all
 * copies, and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Secret Labs
 * AB or the author not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.
 * 
 * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * -------------------------------------------------------------------- */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/* === Internal API ======================================================= */</comment>

<comment type="block">/* --- Internal Unicode Format -------------------------------------------- */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifndef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>                 <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_CheckExact</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>0</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* FIXME: MvL's new implementation assumes that Py_UNICODE_SIZE is
   properly set, but the default rules below doesn't set it.  I'll
   sort this out some other day -- fredrik@pythonware.com */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_SIZE</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive> Must define Py_UNICODE_SIZE</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Setting Py_UNICODE_WIDE enables UCS-4 storage.  Otherwise, Unicode
   strings are stored as UCS-2 (with limited support for UTF-16) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Py_UNICODE_SIZE</name> &gt;= 4</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_WIDE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Set these flags if the platform has "wchar.h", "wctype.h" and the
   wchar_t type is a 16-bit unsigned type */</comment>
<comment type="block">/* #define HAVE_WCHAR_H */</comment>
<comment type="block">/* #define HAVE_USABLE_WCHAR_T */</comment>

<comment type="block">/* Defaults for various platforms */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PY_UNICODE_TYPE</name></cpp:ifndef>

<comment type="block">/* Windows has a usable wchar_t type (unless we're using UCS-4) */</comment>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Py_UNICODE_SIZE</name> == 2</expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_USABLE_WCHAR_T</name></cpp:macro></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PY_UNICODE_TYPE</name></cpp:macro> <cpp:value>wchar_t</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PY_UNICODE_TYPE</name></cpp:macro> <cpp:value>Py_UCS4</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If the compiler provides a wchar_t type we try to support it
   through the interface functions PyUnicode_FromWideChar() and
   PyUnicode_AsWideChar(). */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_USABLE_WCHAR_T</name></cpp:ifdef>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>HAVE_WCHAR_H</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_WCHAR_H</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCHAR_H</name></cpp:ifdef>
<comment type="block">/* Work around a cosmetic bug in BSDI 4.x wchar.h; thanks to Thomas Wouters */</comment>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>_HAVE_BSDI</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Use this typedef when you need to represent a UTF-16 surrogate pair
 * as single unsigned integer.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> &gt;= 4</expr></cpp:if> 
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>Py_UCS4</name>;</typedef> 
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG</name> &gt;= 4</expr></cpp:elif>
<typedef>typedef <type><name>unsigned</name> <name>long</name></type> <name>Py_UCS4</name>;</typedef> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>PY_UNICODE_TYPE</name></type> <name>Py_UNICODE</name>;</typedef>

<comment type="block">/* --- UCS-2/UCS-4 Name Mangling ------------------------------------------ */</comment>

<comment type="block">/* Unicode API names are mangled to assure that UCS-2 and UCS-4 builds
   produce different external names and thus cause import errors in
   case Python interpreters and extensions with mixed compiled in
   Unicode width assumptions are combined. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_UNICODE_WIDE</name></cpp:ifndef>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsASCIIString</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsASCIIString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsCharmapString</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsCharmapString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsEncodedObject</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsEncodedObject</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsEncodedString</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsEncodedString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsLatin1String</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsLatin1String</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsRawUnicodeEscapeString</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsRawUnicodeEscapeString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUTF32String</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsUTF32String</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUTF16String</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsUTF16String</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUTF8String</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsUTF8String</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUnicode</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsUnicode</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUnicodeEscapeString</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsUnicodeEscapeString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsWideChar</name></cpp:macro> <cpp:value>PyUnicodeUCS2_AsWideChar</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Compare</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Compare</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Concat</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Concat</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Contains</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Contains</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Count</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Count</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Decode</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Decode</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeASCII</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeASCII</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeCharmap</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeCharmap</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeLatin1</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeLatin1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeRawUnicodeEscape</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeRawUnicodeEscape</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF32</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeUTF32</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF32Stateful</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeUTF32Stateful</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF16</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeUTF16</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF16Stateful</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeUTF16Stateful</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF8</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeUTF8</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF8Stateful</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeUTF8Stateful</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUnicodeEscape</name></cpp:macro> <cpp:value>PyUnicodeUCS2_DecodeUnicodeEscape</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Encode</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Encode</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeASCII</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeASCII</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeCharmap</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeCharmap</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeDecimal</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeDecimal</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeLatin1</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeLatin1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeRawUnicodeEscape</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeRawUnicodeEscape</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeUTF32</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeUTF32</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeUTF16</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeUTF16</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeUTF8</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeUTF8</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeUnicodeEscape</name></cpp:macro> <cpp:value>PyUnicodeUCS2_EncodeUnicodeEscape</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Find</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Find</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Format</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Format</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromEncodedObject</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromEncodedObject</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromObject</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromObject</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromOrdinal</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromOrdinal</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromUnicode</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromUnicode</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromString</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromStringAndSize</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromStringAndSize</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromFormatV</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromFormatV</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromFormat</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromFormat</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromWideChar</name></cpp:macro> <cpp:value>PyUnicodeUCS2_FromWideChar</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_GetDefaultEncoding</name></cpp:macro> <cpp:value>PyUnicodeUCS2_GetDefaultEncoding</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_GetMax</name></cpp:macro> <cpp:value>PyUnicodeUCS2_GetMax</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_GetSize</name></cpp:macro> <cpp:value>PyUnicodeUCS2_GetSize</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Join</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Join</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Partition</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Partition</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_RPartition</name></cpp:macro> <cpp:value>PyUnicodeUCS2_RPartition</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_RSplit</name></cpp:macro> <cpp:value>PyUnicodeUCS2_RSplit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Replace</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Replace</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Resize</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Resize</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_RichCompare</name></cpp:macro> <cpp:value>PyUnicodeUCS2_RichCompare</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_SetDefaultEncoding</name></cpp:macro> <cpp:value>PyUnicodeUCS2_SetDefaultEncoding</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Split</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Split</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Splitlines</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Splitlines</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Tailmatch</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Tailmatch</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Translate</name></cpp:macro> <cpp:value>PyUnicodeUCS2_Translate</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_TranslateCharmap</name></cpp:macro> <cpp:value>PyUnicodeUCS2_TranslateCharmap</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_AsDefaultEncodedString</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_AsDefaultEncodedString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_Fini</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_Fini</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_Init</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_Init</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_ClearFreeList</name></cpp:macro> <cpp:value>PyUnicodeUCS2_ClearFreelist</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsAlpha</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsAlpha</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsDecimalDigit</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsDecimalDigit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsDigit</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsDigit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsLinebreak</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsLinebreak</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsLowercase</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsLowercase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsNumeric</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsNumeric</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsTitlecase</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsTitlecase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsUppercase</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsUppercase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsWhitespace</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_IsWhitespace</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToDecimalDigit</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_ToDecimalDigit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToDigit</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_ToDigit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToLowercase</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_ToLowercase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToNumeric</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_ToNumeric</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToTitlecase</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_ToTitlecase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToUppercase</name></cpp:macro> <cpp:value>_PyUnicodeUCS2_ToUppercase</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsASCIIString</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsASCIIString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsCharmapString</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsCharmapString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsEncodedObject</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsEncodedObject</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsEncodedString</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsEncodedString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsLatin1String</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsLatin1String</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsRawUnicodeEscapeString</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsRawUnicodeEscapeString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUTF32String</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsUTF32String</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUTF16String</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsUTF16String</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUTF8String</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsUTF8String</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUnicode</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsUnicode</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsUnicodeEscapeString</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsUnicodeEscapeString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AsWideChar</name></cpp:macro> <cpp:value>PyUnicodeUCS4_AsWideChar</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Compare</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Compare</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Concat</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Concat</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Contains</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Contains</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Count</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Count</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Decode</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Decode</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeASCII</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeASCII</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeCharmap</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeCharmap</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeLatin1</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeLatin1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeRawUnicodeEscape</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeRawUnicodeEscape</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF32</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeUTF32</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF32Stateful</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeUTF32Stateful</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF16</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeUTF16</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF16Stateful</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeUTF16Stateful</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF8</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeUTF8</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUTF8Stateful</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeUTF8Stateful</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_DecodeUnicodeEscape</name></cpp:macro> <cpp:value>PyUnicodeUCS4_DecodeUnicodeEscape</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Encode</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Encode</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeASCII</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeASCII</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeCharmap</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeCharmap</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeDecimal</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeDecimal</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeLatin1</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeLatin1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeRawUnicodeEscape</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeRawUnicodeEscape</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeUTF32</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeUTF32</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeUTF16</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeUTF16</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeUTF8</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeUTF8</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_EncodeUnicodeEscape</name></cpp:macro> <cpp:value>PyUnicodeUCS4_EncodeUnicodeEscape</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Find</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Find</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Format</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Format</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromEncodedObject</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromEncodedObject</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromObject</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromObject</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromOrdinal</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromOrdinal</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromUnicode</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromUnicode</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromString</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromStringAndSize</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromStringAndSize</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromFormatV</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromFormatV</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromFormat</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromFormat</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_FromWideChar</name></cpp:macro> <cpp:value>PyUnicodeUCS4_FromWideChar</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_GetDefaultEncoding</name></cpp:macro> <cpp:value>PyUnicodeUCS4_GetDefaultEncoding</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_GetMax</name></cpp:macro> <cpp:value>PyUnicodeUCS4_GetMax</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_GetSize</name></cpp:macro> <cpp:value>PyUnicodeUCS4_GetSize</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Join</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Join</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Partition</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Partition</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_RPartition</name></cpp:macro> <cpp:value>PyUnicodeUCS4_RPartition</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_RSplit</name></cpp:macro> <cpp:value>PyUnicodeUCS4_RSplit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Replace</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Replace</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Resize</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Resize</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_RichCompare</name></cpp:macro> <cpp:value>PyUnicodeUCS4_RichCompare</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_SetDefaultEncoding</name></cpp:macro> <cpp:value>PyUnicodeUCS4_SetDefaultEncoding</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Split</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Split</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Splitlines</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Splitlines</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Tailmatch</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Tailmatch</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Translate</name></cpp:macro> <cpp:value>PyUnicodeUCS4_Translate</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_TranslateCharmap</name></cpp:macro> <cpp:value>PyUnicodeUCS4_TranslateCharmap</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_AsDefaultEncodedString</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_AsDefaultEncodedString</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_Fini</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_Fini</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_Init</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_Init</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_ClearFreeList</name></cpp:macro> <cpp:value>PyUnicodeUCS2_ClearFreelist</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsAlpha</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsAlpha</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsDecimalDigit</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsDecimalDigit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsDigit</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsDigit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsLinebreak</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsLinebreak</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsLowercase</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsLowercase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsNumeric</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsNumeric</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsTitlecase</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsTitlecase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsUppercase</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsUppercase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_IsWhitespace</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_IsWhitespace</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToDecimalDigit</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_ToDecimalDigit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToDigit</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_ToDigit</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToLowercase</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_ToLowercase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToNumeric</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_ToNumeric</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToTitlecase</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_ToTitlecase</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_ToUppercase</name></cpp:macro> <cpp:value>_PyUnicodeUCS4_ToUppercase</cpp:value></cpp:define>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* --- Internal Unicode Operations ---------------------------------------- */</comment>

<comment type="block">/* If you want Python to use the compiler's wctype.h functions instead
   of the ones supplied with Python, define WANT_WCTYPE_FUNCTIONS or
   configure Python using --with-wctype-functions.  This reduces the
   interpreter's code size. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WANT_WCTYPE_FUNCTIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wctype.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISSPACE</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswspace(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISLOWER</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswlower(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISUPPER</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswupper(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISTITLE</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsTitlecase(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISLINEBREAK</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsLinebreak(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TOLOWER</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>towlower(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TOUPPER</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>towupper(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TOTITLE</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToTitlecase(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISDECIMAL</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsDecimalDigit(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISDIGIT</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsDigit(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISNUMERIC</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsNumeric(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TODECIMAL</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToDecimalDigit(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TODIGIT</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToDigit(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TONUMERIC</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToNumeric(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISALPHA</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswalpha(ch)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* Since splitting on whitespace is an important use case, and whitespace
   in most situations is solely ASCII whitespace, we optimize for the common
   case by using a quick look-up table with an inlined check.
 */</comment>
<macro><name>PyAPI_DATA</name><argument_list>(<argument>const unsigned char</argument>)</argument_list></macro> <expr_stmt><expr><name><name>_Py_ascii_whitespace</name><index>[]</index></name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISSPACE</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>((ch) &lt; 128U ? _Py_ascii_whitespace[(ch)] : _PyUnicode_IsWhitespace(ch))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISLOWER</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsLowercase(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISUPPER</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsUppercase(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISTITLE</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsTitlecase(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISLINEBREAK</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsLinebreak(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TOLOWER</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToLowercase(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TOUPPER</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToUppercase(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TOTITLE</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToTitlecase(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISDECIMAL</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsDecimalDigit(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISDIGIT</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsDigit(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISNUMERIC</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsNumeric(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TODECIMAL</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToDecimalDigit(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TODIGIT</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToDigit(ch)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_TONUMERIC</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_ToNumeric(ch)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISALPHA</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>_PyUnicode_IsAlpha(ch)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_ISALNUM</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> \
       <cpp:value>(Py_UNICODE_ISALPHA(ch) || \
        Py_UNICODE_ISDECIMAL(ch) || \
        Py_UNICODE_ISDIGIT(ch) || \
        Py_UNICODE_ISNUMERIC(ch))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_COPY</name><parameter_list>(<param><type><name>target</name></type></param>, <param><type><name>source</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro>				\
	<cpp:value>Py_MEMCPY((target), (source), (length)*sizeof(Py_UNICODE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_FILL</name><parameter_list>(<param><type><name>target</name></type></param>, <param><type><name>value</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do\
    {Py_ssize_t i_; Py_UNICODE *t_ = (target); Py_UNICODE v_ = (value);\
        for (i_ = 0; i_ &lt; (length); i_++) t_[i_] = v_;\
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* check if substring matches at given offset.  the offset must be
   valid, and the substring must not be empty */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_MATCH</name><parameter_list>(<param><type><name>string</name></type></param>, <param><type><name>offset</name></type></param>, <param><type><name>substring</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((*((string)-&gt;str + (offset)) == *((substring)-&gt;str)) &amp;&amp; \
    ((*((string)-&gt;str + (offset) + (substring)-&gt;length-1) == *((substring)-&gt;str + (substring)-&gt;length-1))) &amp;&amp; \
     !memcmp((string)-&gt;str + (offset), (substring)-&gt;str, (substring)-&gt;length*sizeof(Py_UNICODE)))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_ClearFreeList</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* --- Unicode Type ------------------------------------------------------- */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>PyObject_HEAD</name>
    <name>Py_ssize_t</name></type> <name>length</name></decl>;</decl_stmt>		<comment type="block">/* Length of raw Unicode data in buffer */</comment>
    <decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>str</name></decl>;</decl_stmt>		<comment type="block">/* Raw Unicode buffer */</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>hash</name></decl>;</decl_stmt>			<comment type="block">/* Hash value; -1 if not set */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>defenc</name></decl>;</decl_stmt>		<comment type="block">/* (Default) Encoded version as Python
				   string, or NULL; this is used for
				   implementing the buffer protocol */</comment>
}</block></struct></type> <name>PyUnicodeObject</name>;</typedef>

<macro><name>PyAPI_DATA</name><argument_list>(<argument>PyTypeObject</argument>)</argument_list></macro> <expr_stmt><expr><name>PyUnicode_Type</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> \
                 <cpp:value>PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_CheckExact</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PyUnicode_Type)</cpp:value></cpp:define>

<comment type="block">/* Fast access macros */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_GET_SIZE</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>(((PyUnicodeObject *)(op))-&gt;length)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_GET_DATA_SIZE</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>(((PyUnicodeObject *)(op))-&gt;length * sizeof(Py_UNICODE))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AS_UNICODE</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>(((PyUnicodeObject *)(op))-&gt;str)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_AS_DATA</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>((const char *)((PyUnicodeObject *)(op))-&gt;str)</cpp:value></cpp:define>

<comment type="block">/* --- Constants ---------------------------------------------------------- */</comment>

<comment type="block">/* This Unicode character will be used as replacement character during
   decoding if the errors argument is set to "replace". Note: the
   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
   Unicode 3.0. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNICODE_REPLACEMENT_CHARACTER</name></cpp:macro> <cpp:value>((Py_UNICODE) 0xFFFD)</cpp:value></cpp:define>

<comment type="block">/* === Public API ========================================================= */</comment>

<comment type="block">/* --- Plain Py_UNICODE --------------------------------------------------- */</comment>

<comment type="block">/* Create a Unicode Object from the Py_UNICODE buffer u of the given
   size. 

   u may be NULL which causes the contents to be undefined. It is the
   user's responsibility to fill in the needed data afterwards. Note
   that modifying the Unicode object contents after construction is
   only allowed if u was set to NULL.

   The buffer is copied into the new object. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_FromUnicode</name><argument_list>(
    <argument>const Py_UNICODE *u</argument>,        <comment type="block">/* Unicode buffer */</comment>
    <argument>Py_ssize_t size</argument>             <comment type="block">/* size of buffer */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Similar to PyUnicode_FromUnicode(), but u points to Latin-1 encoded bytes */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_FromStringAndSize</name><argument_list>(
    <argument>const char *u</argument>,        <comment type="block">/* char buffer */</comment>
    <argument>Py_ssize_t size</argument>       <comment type="block">/* size of buffer */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
   Latin-1 encoded bytes */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_FromString</name><argument_list>(
    <argument><expr>const <name>char</name> *<name>u</name></expr></argument>        <comment type="block">/* string */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Return a read-only pointer to the Unicode object's internal
   Py_UNICODE buffer. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_UNICODE *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsUnicode</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Get the length of the Unicode object. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_GetSize</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Get the maximum ordinal for a Unicode character. */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_UNICODE</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_GetMax</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Resize an already allocated Unicode object to the new size length.

   *unicode is modified to point to the new (resized) object and 0
   returned on success.

   This API may only be called by the function which also called the
   Unicode constructor. The refcount on the object must be 1. Otherwise,
   an error is returned.

   Error handling is implemented as follows: an exception is set, -1
   is returned and *unicode left untouched.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyUnicode_Resize</name><argument_list>(
    <argument>PyObject **unicode</argument>,		<comment type="block">/* Pointer to the Unicode object */</comment>
    <argument>Py_ssize_t length</argument>		<comment type="block">/* New length */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Coerce obj to an Unicode object and return a reference with
   *incremented* refcount.

   Coercion is done in the following way:

   1. String and other char buffer compatible objects are decoded
      under the assumptions that they contain data using the current
      default encoding. Decoding is done in "strict" mode.

   2. All other objects (including Unicode objects) raise an
      exception.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_FromEncodedObject</name><argument_list>(
    <argument>register PyObject *obj</argument>, 	<comment type="block">/* Object */</comment>
    <argument>const char *encoding</argument>,       <comment type="block">/* encoding */</comment>
    <argument>const char *errors</argument>          <comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Coerce obj to an Unicode object and return a reference with
   *incremented* refcount.
   
   Unicode objects are passed back as-is (subclasses are converted to
   true Unicode objects), all other objects are delegated to
   PyUnicode_FromEncodedObject(obj, NULL, "strict") which results in
   using the default encoding as basis for decoding the object.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_FromObject</name><argument_list>(
    <argument>register PyObject *obj</argument> 	<comment type="block">/* Object */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_FromFormatV</name><argument_list>(<argument><expr>const <name>char</name>*</expr></argument>, <argument><expr><name>va_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_FromFormat</name><argument_list>(<argument><expr>const <name>char</name>*</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>_PyUnicode_FormatAdvanced</name><argument_list>(<argument>PyObject *obj</argument>,
						 <argument>Py_UNICODE *format_spec</argument>,
						 <argument>Py_ssize_t format_spec_len</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- wchar_t support for platforms which support it --------------------- */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCHAR_H</name></cpp:ifdef>

<comment type="block">/* Create a Unicode Object from the whcar_t buffer w of the given
   size.

   The buffer is copied into the new object. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_FromWideChar</name><argument_list>(
    <argument>register const wchar_t *w</argument>,  <comment type="block">/* wchar_t buffer */</comment>
    <argument>Py_ssize_t size</argument>             <comment type="block">/* size of buffer */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Copies the Unicode Object contents into the wchar_t buffer w.  At
   most size wchar_t characters are copied.

   Note that the resulting wchar_t string may or may not be
   0-terminated.  It is the responsibility of the caller to make sure
   that the wchar_t string is 0-terminated in case this is required by
   the application.

   Returns the number of wchar_t characters copied (excluding a
   possibly trailing 0-termination character) or -1 in case of an
   error. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <macro><name>PyUnicode_AsWideChar</name><argument_list>(
    <argument>PyUnicodeObject *unicode</argument>,   <comment type="block">/* Unicode object */</comment>
    <argument>register wchar_t *w</argument>,        <comment type="block">/* wchar_t buffer */</comment>
    <argument>Py_ssize_t size</argument>             <comment type="block">/* size of buffer */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* --- Unicode ordinals --------------------------------------------------- */</comment>

<comment type="block">/* Create a Unicode Object from the given Unicode code point ordinal. 
 
   The ordinal must be in range(0x10000) on narrow Python builds
   (UCS2), and range(0x110000) on wide builds (UCS4). A ValueError is
   raised in case it is not.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_FromOrdinal</name><argument_list>(<argument>int ordinal</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* === Builtin Codecs ===================================================== 

   Many of these APIs take two arguments encoding and errors. These
   parameters encoding and errors have the same semantics as the ones
   of the builtin unicode() API. 

   Setting encoding to NULL causes the default encoding to be used.

   Error handling is set by errors which may also be set to NULL
   meaning to use the default handling defined for the codec. Default
   error handling for all builtin codecs is "strict" (ValueErrors are
   raised).

   The codecs all use a similar interface. Only deviation from the
   generic ones are documented.

*/</comment>

<comment type="block">/* --- Manage the default encoding ---------------------------------------- */</comment>

<comment type="block">/* Return a Python string holding the default encoded value of the
   Unicode object. 

   The resulting string is cached in the Unicode object for subsequent
   usage by this function. The cached version is needed to implement
   the character buffer interface and will live (at least) as long as
   the Unicode object itself.

   The refcount of the string is *not* incremented.

   *** Exported for internal use by the interpreter only !!! ***

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(
    <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Returns the currently active default encoding.

   The default encoding is currently implemented as run-time settable
   process global.  This may change in future versions of the
   interpreter to become a parameter which is managed on a per-thread
   basis.
   
 */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>const char*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_GetDefaultEncoding</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Sets the currently active default encoding.

   Returns 0 on success, -1 in case of an error.
   
 */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_SetDefaultEncoding</name><argument_list>(
    <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>	<comment type="block">/* Encoding name in standard form */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* --- Generic Codecs ----------------------------------------------------- */</comment>

<comment type="block">/* Create a Unicode object by decoding the encoded string s of the
   given size. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_Decode</name><argument_list>(
    <argument>const char *s</argument>,              <comment type="block">/* encoded string */</comment>
    <argument>Py_ssize_t size</argument>,            <comment type="block">/* size of buffer */</comment>
    <argument>const char *encoding</argument>,       <comment type="block">/* encoding */</comment>
    <argument>const char *errors</argument>          <comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Encodes a Py_UNICODE buffer of the given size and returns a 
   Python string object. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_Encode</name><argument_list>(
    <argument>const Py_UNICODE *s</argument>,        <comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t size</argument>,            <comment type="block">/* number of Py_UNICODE chars to encode */</comment>
    <argument>const char *encoding</argument>,       <comment type="block">/* encoding */</comment>
    <argument>const char *errors</argument>          <comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Encodes a Unicode object and returns the result as Python
   object. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsEncodedObject</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>,	 	<comment type="block">/* Unicode object */</comment>
    <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>,	<comment type="block">/* encoding */</comment>
    <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Encodes a Unicode object and returns the result as Python string
   object. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsEncodedString</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>,	 	<comment type="block">/* Unicode object */</comment>
    <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>,	<comment type="block">/* encoding */</comment>
    <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_BuildEncodingMap</name><argument_list>(
    <argument><expr><name>PyObject</name>* <name>string</name></expr></argument>            <comment type="block">/* 256 character map */</comment>
   )</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* --- UTF-7 Codecs ------------------------------------------------------- */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUTF7</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* UTF-7 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUTF7Stateful</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* UTF-7 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>,		<comment type="block">/* error handling */</comment>
    <argument>Py_ssize_t *consumed</argument>	<comment type="block">/* bytes consumed */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeUTF7</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,	 		<comment type="block">/* number of Py_UNICODE chars to encode */</comment>
    <argument>int encodeSetO</argument>,             <comment type="block">/* force the encoder to encode characters in
                                   Set O, as described in RFC2152 */</comment>
    <argument>int encodeWhiteSpace</argument>,       <comment type="block">/* force the encoder to encode space, tab,
                                   carriage return and linefeed characters */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- UTF-8 Codecs ------------------------------------------------------- */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUTF8</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* UTF-8 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUTF8Stateful</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* UTF-8 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>,		<comment type="block">/* error handling */</comment>
    <argument>Py_ssize_t *consumed</argument>		<comment type="block">/* bytes consumed */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsUTF8String</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeUTF8</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,	 		<comment type="block">/* number of Py_UNICODE chars to encode */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- UTF-32 Codecs ------------------------------------------------------ */</comment>

<comment type="block">/* Decodes length bytes from a UTF-32 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict". 

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

	*byteorder == -1: little endian
	*byteorder == 0:  native order
	*byteorder == 1:  big endian

   In native mode, the first four bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUTF32</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* UTF-32 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>,		<comment type="block">/* error handling */</comment>
    <argument>int *byteorder</argument>		<comment type="block">/* pointer to byteorder to use
				   0=native;-1=LE,1=BE; updated on
				   exit */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUTF32Stateful</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* UTF-32 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>,		<comment type="block">/* error handling */</comment>
    <argument>int *byteorder</argument>,		<comment type="block">/* pointer to byteorder to use
				   0=native;-1=LE,1=BE; updated on
				   exit */</comment>
    <argument>Py_ssize_t *consumed</argument>	<comment type="block">/* bytes consumed */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Returns a Python string using the UTF-32 encoding in native byte
   order. The string always starts with a BOM mark.  */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsUTF32String</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Returns a Python string object holding the UTF-32 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeUTF32</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* number of Py_UNICODE chars to encode */</comment>
    <argument>const char *errors</argument>,		<comment type="block">/* error handling */</comment>
    <argument>int byteorder</argument>		<comment type="block">/* byteorder to use 0=BOM+native;-1=LE,1=BE */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- UTF-16 Codecs ------------------------------------------------------ */</comment>

<comment type="block">/* Decodes length bytes from a UTF-16 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict". 

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

	*byteorder == -1: little endian
	*byteorder == 0:  native order
	*byteorder == 1:  big endian

   In native mode, the first two bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUTF16</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* UTF-16 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>,		<comment type="block">/* error handling */</comment>
    <argument>int *byteorder</argument>		<comment type="block">/* pointer to byteorder to use
				   0=native;-1=LE,1=BE; updated on
				   exit */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUTF16Stateful</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* UTF-16 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>,		<comment type="block">/* error handling */</comment>
    <argument>int *byteorder</argument>,		<comment type="block">/* pointer to byteorder to use
				   0=native;-1=LE,1=BE; updated on
				   exit */</comment>
    <argument>Py_ssize_t *consumed</argument>		<comment type="block">/* bytes consumed */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Returns a Python string using the UTF-16 encoding in native byte
   order. The string always starts with a BOM mark.  */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsUTF16String</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Returns a Python string object holding the UTF-16 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to
   UCS-2. This trick makes it possible to add full UTF-16 capabilities
   at a later point without compromising the APIs.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeUTF16</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,	 		<comment type="block">/* number of Py_UNICODE chars to encode */</comment>
    <argument>const char *errors</argument>,		<comment type="block">/* error handling */</comment>
    <argument>int byteorder</argument>		<comment type="block">/* byteorder to use 0=BOM+native;-1=LE,1=BE */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- Unicode-Escape Codecs ---------------------------------------------- */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeUnicodeEscape</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* Unicode-Escape encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsUnicodeEscapeString</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeUnicodeEscape</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>	 		<comment type="block">/* Number of Py_UNICODE chars to encode */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeRawUnicodeEscape</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* Raw-Unicode-Escape encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsRawUnicodeEscapeString</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeRawUnicodeEscape</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>	 		<comment type="block">/* Number of Py_UNICODE chars to encode */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- Unicode Internal Codec ---------------------------------------------

    Only for internal use in _codecsmodule.c */</comment>

<function_decl><type><name>PyObject</name> *</type><name>_PyUnicode_DecodeUnicodeInternal</name><parameter_list>(
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>,
    <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>
    )</parameter_list>;</function_decl>

<comment type="block">/* --- Latin-1 Codecs ----------------------------------------------------- 

   Note: Latin-1 corresponds to the first 256 Unicode ordinals.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeLatin1</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* Latin-1 encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsLatin1String</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeLatin1</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,	 		<comment type="block">/* Number of Py_UNICODE chars to encode */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- ASCII Codecs ------------------------------------------------------- 

   Only 7-bit ASCII data is excepted. All other codes generate errors.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeASCII</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* ASCII encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsASCIIString</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>	 	<comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeASCII</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,	 		<comment type="block">/* Number of Py_UNICODE chars to encode */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- Character Map Codecs ----------------------------------------------- 

   This codec uses mappings to encode and decode characters. 

   Decoding mappings must map single string characters to single
   Unicode characters, integers (which are then interpreted as Unicode
   ordinals) or None (meaning "undefined mapping" and causing an
   error).

   Encoding mappings must map single Unicode characters to single
   string characters, integers (which are then interpreted as Latin-1
   ordinals) or None (meaning "undefined mapping" and causing an
   error).

   If a character lookup fails with a LookupError, the character is
   copied as-is meaning that its ordinal value will be interpreted as
   Unicode or Latin-1 ordinal resp. Because of this mappings only need
   to contain those mappings which map characters to different code
   points.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeCharmap</name><argument_list>(
    <argument>const char *string</argument>, 	<comment type="block">/* Encoded string */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* size of string */</comment>
    <argument>PyObject *mapping</argument>,		<comment type="block">/* character mapping 
				   (char ordinal -&gt; unicode ordinal) */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsCharmapString</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>,	 	<comment type="block">/* Unicode object */</comment>
    <argument><expr><name>PyObject</name> *<name>mapping</name></expr></argument>		<comment type="block">/* character mapping 
				   (unicode ordinal -&gt; char ordinal) */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeCharmap</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,	 	<comment type="block">/* Number of Py_UNICODE chars to encode */</comment>
    <argument>PyObject *mapping</argument>,		<comment type="block">/* character mapping 
				   (unicode ordinal -&gt; char ordinal) */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Translate a Py_UNICODE buffer of the given length by applying a
   character mapping table to it and return the resulting Unicode
   object.

   The mapping table must map Unicode ordinal integers to Unicode
   ordinal integers or None (causing deletion of the character). 

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PyUnicode_TranslateCharmap</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>, 	<comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,	 		<comment type="block">/* Number of Py_UNICODE chars to encode */</comment>
    <argument>PyObject *table</argument>,		<comment type="block">/* Translate table */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WIN32</name></cpp:ifdef>

<comment type="block">/* --- MBCS codecs for Windows -------------------------------------------- */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeMBCS</name><argument_list>(
    <argument>const char *string</argument>,         <comment type="block">/* MBCS encoded string */</comment>
    <argument>Py_ssize_t length</argument>,              <comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>          <comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_DecodeMBCSStateful</name><argument_list>(
    <argument>const char *string</argument>,         <comment type="block">/* MBCS encoded string */</comment>
    <argument>Py_ssize_t length</argument>,          <comment type="block">/* size of string */</comment>
    <argument>const char *errors</argument>,         <comment type="block">/* error handling */</comment>
    <argument>Py_ssize_t *consumed</argument>        <comment type="block">/* bytes consumed */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_AsMBCSString</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>unicode</name></expr></argument>           <comment type="block">/* Unicode object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeMBCS</name><argument_list>(
    <argument>const Py_UNICODE *data</argument>,     <comment type="block">/* Unicode char buffer */</comment>
    <argument>Py_ssize_t length</argument>,              <comment type="block">/* Number of Py_UNICODE chars to encode */</comment>
    <argument>const char *errors</argument>          <comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WIN32 */</comment>

<comment type="block">/* --- Decimal Encoder ---------------------------------------------------- */</comment>

<comment type="block">/* Takes a Unicode string holding a decimal value and writes it into
   an output buffer using standard ASCII digit codes.

   The output buffer has to provide at least length+1 bytes of storage
   area. The output string is 0-terminated.

   The encoder converts whitespace to ' ', decimal characters to their
   corresponding ASCII digit and all other Latin-1 characters except
   \0 as-is. Characters outside this range (Unicode ordinals 1-256)
   are treated as errors. This includes embedded NULL bytes.

   Error handling is defined by the errors argument:

      NULL or "strict": raise a ValueError
      "ignore": ignore the wrong characters (these are not copied to the
		output buffer)
      "replace": replaces illegal characters with '?'

   Returns 0 on success, -1 on failure.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyUnicode_EncodeDecimal</name><argument_list>(
    <argument>Py_UNICODE *s</argument>,		<comment type="block">/* Unicode buffer */</comment>
    <argument>Py_ssize_t length</argument>,			<comment type="block">/* Number of Py_UNICODE chars to encode */</comment>
    <argument>char *output</argument>,		<comment type="block">/* Output buffer; must have size &gt;= length */</comment>
    <argument>const char *errors</argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* --- Methods &amp; Slots ----------------------------------------------------

   These are capable of handling Unicode objects and strings on input
   (we refer to them as strings in the descriptions) and return
   Unicode objects or integers as apporpriate. */</comment>

<comment type="block">/* Concat two strings giving a new Unicode string. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_Concat</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>left</name></expr></argument>,	 	<comment type="block">/* Left string */</comment>
    <argument><expr><name>PyObject</name> *<name>right</name></expr></argument>	 	<comment type="block">/* Right string */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. If negative, no limit is set.

   Separators are not included in the resulting list.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_Split</name><argument_list>(
    <argument>PyObject *s</argument>,		<comment type="block">/* String to split */</comment>
    <argument>PyObject *sep</argument>,		<comment type="block">/* String separator */</comment>
    <argument>Py_ssize_t maxsplit</argument>		<comment type="block">/* Maxsplit count */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>		

<comment type="block">/* Dito, but split at line breaks.

   CRLF is considered to be one line break. Line breaks are not
   included in the resulting list. */</comment>
    
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_Splitlines</name><argument_list>(
    <argument>PyObject *s</argument>,		<comment type="block">/* String to split */</comment>
    <argument>int keepends</argument>		<comment type="block">/* If true, line end markers are included */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>		

<comment type="block">/* Partition a string using a given separator. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_Partition</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>s</name></expr></argument>,		<comment type="block">/* String to partition */</comment>
    <argument><expr><name>PyObject</name> *<name>sep</name></expr></argument>		<comment type="block">/* String separator */</comment>
    )</argument_list></call></expr>;</expr_stmt>		

<comment type="block">/* Partition a string using a given separator, searching from the end of the
   string. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_RPartition</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>s</name></expr></argument>,		<comment type="block">/* String to partition */</comment>
    <argument><expr><name>PyObject</name> *<name>sep</name></expr></argument>		<comment type="block">/* String separator */</comment>
    )</argument_list></call></expr>;</expr_stmt>		

<comment type="block">/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. But unlike PyUnicode_Split
   PyUnicode_RSplit splits from the end of the string. If negative,
   no limit is set.

   Separators are not included in the resulting list.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <macro><name>PyUnicode_RSplit</name><argument_list>(
    <argument>PyObject *s</argument>,		<comment type="block">/* String to split */</comment>
    <argument>PyObject *sep</argument>,		<comment type="block">/* String separator */</comment>
    <argument>Py_ssize_t maxsplit</argument>		<comment type="block">/* Maxsplit count */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>		

<comment type="block">/* Translate a string by applying a character mapping table to it and
   return the resulting Unicode object.

   The mapping table must map Unicode ordinal integers to Unicode
   ordinal integers or None (causing deletion of the character). 

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_Translate</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>str</name></expr></argument>,		<comment type="block">/* String */</comment> 
    <argument><expr><name>PyObject</name> *<name>table</name></expr></argument>,		<comment type="block">/* Translate table */</comment>
    <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>		<comment type="block">/* error handling */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Join a sequence of strings using the given separator and return
   the resulting Unicode string. */</comment>
    
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_Join</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>separator</name></expr></argument>, 	<comment type="block">/* Separator string */</comment>
    <argument><expr><name>PyObject</name> *<name>seq</name></expr></argument>	 	<comment type="block">/* Sequence object */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Return 1 if substr matches str[start:end] at the given tail end, 0
   otherwise. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <macro><name>PyUnicode_Tailmatch</name><argument_list>(
    <argument>PyObject *str</argument>,		<comment type="block">/* String */</comment> 
    <argument>PyObject *substr</argument>,		<comment type="block">/* Prefix or Suffix string */</comment>
    <argument>Py_ssize_t start</argument>,		<comment type="block">/* Start index */</comment>
    <argument>Py_ssize_t end</argument>,		<comment type="block">/* Stop index */</comment>
    <argument>int direction</argument>		<comment type="block">/* Tail end: -1 prefix, +1 suffix */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Return the first position of substr in str[start:end] using the
   given search direction or -1 if not found. -2 is returned in case
   an error occurred and an exception is set. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <macro><name>PyUnicode_Find</name><argument_list>(
    <argument>PyObject *str</argument>,		<comment type="block">/* String */</comment> 
    <argument>PyObject *substr</argument>,		<comment type="block">/* Substring to find */</comment>
    <argument>Py_ssize_t start</argument>,		<comment type="block">/* Start index */</comment>
    <argument>Py_ssize_t end</argument>,		<comment type="block">/* Stop index */</comment>
    <argument>int direction</argument>		<comment type="block">/* Find direction: +1 forward, -1 backward */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Count the number of occurrences of substr in str[start:end]. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <macro><name>PyUnicode_Count</name><argument_list>(
    <argument>PyObject *str</argument>,		<comment type="block">/* String */</comment> 
    <argument>PyObject *substr</argument>,		<comment type="block">/* Substring to count */</comment>
    <argument>Py_ssize_t start</argument>,		<comment type="block">/* Start index */</comment>
    <argument>Py_ssize_t end</argument>		<comment type="block">/* Stop index */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Replace at most maxcount occurrences of substr in str with replstr
   and return the resulting Unicode object. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PyUnicode_Replace</name><argument_list>(
    <argument>PyObject *str</argument>,		<comment type="block">/* String */</comment> 
    <argument>PyObject *substr</argument>,		<comment type="block">/* Substring to find */</comment>
    <argument>PyObject *replstr</argument>,		<comment type="block">/* Substring to replace */</comment>
    <argument>Py_ssize_t maxcount</argument>		<comment type="block">/* Max. number of replacements to apply;
				   -1 = all */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Compare two strings and return -1, 0, 1 for less than, equal,
   greater than resp. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_Compare</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>left</name></expr></argument>,		<comment type="block">/* Left string */</comment> 
    <argument><expr><name>PyObject</name> *<name>right</name></expr></argument>		<comment type="block">/* Right string */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Rich compare two strings and return one of the following:

   - NULL in case an exception was raised
   - Py_True or Py_False for successfuly comparisons
   - Py_NotImplemented in case the type combination is unknown

   Note that Py_EQ and Py_NE comparisons can cause a UnicodeWarning in
   case the conversion of the arguments to Unicode fails with a
   UnicodeDecodeError.

   Possible values for op:

     Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PyUnicode_RichCompare</name><argument_list>(
    <argument>PyObject *left</argument>,		<comment type="block">/* Left string */</comment> 
    <argument>PyObject *right</argument>,		<comment type="block">/* Right string */</comment>
    <argument>int op</argument>			<comment type="block">/* Operation: Py_EQ, Py_NE, Py_GT, etc. */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Apply a argument tuple or dictionary to a format string and return
   the resulting Unicode string. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_Format</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>format</name></expr></argument>,		<comment type="block">/* Format string */</comment> 
    <argument><expr><name>PyObject</name> *<name>args</name></expr></argument>		<comment type="block">/* Argument tuple or dictionary */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Checks whether element is contained in container and return 1/0
   accordingly.

   element has to coerce to an one element Unicode string. -1 is
   returned in case of an error. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyUnicode_Contains</name><argument_list>(
    <argument><expr><name>PyObject</name> *<name>container</name></expr></argument>,	<comment type="block">/* Container string */</comment> 
    <argument><expr><name>PyObject</name> *<name>element</name></expr></argument>		<comment type="block">/* Element string */</comment>
    )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Externally visible for str.strip(unicode) */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>_PyUnicode_XStrip</name><argument_list>(
    <argument>PyUnicodeObject *self</argument>,
    <argument>int striptype</argument>,
    <argument>PyObject *sepobj</argument>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* === Characters Type APIs =============================================== */</comment>

<comment type="block">/* These should not be used directly. Use the Py_UNICODE_IS* and
   Py_UNICODE_TO* macros instead. 

   These APIs are implemented in Objects/unicodectype.c.

*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsLowercase</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsUppercase</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsTitlecase</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsWhitespace</name><argument_list>(
    <argument>const Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsLinebreak</name><argument_list>(
    <argument>const Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_UNICODE</argument>)</argument_list></macro> <macro><name>_PyUnicode_ToLowercase</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_UNICODE</argument>)</argument_list></macro> <macro><name>_PyUnicode_ToUppercase</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_UNICODE</argument>)</argument_list></macro> <macro><name>_PyUnicode_ToTitlecase</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_ToDecimalDigit</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_ToDigit</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>double</argument>)</argument_list></macro> <macro><name>_PyUnicode_ToNumeric</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsDecimalDigit</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsDigit</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsNumeric</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyUnicode_IsAlpha</name><argument_list>(
    <argument>Py_UNICODE ch</argument> 	<comment type="block">/* Unicode character */</comment>
    )</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_USING_UNICODE */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_UNICODEOBJECT_H */</comment>
</unit>
