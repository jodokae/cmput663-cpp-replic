<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/ceval.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_CEVAL_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_CEVAL_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Interface to random parts in ceval.c */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_CallObjectWithKeywords</name><argument_list>(
	<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* DLL-level Backwards compatibility: */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyEval_CallObject</name></cpp:undef>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Inline this */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyEval_CallObject</name><parameter_list>(<param><type><name>func</name></type></param>,<param><type><name>arg</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)</cpp:value></cpp:define>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_CallFunction</name><argument_list>(<argument><expr><name>PyObject</name> *<name>obj</name></expr></argument>,
                                           <argument><expr>const <name>char</name> *<name>format</name></expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_CallMethod</name><argument_list>(<argument><expr><name>PyObject</name> *<name>obj</name></expr></argument>,
                                         <argument><expr>const <name>char</name> *<name>methodname</name></expr></argument>,
                                         <argument><expr>const <name>char</name> *<name>format</name></expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_SetProfile</name><argument_list>(<argument><expr><name>Py_tracefunc</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_SetTrace</name><argument_list>(<argument><expr><name>Py_tracefunc</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<struct_decl>struct <name>_frame</name>;</struct_decl> <comment type="block">/* Avoid including frameobject.h */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_GetBuiltins</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_GetGlobals</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_GetLocals</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>struct _frame *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_GetFrame</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_GetRestricted</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Look at the current frame's (if any) code's co_flags, and turn on
   the corresponding compiler flags in cf-&gt;cf_flags.  Return 1 if any
   flag was set, else return 0. */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_MergeCompilerFlags</name><argument_list>(<argument><expr><name>PyCompilerFlags</name> *<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Py_FlushLine</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Py_AddPendingCall</name><argument_list>(<argument><expr><call><call><name>int</name> <argument_list>(<argument><expr>*<name>func</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>void</name> *<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Py_MakePendingCalls</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Protection against deeply nested recursive calls */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Py_SetRecursionLimit</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Py_GetRecursionLimit</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_EnterRecursiveCall</name><parameter_list>(<param><type><name>where</name></type></param>)</parameter_list></cpp:macro>                                    \
	    <cpp:value>(_Py_MakeRecCheck(PyThreadState_GET()-&gt;recursion_depth) &amp;&amp;  \
	     _Py_CheckRecursiveCall(where))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_LeaveRecursiveCall</name><parameter_list>()</parameter_list></cpp:macro>				\
	    <cpp:value>(--PyThreadState_GET()-&gt;recursion_depth)</cpp:value></cpp:define>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_Py_CheckRecursiveCall</name><argument_list>(<argument><expr><name>char</name> *<name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_DATA</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><name>_Py_CheckRecursionLimit</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_STACKCHECK</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>_Py_MakeRecCheck</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>(++(x) &gt; --_Py_CheckRecursionLimit)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>_Py_MakeRecCheck</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>(++(x) &gt; _Py_CheckRecursionLimit)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_GetFuncName</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_GetFuncDesc</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_GetCallStats</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_EvalFrame</name><argument_list>(<argument>struct <expr><name>_frame</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PyEval_EvalFrameEx</name><argument_list>(<argument>struct _frame *f</argument>, <argument>int exc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* this used to be handled on a per-thread basis - now just two globals */</comment>
<macro><name>PyAPI_DATA</name><argument_list>(<argument>volatile int</argument>)</argument_list></macro> <expr_stmt><expr><name>_Py_Ticker</name></expr>;</expr_stmt>
<macro><name>PyAPI_DATA</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><name>_Py_CheckInterval</name></expr>;</expr_stmt>

<comment type="block">/* Interface for threads.

   A module that plans to do a blocking system call (or something else
   that lasts a long time and doesn't touch Python data) can allow other
   threads to run as follows:

	...preparations here...
	Py_BEGIN_ALLOW_THREADS
	...blocking system call here...
	Py_END_ALLOW_THREADS
	...interpret result here...

   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
   {}-surrounded block.
   To leave the block in the middle (e.g., with return), you must insert
   a line containing Py_BLOCK_THREADS before the return, e.g.

	if (...premature_exit...) {
		Py_BLOCK_THREADS
		PyErr_SetFromErrno(PyExc_IOError);
		return NULL;
	}

   An alternative is:

	Py_BLOCK_THREADS
	if (...premature_exit...) {
		PyErr_SetFromErrno(PyExc_IOError);
		return NULL;
	}
	Py_UNBLOCK_THREADS

   For convenience, that the value of 'errno' is restored across
   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.

   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
   Py_END_ALLOW_THREADS!!!

   The function PyEval_InitThreads() should be called only from
   initthread() in "threadmodule.c".

   Note that not yet all candidates have been converted to use this
   mechanism!
*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyThreadState *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_SaveThread</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><name>PyThreadState</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_THREAD</name></cpp:ifdef>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro>  <expr_stmt><expr><call><name>PyEval_ThreadsInitialized</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_InitThreads</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_AcquireLock</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_ReleaseLock</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_AcquireThread</name><argument_list>(<argument><expr><name>PyThreadState</name> *<name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_ReleaseThread</name><argument_list>(<argument><expr><name>PyThreadState</name> *<name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyEval_ReInitThreads</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_BEGIN_ALLOW_THREADS</name></cpp:macro> <cpp:value>{ \
			PyThreadState *_save; \
			_save = PyEval_SaveThread();</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_BLOCK_THREADS</name></cpp:macro>	<cpp:value>PyEval_RestoreThread(_save);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNBLOCK_THREADS</name></cpp:macro>	<cpp:value>_save = PyEval_SaveThread();</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_END_ALLOW_THREADS</name></cpp:macro>	<cpp:value>PyEval_RestoreThread(_save); \
		 }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !WITH_THREAD */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_BEGIN_ALLOW_THREADS</name></cpp:macro> <cpp:value>{</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_BLOCK_THREADS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_UNBLOCK_THREADS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_END_ALLOW_THREADS</name></cpp:macro> <cpp:value>}</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !WITH_THREAD */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyEval_SliceIndex</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_CEVAL_H */</comment>
</unit>
