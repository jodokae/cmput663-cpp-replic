<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/Python.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_PYTHON_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_PYTHON_H</name></cpp:macro></cpp:define>
<comment type="block">/* Since this is a "meta-include" file, no #ifdef __cplusplus / extern "C" { */</comment>

<comment type="block">/* Include nearly all Python header files */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"patchlevel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyconfig.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pymacconfig.h"</cpp:file></cpp:include>

<comment type="block">/* Cyclic gc is always enabled, starting with release 2.3a1.  Supply the
 * old symbol for the benefit of extension modules written before then
 * that may be conditionalizing on it.  The core doesn't use it anymore.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITH_CYCLE_GC</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WITH_CYCLE_GC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UCHAR_MAX</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive> "Something's broken.  UCHAR_MAX should be defined in limits.h."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UCHAR_MAX</name> != 255</expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "Python's source code assumes C's unsigned char is an 8-bit type."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_SGI_MP_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SGI_MP_SOURCE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NULL</name></cpp:ifndef>
<cpp:error>#   <cpp:directive>error</cpp:directive> "Python.h requires that stdio.h define NULL."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ERRNO_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNISTD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* For size_t? */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STDDEF_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
 * compiler command line when building Python in release mode; else
 * assert() calls won't be removed.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyport.h"</cpp:file></cpp:include>

<comment type="block">/* pyconfig.h or pyport.h may or may not define DL_IMPORT */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DL_IMPORT</name></cpp:ifndef>	<comment type="block">/* declarations for DLL import/export */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DL_IMPORT</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>RTYPE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DL_EXPORT</name></cpp:ifndef>	<comment type="block">/* declarations for DLL import/export */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DL_EXPORT</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>RTYPE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Debug-mode build with pymalloc implies PYMALLOC_DEBUG.
 *  PYMALLOC_DEBUG is in error if pymalloc is not in use.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WITH_PYMALLOC</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYMALLOC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYMALLOC_DEBUG</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYMALLOC_DEBUG</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>WITH_PYMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "PYMALLOC_DEBUG requires WITH_PYMALLOC"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pymath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pymem.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"objimpl.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pydebug.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unicodeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"intobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"boolobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"longobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"floatobject.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITHOUT_COMPLEX</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"complexobject.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rangeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringobject.h"</cpp:file></cpp:include>
<comment type="block">/* #include "memoryobject.h" */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bufferobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytesobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytearrayobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tupleobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"listobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dictobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"enumobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"setobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"methodobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"moduleobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"classobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fileobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"traceback.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sliceobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cellobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iterobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"genobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"descrobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"warnings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"weakrefobject.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"codecs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyerrors.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pystate.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"modsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythonrun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ceval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sysmodule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"intrcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"import.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"abstract.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pystrtod.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pystrcmp.h"</cpp:file></cpp:include>

<comment type="block">/* _Py_Mangle is defined in compile.c */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_Py_Mangle</name><argument_list>(<argument><expr><name>PyObject</name> *<name>p</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* PyArg_GetInt is deprecated and should not be used, use PyArg_Parse(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyArg_GetInt</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>a</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>PyArg_Parse((v), "i", (a))</cpp:value></cpp:define>

<comment type="block">/* PyArg_NoArgs should not be necessary.
   Set ml_flags in the PyMethodDef to METH_NOARGS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyArg_NoArgs</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>PyArg_Parse(v, "")</cpp:value></cpp:define>

<comment type="block">/* Convert a possibly signed character to a nonnegative int */</comment>
<comment type="block">/* XXX This assumes characters are 8 bits wide */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__CHAR_UNSIGNED__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_CHARMASK</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>(c)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_CHARMASK</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>		<cpp:value>((unsigned char)((c) &amp; 0xff))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyfpe.h"</cpp:file></cpp:include>

<comment type="block">/* These definitions must match corresponding definitions in graminit.h.
   There's code in compile.c that checks that they are the same. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_single_input</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_file_input</name></cpp:macro> <cpp:value>257</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_eval_input</name></cpp:macro> <cpp:value>258</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTH</name></cpp:ifdef>
<comment type="block">/* GNU pth user-space thread support */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pth.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Define macros for inline documentation. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_VAR</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static char name[]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_STRVAR</name><parameter_list>(<param><type><name>name</name></type></param>,<param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyDoc_VAR(name) = PyDoc_STR(str)</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_DOC_STRINGS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_STR</name><parameter_list>(<param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>str</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_STR</name><parameter_list>(<param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_PYTHON_H */</comment>
</unit>
