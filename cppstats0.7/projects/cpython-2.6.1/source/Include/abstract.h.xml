<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/abstract.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_ABSTRACTOBJECT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_ABSTRACTOBJECT_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PY_SSIZE_T_CLEAN</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_CallFunction</name></cpp:macro> <cpp:value>_PyObject_CallFunction_SizeT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_CallMethod</name></cpp:macro> <cpp:value>_PyObject_CallMethod_SizeT</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Abstract Object Interface (many thanks to Jim Fulton) */</comment>

<comment type="block">/*
   PROPOSAL: A Generic Python Object Interface for Python C Modules

Problem

  Python modules written in C that must access Python objects must do
  so through routines whose interfaces are described by a set of
  include files.  Unfortunately, these routines vary according to the
  object accessed.  To use these routines, the C programmer must check
  the type of the object being used and must call a routine based on
  the object type.  For example, to access an element of a sequence,
  the programmer must determine whether the sequence is a list or a
  tuple:

    if(is_tupleobject(o))
      e=gettupleitem(o,i)
    else if(is_listitem(o))
      e=getlistitem(o,i)

  If the programmer wants to get an item from another type of object
  that provides sequence behavior, there is no clear way to do it
  correctly.  

  The persistent programmer may peruse object.h and find that the
  _typeobject structure provides a means of invoking up to (currently
  about) 41 special operators.  So, for example, a routine can get an
  item from any object that provides sequence behavior. However, to
  use this mechanism, the programmer must make their code dependent on
  the current Python implementation.

  Also, certain semantics, especially memory management semantics, may
  differ by the type of object being used.  Unfortunately, these
  semantics are not clearly described in the current include files.
  An abstract interface providing more consistent semantics is needed. 

Proposal

  I propose the creation of a standard interface (with an associated
  library of routines and/or macros) for generically obtaining the
  services of Python objects.  This proposal can be viewed as one
  components of a Python C interface consisting of several components.

  From the viewpoint of C access to Python services, we have (as
  suggested by Guido in off-line discussions):

  - "Very high level layer": two or three functions that let you exec or
    eval arbitrary Python code given as a string in a module whose name is
    given, passing C values in and getting C values out using
    mkvalue/getargs style format strings.  This does not require the user
    to declare any variables of type "PyObject *".  This should be enough
    to write a simple application that gets Python code from the user,
    execs it, and returns the output or errors.  (Error handling must also
    be part of this API.)

  - "Abstract objects layer": which is the subject of this proposal.
    It has many functions operating on objects, and lest you do many
    things from C that you can also write in Python, without going
    through the Python parser.

  - "Concrete objects layer": This is the public type-dependent
    interface provided by the standard built-in types, such as floats,
    strings, and lists.  This interface exists and is currently
    documented by the collection of include files provided with the
    Python distributions.

  From the point of view of Python accessing services provided by C
  modules: 

  - "Python module interface": this interface consist of the basic
    routines used to define modules and their members.  Most of the
    current extensions-writing guide deals with this interface.

  - "Built-in object interface": this is the interface that a new
    built-in type must provide and the mechanisms and rules that a
    developer of a new built-in type must use and follow.

  This proposal is a "first-cut" that is intended to spur
  discussion. See especially the lists of notes.

  The Python C object interface will provide four protocols: object,
  numeric, sequence, and mapping.  Each protocol consists of a
  collection of related operations.  If an operation that is not
  provided by a particular type is invoked, then a standard exception,
  NotImplementedError is raised with a operation name as an argument.
  In addition, for convenience this interface defines a set of
  constructors for building objects of built-in types.  This is needed
  so new objects can be returned from C functions that otherwise treat
  objects generically.

Memory Management

  For all of the functions described in this proposal, if a function
  retains a reference to a Python object passed as an argument, then the
  function will increase the reference count of the object.  It is
  unnecessary for the caller to increase the reference count of an
  argument in anticipation of the object's retention.

  All Python objects returned from functions should be treated as new
  objects.  Functions that return objects assume that the caller will
  retain a reference and the reference count of the object has already
  been incremented to account for this fact.  A caller that does not
  retain a reference to an object that is returned from a function
  must decrement the reference count of the object (using
  DECREF(object)) to prevent memory leaks.

  Note that the behavior mentioned here is different from the current
  behavior for some objects (e.g. lists and tuples) when certain
  type-specific routines are called directly (e.g. setlistitem).  The
  proposed abstraction layer will provide a consistent memory
  management interface, correcting for inconsistent behavior for some
  built-in types.

Protocols

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/</comment>

<comment type="block">/*  Object Protocol: */</comment>

     <comment type="block">/* Implemented elsewhere:

     int PyObject_Print(PyObject *o, FILE *fp, int flags);

         Print an object, o, on file, fp.  Returns -1 on
	 error.  The flags argument is used to enable certain printing
	 options. The only option currently supported is Py_Print_RAW. 

         (What should be said about Py_Print_RAW?)	

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     int PyObject_HasAttrString(PyObject *o, char *attr_name);

         Returns 1 if o has the attribute attr_name, and 0 otherwise.
	 This is equivalent to the Python expression:
	 hasattr(o,attr_name). 

	 This function always succeeds.

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     PyObject* PyObject_GetAttrString(PyObject *o, char *attr_name);

	 Retrieve an attributed named attr_name form object o.
	 Returns the attribute value on success, or NULL on failure.
	 This is the equivalent of the Python expression: o.attr_name.

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     int PyObject_HasAttr(PyObject *o, PyObject *attr_name);

         Returns 1 if o has the attribute attr_name, and 0 otherwise.
	 This is equivalent to the Python expression:
	 hasattr(o,attr_name). 

	 This function always succeeds.

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);

	 Retrieve an attributed named attr_name form object o.
	 Returns the attribute value on success, or NULL on failure.
	 This is the equivalent of the Python expression: o.attr_name.

       */</comment>


     <comment type="block">/* Implemented elsewhere:

     int PyObject_SetAttrString(PyObject *o, char *attr_name, PyObject *v);

	 Set the value of the attribute named attr_name, for object o,
	 to the value, v. Returns -1 on failure.  This is
	 the equivalent of the Python statement: o.attr_name=v.

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);

	 Set the value of the attribute named attr_name, for object o,
	 to the value, v. Returns -1 on failure.  This is
	 the equivalent of the Python statement: o.attr_name=v.

       */</comment>

     <comment type="block">/* implemented as a macro:

     int PyObject_DelAttrString(PyObject *o, char *attr_name);

	 Delete attribute named attr_name, for object o. Returns
	 -1 on failure.  This is the equivalent of the Python
	 statement: del o.attr_name.

       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PyObject_DelAttrString</name><parameter_list>(<param><type><name>O</name></type></param>,<param><type><name>A</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_SetAttrString((O),(A),NULL)</cpp:value></cpp:define>

     <comment type="block">/* implemented as a macro:

     int PyObject_DelAttr(PyObject *o, PyObject *attr_name);

	 Delete attribute named attr_name, for object o. Returns -1
	 on failure.  This is the equivalent of the Python
	 statement: del o.attr_name.

       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PyObject_DelAttr</name><parameter_list>(<param><type><name>O</name></type></param>,<param><type><name>A</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_SetAttr((O),(A),NULL)</cpp:value></cpp:define>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Cmp</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>, <argument><expr><name>int</name> *<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Compare the values of o1 and o2 using a routine provided by
	 o1, if one exists, otherwise with a routine provided by o2.
	 The result of the comparison is returned in result.  Returns
	 -1 on failure.  This is the equivalent of the Python
	 statement: result=cmp(o1,o2).

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     int PyObject_Compare(PyObject *o1, PyObject *o2);

	 Compare the values of o1 and o2 using a routine provided by
	 o1, if one exists, otherwise with a routine provided by o2.
	 Returns the result of the comparison on success.  On error,
	 the value returned is undefined. This is equivalent to the
	 Python expression: cmp(o1,o2).

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     PyObject *PyObject_Repr(PyObject *o);

	 Compute the string representation of object, o.  Returns the
	 string representation on success, NULL on failure.  This is
	 the equivalent of the Python expression: repr(o).

	 Called by the repr() built-in function and by reverse quotes.

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     PyObject *PyObject_Str(PyObject *o);

	 Compute the string representation of object, o.  Returns the
	 string representation on success, NULL on failure.  This is
	 the equivalent of the Python expression: str(o).)

	 Called by the str() built-in function and by the print
	 statement.

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     PyObject *PyObject_Unicode(PyObject *o);

	 Compute the unicode representation of object, o.  Returns the
	 unicode representation on success, NULL on failure.  This is
	 the equivalent of the Python expression: unistr(o).)

	 Called by the unistr() built-in function.

       */</comment>

       <comment type="block">/* Declared elsewhere

     PyAPI_FUNC(int) PyCallable_Check(PyObject *o);

	 Determine if the object, o, is callable.  Return 1 if the
	 object is callable and 0 otherwise.

	 This function always succeeds.

       */</comment>



     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Call</name><argument_list>(<argument><expr><name>PyObject</name> *<name>callable_object</name></expr></argument>,
					 <argument><expr><name>PyObject</name> *<name>args</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Call a callable Python object, callable_object, with
	 arguments and keywords arguments.  The 'args' argument can not be
	 NULL, but the 'kw' argument can be NULL.

       */</comment>
     
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name>PyObject</name> *<name>callable_object</name></expr></argument>,
                                               <argument><expr><name>PyObject</name> *<name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Call a callable Python object, callable_object, with
	 arguments given by the tuple, args.  If no arguments are
	 needed, then args may be NULL.  Returns the result of the
	 call on success, or NULL on failure.  This is the equivalent
	 of the Python expression: apply(o,args).

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>PyObject</name> *<name>callable_object</name></expr></argument>,
                                                 <argument><expr><name>char</name> *<name>format</name></expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Call a callable Python object, callable_object, with a
	 variable number of C arguments. The C arguments are described
	 using a mkvalue-style format string. The format may be NULL,
	 indicating that no arguments are provided.  Returns the
	 result of the call on success, or NULL on failure.  This is
	 the equivalent of the Python expression: apply(o,args).

       */</comment>


     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>char</name> *<name>m</name></expr></argument>,
                                               <argument><expr><name>char</name> *<name>format</name></expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Call the method named m of object o with a variable number of
	 C arguments.  The C arguments are described by a mkvalue
	 format string.  The format may be NULL, indicating that no
	 arguments are provided. Returns the result of the call on
	 success, or NULL on failure.  This is the equivalent of the
	 Python expression: o.method(args).
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_CallFunction_SizeT</name><argument_list>(<argument><expr><name>PyObject</name> *<name>callable</name></expr></argument>,
							 <argument><expr><name>char</name> *<name>format</name></expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_CallMethod_SizeT</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>,
						       <argument><expr><name>char</name> *<name>name</name></expr></argument>,
						       <argument><expr><name>char</name> *<name>format</name></expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>PyObject</name> *<name>callable</name></expr></argument>,
                                                        <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Call a callable Python object, callable_object, with a
	 variable number of C arguments.  The C arguments are provided
	 as PyObject * values, terminated by a NULL.  Returns the
	 result of the call on success, or NULL on failure.  This is
	 the equivalent of the Python expression: apply(o,args).
       */</comment>


     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_CallMethodObjArgs</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>,
                                                      <argument><expr><name>PyObject</name> *<name>m</name></expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Call the method named m of object o with a variable number of
	 C arguments.  The C arguments are provided as PyObject *
	 values, terminated by NULL.  Returns the result of the call
	 on success, or NULL on failure.  This is the equivalent of
	 the Python expression: o.method(args).
       */</comment>


     <comment type="block">/* Implemented elsewhere:

     long PyObject_Hash(PyObject *o);

         Compute and return the hash, hash_value, of an object, o.  On
	 failure, return -1.  This is the equivalent of the Python
	 expression: hash(o).

       */</comment>


     <comment type="block">/* Implemented elsewhere:

     int PyObject_IsTrue(PyObject *o);

	 Returns 1 if the object, o, is considered to be true, 0 if o is
	 considered to be false and -1 on failure. This is equivalent to the
	 Python expression: not not o

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     int PyObject_Not(PyObject *o);

	 Returns 0 if the object, o, is considered to be true, 1 if o is
	 considered to be false and -1 on failure. This is equivalent to the
	 Python expression: not o

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Type</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 On success, returns a type object corresponding to the object
	 type of object o. On failure, returns NULL.  This is
	 equivalent to the Python expression: type(o).
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Size</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Return the size of object o.  If the object, o, provides
	 both sequence and mapping protocols, the sequence size is
	 returned. On error, -1 is returned.  This is the equivalent
	 to the Python expression: len(o).

       */</comment>

       <comment type="block">/* For DLL compatibility */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyObject_Length</name></cpp:undef>
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Length</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Length</name></cpp:macro> <cpp:value>PyObject_Size</cpp:value></cpp:define>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_LengthHint</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Guess the size of object o using len(o) or o.__length_hint__().
         If neither of those return a non-negative value, then return the
         default value.  This function never fails. All exceptions are cleared.
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Return element of o corresponding to the object, key, or NULL
	 on failure. This is the equivalent of the Python expression:
	 o[key].

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_SetItem</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>key</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Map the object, key, to the value, v.  Returns
	 -1 on failure.  This is the equivalent of the Python
	 statement: o[key]=v.
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_DelItemString</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>char</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Remove the mapping for object, key, from the object *o.
         Returns -1 on failure.  This is equivalent to
         the Python statement: del o[key].
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_DelItem</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Delete the mapping for key from *o.  Returns -1 on failure.
	 This is the equivalent of the Python statement: del o[key].
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>PyObject</name> *<name>obj</name></expr></argument>,
					  <argument><expr>const <name>char</name> **<name>buffer</name></expr></argument>,
					  <argument><expr><name>Py_ssize_t</name> *<name>buffer_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/* 
	  Takes an arbitrary object which must support the (character,
	  single segment) buffer interface and returns a pointer to a
	  read-only memory location useable as character based input
	  for subsequent processing.

	  0 is returned on success.  buffer and buffer_len are only
	  set in case no error occurs. Otherwise, -1 is returned and
	  an exception set.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_CheckReadBuffer</name><argument_list>(<argument><expr><name>PyObject</name> *<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/*  
	  Checks whether an arbitrary object supports the (character,
	  single segment) buffer interface.  Returns 1 on success, 0
	  on failure.

      */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_AsReadBuffer</name><argument_list>(<argument><expr><name>PyObject</name> *<name>obj</name></expr></argument>,
					  <argument><expr>const <name>void</name> **<name>buffer</name></expr></argument>,
					  <argument><expr><name>Py_ssize_t</name> *<name>buffer_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/* 
	  Same as PyObject_AsCharBuffer() except that this API expects
	  (readable, single segment) buffer interface and returns a
	  pointer to a read-only memory location which can contain
	  arbitrary data.

	  0 is returned on success.  buffer and buffer_len are only
	  set in case no error occurrs.  Otherwise, -1 is returned and
	  an exception set.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_AsWriteBuffer</name><argument_list>(<argument><expr><name>PyObject</name> *<name>obj</name></expr></argument>,
					   <argument><expr><name>void</name> **<name>buffer</name></expr></argument>,
					   <argument><expr><name>Py_ssize_t</name> *<name>buffer_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/* 
	  Takes an arbitrary object which must support the (writeable,
	  single segment) buffer interface and returns a pointer to a
	  writeable memory location in buffer of size buffer_len.

	  0 is returned on success.  buffer and buffer_len are only
	  set in case no error occurrs. Otherwise, -1 is returned and
	  an exception set.

       */</comment>

	<comment type="block">/* new buffer API */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_CheckBuffer</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(((obj)-&gt;ob_type-&gt;tp_as_buffer != NULL) &amp;&amp;			\
	 (PyType_HasFeature((obj)-&gt;ob_type, Py_TPFLAGS_HAVE_NEWBUFFER)) &amp;&amp; \
	 ((obj)-&gt;ob_type-&gt;tp_as_buffer-&gt;bf_getbuffer != NULL))</cpp:value></cpp:define>
			    
	<comment type="block">/* Return 1 if the getbuffer function is available, otherwise 
	   return 0 */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyObject_GetBuffer</name><argument_list>(<argument>PyObject *obj</argument>, <argument>Py_buffer *view</argument>, 
					<argument>int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	<comment type="block">/* This is a C-API version of the getbuffer function call.  It checks
       	   to make sure object has the required function pointer and issues the
	   call.  Returns -1 and raises an error on failure and returns 0 on 
	   success
        */</comment>


     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyBuffer_GetPointer</name><argument_list>(<argument><expr><name>Py_buffer</name> *<name>view</name></expr></argument>, <argument><expr><name>Py_ssize_t</name> *<name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Get the memory area pointed to by the indices for the buffer given. 
           Note that view-&gt;ndim is the assumed size of indices 
        */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyBuffer_SizeFromFormat</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
	<comment type="block">/* Return the implied itemsize of the data-format area from a 
	   struct-style description */</comment>
    

	
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyBuffer_ToContiguous</name><argument_list>(<argument>void *buf</argument>, <argument>Py_buffer *view</argument>,
    					   <argument>Py_ssize_t len</argument>, <argument>char fort</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyBuffer_FromContiguous</name><argument_list>(<argument>Py_buffer *view</argument>, <argument>void *buf</argument>, 
    					     <argument>Py_ssize_t len</argument>, <argument>char fort</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


	<comment type="block">/* Copy len bytes of data from the contiguous chunk of memory
	   pointed to by buf into the buffer exported by obj.  Return
	   0 on success and return -1 and raise a PyBuffer_Error on
	   error (i.e. the object does not have a buffer interface or
	   it is not working).

	   If fort is 'F' and the object is multi-dimensional,
	   then the data will be copied into the array in
	   Fortran-style (first dimension varies the fastest).  If
	   fort is 'C', then the data will be copied into the array
	   in C-style (last dimension varies the fastest).  If fort
	   is 'A', then it does not matter and the copy will be made
	   in whatever way is more efficient.

        */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_CopyData</name><argument_list>(<argument><expr><name>PyObject</name> *<name>dest</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Copy the data from the src buffer to the buffer of destination
         */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyBuffer_IsContiguous</name><argument_list>(<argument>Py_buffer *view</argument>, <argument>char fort</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>PyBuffer_FillContiguousStrides</name><argument_list>(<argument>int ndims</argument>, 
	  					    <argument>Py_ssize_t *shape</argument>, 
						    <argument>Py_ssize_t *strides</argument>,
	                                            <argument>int itemsize</argument>,
	     					    <argument>char fort</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       	<comment type="block">/*  Fill the strides array with byte-strides of a contiguous
            (Fortran-style if fort is 'F' or C-style otherwise)
            array of the given shape with the given number of bytes
            per element.
        */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyBuffer_FillInfo</name><argument_list>(<argument>Py_buffer *view</argument>, <argument>PyObject *o</argument>, <argument>void *buf</argument>,
		             	       <argument>Py_ssize_t len</argument>, <argument>int readonly</argument>,
				       <argument>int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

        <comment type="block">/* Fills in a buffer-info structure correctly for an exporter
           that can only share a contiguous chunk of memory of
           "unsigned bytes" of the given length. Returns 0 on success
           and -1 (with raising an error) on error.
         */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr><name>Py_buffer</name> *<name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/* Releases a Py_buffer obtained from getbuffer ParseTuple's s*.
        */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Format</name><argument_list>(<argument><expr><name>PyObject</name>* <name>obj</name></expr></argument>,
					    <argument><expr><name>PyObject</name> *<name>format_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <comment type="block">/*
	 Takes an arbitrary object and returns the result of
	 calling obj.__format__(format_spec).
       */</comment>

<comment type="block">/* Iterators */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="block">/* Takes an object and returns an iterator for it.
        This is typically a new iterator but if the argument
	is an iterator, this returns itself. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyIter_Check</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>(PyType_HasFeature((obj)-&gt;ob_type, Py_TPFLAGS_HAVE_ITER) &amp;&amp; \
     (obj)-&gt;ob_type-&gt;tp_iternext != NULL)</cpp:value></cpp:define>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyIter_Next</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="block">/* Takes an iterator object and calls its tp_iternext slot,
	returning the next value.  If the iterator is exhausted,
	this returns NULL without setting an exception.
	NULL with an exception means an error occurred. */</comment>

<comment type="block">/*  Number Protocol:*/</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Returns 1 if the object, o, provides numeric protocols, and
	 false otherwise. 

	 This function always succeeds.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of adding o1 and o2, or null on failure.
	 This is the equivalent of the Python expression: o1+o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Subtract</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of subtracting o2 from o1, or null on
	 failure.  This is the equivalent of the Python expression:
	 o1-o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of multiplying o1 and o2, or null on
	 failure.  This is the equivalent of the Python expression:
	 o1*o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Divide</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of dividing o1 by o2, or null on failure.
	 This is the equivalent of the Python expression: o1/o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_FloorDivide</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of dividing o1 by o2 giving an integral result,
	 or null on failure.
	 This is the equivalent of the Python expression: o1//o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_TrueDivide</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of dividing o1 by o2 giving a float result,
	 or null on failure.
	 This is the equivalent of the Python expression: o1/o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Remainder</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the remainder of dividing o1 by o2, or null on
	 failure.  This is the equivalent of the Python expression:
	 o1%o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Divmod</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 See the built-in function divmod.  Returns NULL on failure.
	 This is the equivalent of the Python expression:
	 divmod(o1,o2).


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Power</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>,
                                          <argument><expr><name>PyObject</name> *<name>o3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 See the built-in function pow.  Returns NULL on failure.
	 This is the equivalent of the Python expression:
	 pow(o1,o2,o3), where o3 is optional.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Negative</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the negation of o on success, or null on failure.
	 This is the equivalent of the Python expression: -o.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Positive</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Returns the (what?) of o on success, or NULL on failure.
	 This is the equivalent of the Python expression: +o.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Absolute</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the absolute value of o, or null on failure.  This is
	 the equivalent of the Python expression: abs(o).

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Invert</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the bitwise negation of o on success, or NULL on
	 failure.  This is the equivalent of the Python expression:
	 ~o.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Lshift</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of left shifting o1 by o2 on success, or
	 NULL on failure.  This is the equivalent of the Python
	 expression: o1 &lt;&lt; o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Rshift</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of right shifting o1 by o2 on success, or
	 NULL on failure.  This is the equivalent of the Python
	 expression: o1 &gt;&gt; o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_And</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of bitwise and of o1 and o2 on success, or
	 NULL on failure. This is the equivalent of the Python
	 expression: o1&amp;o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Xor</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the bitwise exclusive or of o1 by o2 on success, or
	 NULL on failure.  This is the equivalent of the Python
	 expression: o1^o2.


       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Or</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of bitwise or on o1 and o2 on success, or
	 NULL on failure.  This is the equivalent of the Python
	 expression: o1|o2.

       */</comment>

     <comment type="block">/* Implemented elsewhere:

     int PyNumber_Coerce(PyObject **p1, PyObject **p2);

	 This function takes the addresses of two variables of type
	 PyObject*.

	 If the objects pointed to by *p1 and *p2 have the same type,
	 increment their reference count and return 0 (success).
	 If the objects can be converted to a common numeric type,
	 replace *p1 and *p2 by their converted value (with 'new'
	 reference counts), and return 0.
	 If no conversion is possible, or if some other error occurs,
	 return -1 (failure) and don't increment the reference counts.
	 The call PyNumber_Coerce(&amp;o1, &amp;o2) is equivalent to the Python
	 statement o1, o2 = coerce(o1, o2).

       */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyIndex_Check</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro> \
   <cpp:value>((obj)-&gt;ob_type-&gt;tp_as_number != NULL &amp;&amp; \
    PyType_HasFeature((obj)-&gt;ob_type, Py_TPFLAGS_HAVE_INDEX) &amp;&amp; \
    (obj)-&gt;ob_type-&gt;tp_as_number-&gt;nb_index != NULL)</cpp:value></cpp:define>
        
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Index</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the object converted to a Python long or int
	 or NULL with an error raised on failure.
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Returns the Integral instance converted to an int. The
         instance is expected to be int or long or have an __int__
         method. Steals integral's reference. error_format will be
         used to create the TypeError if integral isn't actually an
         Integral instance. error_format should be a format string
         that can accept a char* naming integral's type.
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyNumber_ConvertIntegralToInt</name><argument_list>(
             <argument><expr><name>PyObject</name> *<name>integral</name></expr></argument>,
             <argument><expr>const <name>char</name>* <name>error_format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
        Returns the object converted to Py_ssize_t by going through
        PyNumber_Index first.  If an overflow error occurs while
        converting the int-or-long to Py_ssize_t, then the second argument
        is the error-type to return.  If it is NULL, then the overflow error
        is cleared and the value is clipped. 
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the o converted to an integer object on success, or
	 NULL on failure.  This is the equivalent of the Python
	 expression: int(o).

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Long</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the o converted to a long integer object on success,
	 or NULL on failure.  This is the equivalent of the Python
	 expression: long(o).

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_Float</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the o converted to a float object on success, or NULL
	 on failure.  This is the equivalent of the Python expression:
	 float(o).
       */</comment>
	 
<comment type="block">/*  In-place variants of (some of) the above number protocol functions */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceAdd</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of adding o2 to o1, possibly in-place, or null
	 on failure.  This is the equivalent of the Python expression:
	 o1 += o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceSubtract</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of subtracting o2 from o1, possibly in-place or
	 null on failure.  This is the equivalent of the Python expression:
	 o1 -= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceMultiply</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of multiplying o1 by o2, possibly in-place, or
	 null on failure.  This is the equivalent of the Python expression:
	 o1 *= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceDivide</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of dividing o1 by o2, possibly in-place, or null
	 on failure.  This is the equivalent of the Python expression:
	 o1 /= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceFloorDivide</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>,
						       <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of dividing o1 by o2 giving an integral result,
	 possibly in-place, or null on failure.
	 This is the equivalent of the Python expression:
	 o1 /= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceTrueDivide</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>,
						      <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of dividing o1 by o2 giving a float result,
	 possibly in-place, or null on failure.
	 This is the equivalent of the Python expression:
	 o1 /= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceRemainder</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the remainder of dividing o1 by o2, possibly in-place, or
	 null on failure.  This is the equivalent of the Python expression:
	 o1 %= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlacePower</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>,
     						 <argument><expr><name>PyObject</name> *<name>o3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of raising o1 to the power of o2, possibly
	 in-place, or null on failure.  This is the equivalent of the Python
	 expression: o1 **= o2, or pow(o1, o2, o3) if o3 is present.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceLshift</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of left shifting o1 by o2, possibly in-place, or
	 null on failure.  This is the equivalent of the Python expression:
	 o1 &lt;&lt;= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceRshift</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of right shifting o1 by o2, possibly in-place or
	 null on failure.  This is the equivalent of the Python expression:
	 o1 &gt;&gt;= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceAnd</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of bitwise and of o1 and o2, possibly in-place,
	 or null on failure. This is the equivalent of the Python
	 expression: o1 &amp;= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceXor</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the bitwise exclusive or of o1 by o2, possibly in-place, or
	 null on failure.  This is the equivalent of the Python expression:
	 o1 ^= o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyNumber_InPlaceOr</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the result of bitwise or of o1 and o2, possibly in-place,
	 or null on failure.  This is the equivalent of the Python
	 expression: o1 |= o2.

       */</comment>


     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PyNumber_ToBase</name><argument_list>(<argument>PyObject *n</argument>, <argument>int base</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
	 Returns the integer n converted to a string with a base, with a base
	 marker of 0b, 0o or 0x prefixed if applicable.
	 If n is not an int object, it is converted with PyNumber_Index first.
       */</comment>


<comment type="block">/*  Sequence protocol:*/</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Check</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Return 1 if the object provides sequence protocol, and zero
	 otherwise.  

	 This function always succeeds.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Size</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Return the size of sequence object o, or -1 on failure.

       */</comment>

       <comment type="block">/* For DLL compatibility */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PySequence_Length</name></cpp:undef>
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Length</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySequence_Length</name></cpp:macro> <cpp:value>PySequence_Size</cpp:value></cpp:define>


     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Concat</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Return the concatenation of o1 and o2 on success, and NULL on
	 failure.   This is the equivalent of the Python
	 expression: o1+o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PySequence_Repeat</name><argument_list>(<argument>PyObject *o</argument>, <argument>Py_ssize_t count</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
	 Return the result of repeating sequence object o count times,
	 or NULL on failure.  This is the equivalent of the Python
	 expression: o1*count.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PySequence_GetItem</name><argument_list>(<argument>PyObject *o</argument>, <argument>Py_ssize_t i</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
	 Return the ith element of o, or NULL on failure. This is the
	 equivalent of the Python expression: o[i].
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PySequence_GetSlice</name><argument_list>(<argument>PyObject *o</argument>, <argument>Py_ssize_t i1</argument>, <argument>Py_ssize_t i2</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
	 Return the slice of sequence object o between i1 and i2, or
	 NULL on failure. This is the equivalent of the Python
	 expression: o[i1:i2].

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PySequence_SetItem</name><argument_list>(<argument>PyObject *o</argument>, <argument>Py_ssize_t i</argument>, <argument>PyObject *v</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
	 Assign object v to the ith element of o.  Returns
	 -1 on failure.  This is the equivalent of the Python
	 statement: o[i]=v.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PySequence_DelItem</name><argument_list>(<argument>PyObject *o</argument>, <argument>Py_ssize_t i</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
	 Delete the ith element of object v.  Returns
	 -1 on failure.  This is the equivalent of the Python
	 statement: del o[i].
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PySequence_SetSlice</name><argument_list>(<argument>PyObject *o</argument>, <argument>Py_ssize_t i1</argument>, <argument>Py_ssize_t i2</argument>,
                                        <argument>PyObject *v</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
         Assign the sequence object, v, to the slice in sequence
	 object, o, from i1 to i2.  Returns -1 on failure. This is the
	 equivalent of the Python statement: o[i1:i2]=v.
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PySequence_DelSlice</name><argument_list>(<argument>PyObject *o</argument>, <argument>Py_ssize_t i1</argument>, <argument>Py_ssize_t i2</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
	 Delete the slice in sequence object, o, from i1 to i2.
	 Returns -1 on failure. This is the equivalent of the Python
	 statement: del o[i1:i2].
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Returns the sequence, o, as a tuple on success, and NULL on failure.
	 This is equivalent to the Python expression: tuple(o)
       */</comment>


     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_List</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <comment type="block">/*
	 Returns the sequence, o, as a list on success, and NULL on failure.
	 This is equivalent to the Python expression: list(o)
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr>const <name>char</name>* <name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <comment type="block">/*
         Returns the sequence, o, as a tuple, unless it's already a
         tuple or list.  Use PySequence_Fast_GET_ITEM to access the
         members of this list, and PySequence_Fast_GET_SIZE to get its length.

         Returns NULL on failure.  If the object does not support iteration,
         raises a TypeError exception with m as the message text.
       */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySequence_Fast_GET_SIZE</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))</cpp:value></cpp:define>
       <comment type="block">/*
	 Return the size of o, assuming that o was returned by
         PySequence_Fast and is not NULL.
       */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySequence_Fast_GET_ITEM</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro>\
     <cpp:value>(PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))</cpp:value></cpp:define>
       <comment type="block">/*
	 Return the ith element of o, assuming that o was returned by
         PySequence_Fast, and that i is within bounds.
       */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySequence_ITEM</name><parameter_list>(<param><type><name>o</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro>\
	<cpp:value>( Py_TYPE(o)-&gt;tp_as_sequence-&gt;sq_item(o, i) )</cpp:value></cpp:define>
       <comment type="block">/* Assume tp_as_sequence and sq_item exist and that i does not
	  need to be corrected for a negative index
       */</comment>     

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySequence_Fast_ITEMS</name><parameter_list>(<param><type><name>sf</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(PyList_Check(sf) ? ((PyListObject *)(sf))-&gt;ob_item \
			  : ((PyTupleObject *)(sf))-&gt;ob_item)</cpp:value></cpp:define>
	<comment type="block">/* Return a pointer to the underlying item array for
           an object retured by PySequence_Fast */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Count</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Return the number of occurrences on value on o, that is,
	 return the number of keys for which o[key]==value.  On
	 failure, return -1.  This is equivalent to the Python
	 expression: o.count(value).
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Contains</name><argument_list>(<argument><expr><name>PyObject</name> *<name>seq</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>ob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <comment type="block">/*
         Return -1 if error; 1 if ob in seq; 0 if ob not in seq.
         Use __contains__ if possible, else _PySequence_IterSearch().
       */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ITERSEARCH_COUNT</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ITERSEARCH_INDEX</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ITERSEARCH_CONTAINS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <macro><name>_PySequence_IterSearch</name><argument_list>(<argument>PyObject *seq</argument>,
     					<argument>PyObject *obj</argument>, <argument>int operation</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	<comment type="block">/*
	  Iterate over seq.  Result depends on the operation:
	  PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if
	  	error.
	  PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of
	  	obj in seq; set ValueError and return -1 if none found;
	  	also return -1 on error.
	  PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on
	  	error.
	*/</comment>

<comment type="block">/* For DLL-level backwards compatibility */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PySequence_In</name></cpp:undef>
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_In</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* For source-level backwards compatibility */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySequence_In</name></cpp:macro> <cpp:value>PySequence_Contains</cpp:value></cpp:define>

       <comment type="block">/*
	 Determine if o contains value.  If an item in o is equal to
	 X, return 1, otherwise return 0.  On error, return -1.  This
	 is equivalent to the Python expression: value in o.
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_Index</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Return the first index for which o[i]=value.  On error,
	 return -1.    This is equivalent to the Python
	 expression: o.index(value).
       */</comment>

<comment type="block">/* In-place versions of some of the above Sequence functions. */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySequence_InPlaceConcat</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o1</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Append o2 to o1, in-place when possible. Return the resulting
	 object, which could be o1, or NULL on failure.  This is the
	 equivalent of the Python expression: o1 += o2.

       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>PySequence_InPlaceRepeat</name><argument_list>(<argument>PyObject *o</argument>, <argument>Py_ssize_t count</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

       <comment type="block">/*
	 Repeat o1 by count, in-place when possible. Return the resulting
	 object, which could be o1, or NULL on failure.  This is the
	 equivalent of the Python expression: o1 *= count.

       */</comment>

<comment type="block">/*  Mapping protocol:*/</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMapping_Check</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Return 1 if the object provides mapping protocol, and zero
	 otherwise.  

	 This function always succeeds.
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMapping_Size</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
         Returns the number of keys in object o on success, and -1 on
	 failure.  For objects that do not provide sequence protocol,
	 this is equivalent to the Python expression: len(o).
       */</comment>

       <comment type="block">/* For DLL compatibility */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PyMapping_Length</name></cpp:undef>
     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMapping_Length</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMapping_Length</name></cpp:macro> <cpp:value>PyMapping_Size</cpp:value></cpp:define>


     <comment type="block">/* implemented as a macro:

     int PyMapping_DelItemString(PyObject *o, char *key);

	 Remove the mapping for object, key, from the object *o.
	 Returns -1 on failure.  This is equivalent to
	 the Python statement: del o[key].
       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMapping_DelItemString</name><parameter_list>(<param><type><name>O</name></type></param>,<param><type><name>K</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_DelItemString((O),(K))</cpp:value></cpp:define>

     <comment type="block">/* implemented as a macro:

     int PyMapping_DelItem(PyObject *o, PyObject *key);

	 Remove the mapping for object, key, from the object *o.
	 Returns -1 on failure.  This is equivalent to
	 the Python statement: del o[key].
       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMapping_DelItem</name><parameter_list>(<param><type><name>O</name></type></param>,<param><type><name>K</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_DelItem((O),(K))</cpp:value></cpp:define>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMapping_HasKeyString</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>char</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 On success, return 1 if the mapping object has the key, key,
	 and 0 otherwise.  This is equivalent to the Python expression:
	 o.has_key(key). 

	 This function always succeeds.
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMapping_HasKey</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Return 1 if the mapping object has the key, key,
	 and 0 otherwise.  This is equivalent to the Python expression:
	 o.has_key(key). 

	 This function always succeeds.

       */</comment>

     <comment type="block">/* Implemented as macro:

     PyObject *PyMapping_Keys(PyObject *o);

         On success, return a list of the keys in object o.  On
	 failure, return NULL. This is equivalent to the Python
	 expression: o.keys().
       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMapping_Keys</name><parameter_list>(<param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_CallMethod(O,"keys",NULL)</cpp:value></cpp:define>

     <comment type="block">/* Implemented as macro:

     PyObject *PyMapping_Values(PyObject *o);

         On success, return a list of the values in object o.  On
	 failure, return NULL. This is equivalent to the Python
	 expression: o.values().
       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMapping_Values</name><parameter_list>(<param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_CallMethod(O,"values",NULL)</cpp:value></cpp:define>

     <comment type="block">/* Implemented as macro:

     PyObject *PyMapping_Items(PyObject *o);

         On success, return a list of the items in object o, where
	 each item is a tuple containing a key-value pair.  On
	 failure, return NULL. This is equivalent to the Python
	 expression: o.items().

       */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMapping_Items</name><parameter_list>(<param><type><name>O</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_CallMethod(O,"items",NULL)</cpp:value></cpp:define>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMapping_GetItemString</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>char</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Return element of o corresponding to the object, key, or NULL
	 on failure. This is the equivalent of the Python expression:
	 o[key].
       */</comment>

     <macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMapping_SetItemString</name><argument_list>(<argument><expr><name>PyObject</name> *<name>o</name></expr></argument>, <argument><expr><name>char</name> *<name>key</name></expr></argument>,
                                            <argument><expr><name>PyObject</name> *<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <comment type="block">/*
	 Map the object, key, to the value, v.  Returns 
	 -1 on failure.  This is the equivalent of the Python
	 statement: o[key]=v.
      */</comment>


<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>PyObject</name> *<name>object</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>typeorclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* isinstance(object, typeorclass) */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_IsSubclass</name><argument_list>(<argument><expr><name>PyObject</name> *<name>object</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>typeorclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* issubclass(object, typeorclass) */</comment>


<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_RealIsInstance</name><argument_list>(<argument><expr><name>PyObject</name> *<name>inst</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_RealIsSubclass</name><argument_list>(<argument><expr><name>PyObject</name> *<name>derived</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>cls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_ABSTRACTOBJECT_H */</comment>
</unit>
