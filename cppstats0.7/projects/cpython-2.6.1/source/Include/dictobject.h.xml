<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/dictobject.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_DICTOBJECT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_DICTOBJECT_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Dictionary object type -- mapping from hashable object to object */</comment>

<comment type="block">/* The distribution includes a separate file, Objects/dictnotes.txt,
   describing explorations into dictionary design and optimization.
   It covers typical dictionary use patterns, the parameters for
   tuning dictionaries, and several ideas for possible optimizations.
*/</comment>

<comment type="block">/*
There are three kinds of slots in the table:

1. Unused.  me_key == me_value == NULL
   Does not hold an active (key, value) pair now and never did.  Unused can
   transition to Active upon key insertion.  This is the only case in which
   me_key is NULL, and is each slot's initial state.

2. Active.  me_key != NULL and me_key != dummy and me_value != NULL
   Holds an active (key, value) pair.  Active can transition to Dummy upon
   key deletion.  This is the only case in which me_value != NULL.

3. Dummy.  me_key == dummy and me_value == NULL
   Previously held an active (key, value) pair, but that was deleted and an
   active pair has not yet overwritten the slot.  Dummy can transition to
   Active upon key insertion.  Dummy slots cannot be made Unused again
   (cannot have me_key set to NULL), else the probe sequence in case of
   collision would have no way to know they were once active.

Note: .popitem() abuses the me_hash field of an Unused or Dummy slot to
hold a search finger.  The me_hash field of Unused or Dummy slots has no
meaning otherwise.
*/</comment>

<comment type="block">/* PyDict_MINSIZE is the minimum size of a dictionary.  This many slots are
 * allocated directly in the dict object (in the ma_smalltable member).
 * It must be a power of 2, and at least 4.  8 allows dicts with no more
 * than 5 active entries to live in ma_smalltable (and so avoid an
 * additional malloc); instrumentation suggested this suffices for the
 * majority of dicts (consisting mostly of usually-small instance dicts and
 * usually-small dicts created to pass keyword arguments).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDict_MINSIZE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
	<comment type="block">/* Cached hash code of me_key.  Note that hash codes are C longs.
	 * We have to use Py_ssize_t instead because dict_popitem() abuses
	 * me_hash to hold a search finger.
	 */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>me_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>me_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>me_value</name></decl>;</decl_stmt>
}</block></struct></type> <name>PyDictEntry</name>;</typedef>

<comment type="block">/*
To ensure the lookup algorithm terminates, there must be at least one Unused
slot (NULL key) in the table.
The value ma_fill is the number of non-NULL keys (sum of Active and Dummy);
ma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL
values == the number of Active items).
To avoid slowing down lookups on a near-full table, we resize the table when
it's two-thirds full.
*/</comment>
<typedef>typedef <type>struct <name>_dictobject</name></type> <name>PyDictObject</name>;</typedef>
<struct>struct <name>_dictobject</name> <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>Py_ssize_t</name></type> <name>ma_fill</name></decl>;</decl_stmt>  <comment type="block">/* # Active + # Dummy */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ma_used</name></decl>;</decl_stmt>  <comment type="block">/* # Active */</comment>

	<comment type="block">/* The table contains ma_mask + 1 slots, and that's a power of 2.
	 * We store the mask instead of the size because the mask is more
	 * frequently needed.
	 */</comment>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ma_mask</name></decl>;</decl_stmt>

	<comment type="block">/* ma_table points to ma_smalltable for small tables, else to
	 * additional malloc'ed memory.  ma_table is never NULL!  This rule
	 * saves repeated runtime null-tests in the workhorse getitem and
	 * setitem calls.
	 */</comment>
	<decl_stmt><decl><type><name>PyDictEntry</name> *</type><name>ma_table</name></decl>;</decl_stmt>
	<function_decl><type><name>PyDictEntry</name> *</type>(*<name>ma_lookup</name>)<parameter_list>(<param><decl><type><name>PyDictObject</name> *</type><name>mp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>key</name></decl></param>, <param><decl><type><name>long</name></type> <name>hash</name></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>PyDictEntry</name></type> <name><name>ma_smalltable</name><index>[<expr><name>PyDict_MINSIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<macro><name>PyAPI_DATA</name><argument_list>(<argument>PyTypeObject</argument>)</argument_list></macro> <expr_stmt><expr><name>PyDict_Type</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDict_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> \
                 <cpp:value>PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDict_CheckExact</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PyDict_Type)</cpp:value></cpp:define>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_New</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>key</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Next</name><argument_list>(
	<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>, <argument><expr><name>Py_ssize_t</name> *<name>pos</name></expr></argument>, <argument><expr><name>PyObject</name> **<name>key</name></expr></argument>, <argument><expr><name>PyObject</name> **<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyDict_Next</name><argument_list>(
	<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>, <argument><expr><name>Py_ssize_t</name> *<name>pos</name></expr></argument>, <argument><expr><name>PyObject</name> **<name>key</name></expr></argument>, <argument><expr><name>PyObject</name> **<name>value</name></expr></argument>, <argument><expr><name>long</name> *<name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Keys</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Values</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Items</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Copy</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Contains</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyDict_Contains</name><argument_list>(<argument>PyObject *mp</argument>, <argument>PyObject *key</argument>, <argument>long hash</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>_PyDict_NewPresized</name><argument_list>(<argument>Py_ssize_t minused</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>PyObject</name> *<name>mp</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* PyDict_Merge updates/merges from a mapping object (an object that
   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
   the last occurrence of a key wins, else the first.  The Python
   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
*/</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyDict_Merge</name><argument_list>(<argument>PyObject *mp</argument>,
				   <argument>PyObject *other</argument>,
				   <argument>int override</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
   iterable objects of length 2.  If override is true, the last occurrence
   of a key wins, else the first.  The Python dict constructor dict(seq2)
   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
*/</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyDict_MergeFromSeq2</name><argument_list>(<argument>PyObject *d</argument>,
					   <argument>PyObject *seq2</argument>,
					   <argument>int override</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>PyObject</name> *<name>dp</name></expr></argument>, <argument><expr>const <name>char</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>PyObject</name> *<name>dp</name></expr></argument>, <argument><expr>const <name>char</name> *<name>key</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyDict_DelItemString</name><argument_list>(<argument><expr><name>PyObject</name> *<name>dp</name></expr></argument>, <argument><expr>const <name>char</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_DICTOBJECT_H */</comment>
</unit>
