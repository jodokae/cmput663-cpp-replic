<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/pyport.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_PYPORT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_PYPORT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyconfig.h"</cpp:file></cpp:include> <comment type="block">/* include for defines */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STDINT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**************************************************************************
Symbols and macros to supply platform-independent interfaces to basic
C language &amp; library operations whose spellings vary across platforms.

Please try to make documentation here as clear as possible:  by definition,
the stuff here is trying to illuminate C's darkest corners.

Config #defines referenced here:

SIGNED_RIGHT_SHIFT_ZERO_FILLS
Meaning:  To be defined iff i&gt;&gt;j does not extend the sign bit when i is a
          signed integral type and i &lt; 0.
Used in:  Py_ARITHMETIC_RIGHT_SHIFT

Py_DEBUG
Meaning:  Extra checks compiled in for debug mode.
Used in:  Py_SAFE_DOWNCAST

HAVE_UINTPTR_T
Meaning:  The C9X type uintptr_t is supported by the compiler
Used in:  Py_uintptr_t

HAVE_LONG_LONG
Meaning:  The compiler supports the C type "long long"
Used in:  PY_LONG_LONG

**************************************************************************/</comment>


<comment type="block">/* For backward compatibility only. Obsolete, do not use. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PROTOTYPES</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_PROTO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_PROTO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>()</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_FPROTO</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_FPROTO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_PROTO(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* typedefs for some C9X-defined synonyms for integral types.
 *
 * The names in Python are exactly the same as the C9X names, except with a
 * Py_ prefix.  Until C9X is universally implemented, this is the only way
 * to ensure that Python gets reliable names that don't conflict with names
 * in non-Python code that are playing their own tricks to define the C9X
 * names.
 *
 * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
 * integral synonyms.  Only define the ones we actually need.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PY_LONG_LONG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LONG_LONG</name></cpp:macro> <cpp:value>long long</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LLONG_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* If LLONG_MAX is defined in limits.h, use that. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LLONG_MIN</name></cpp:macro> <cpp:value>LLONG_MIN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LLONG_MAX</name></cpp:macro> <cpp:value>LLONG_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ULLONG_MAX</name></cpp:macro> <cpp:value>ULLONG_MAX</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__LONG_LONG_MAX__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* Otherwise, if GCC has a builtin define, use that. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LLONG_MAX</name></cpp:macro> <cpp:value>__LONG_LONG_MAX__</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LLONG_MIN</name></cpp:macro> <cpp:value>(-PY_LLONG_MAX-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ULLONG_MAX</name></cpp:macro> <cpp:value>(__LONG_LONG_MAX__*2ULL + 1ULL)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Otherwise, rely on two's complement. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ULLONG_MAX</name></cpp:macro> <cpp:value>(~0ULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LLONG_MAX</name></cpp:macro>  <cpp:value>((long long)(PY_ULLONG_MAX&gt;&gt;1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_LLONG_MIN</name></cpp:macro> <cpp:value>(-PY_LLONG_MAX-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* LLONG_MAX */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LONG_LONG */</comment>

<comment type="block">/* uintptr_t is the C9X name for an unsigned integral type such that a
 * legitimate void* can be cast to uintptr_t and then back to void* again
 * without loss of information.  Similarly for intptr_t, wrt a signed
 * integral type.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UINTPTR_T</name></cpp:ifdef>
<typedef>typedef <type><name>uintptr_t</name></type>	<name>Py_uintptr_t</name>;</typedef>
<typedef>typedef <type><name>intptr_t</name></type>	<name>Py_intptr_t</name>;</typedef>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_VOID_P</name> &lt;= <name>SIZEOF_INT</name></expr></cpp:elif>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type>	<name>Py_uintptr_t</name>;</typedef>
<typedef>typedef <type><name>int</name></type>		<name>Py_intptr_t</name>;</typedef>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_VOID_P</name> &lt;= <name>SIZEOF_LONG</name></expr></cpp:elif>
<typedef>typedef <type><name>unsigned</name> <name>long</name></type>	<name>Py_uintptr_t</name>;</typedef>
<typedef>typedef <type><name>long</name></type>		<name>Py_intptr_t</name>;</typedef>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SIZEOF_VOID_P</name> &lt;= <name>SIZEOF_LONG_LONG</name>)</expr></cpp:elif>
<typedef>typedef <type><name>unsigned</name> <name>PY_LONG_LONG</name></type>	<name>Py_uintptr_t</name>;</typedef>
<typedef>typedef <type><name>PY_LONG_LONG</name></type>		<name>Py_intptr_t</name>;</typedef>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#   <cpp:directive>error</cpp:directive> "Python needs a typedef for Py_uintptr_t in pyport.h."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_UINTPTR_T */</comment>

<comment type="block">/* Py_ssize_t is a signed integral type such that sizeof(Py_ssize_t) ==
 * sizeof(size_t).  C99 doesn't define such a thing directly (size_t is an
 * unsigned integral type).  See PEP 353 for details.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SSIZE_T</name></cpp:ifdef>
<typedef>typedef <type><name>ssize_t</name></type>		<name>Py_ssize_t</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_VOID_P</name> == <name>SIZEOF_SIZE_T</name></expr></cpp:elif>
<typedef>typedef <type><name>Py_intptr_t</name></type>	<name>Py_ssize_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#   <cpp:directive>error</cpp:directive> "Python needs a typedef for Py_ssize_t in pyport.h."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Largest possible value of size_t.
   SIZE_MAX is part of C99, so it might be defined on some
   platforms. If it is not defined, (size_t)-1 is a portable
   definition for C89, due to the way signed-&gt;unsigned 
   conversion is defined. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIZE_MAX</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SIZE_MAX</name></cpp:macro> <cpp:value>SIZE_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SIZE_MAX</name></cpp:macro> <cpp:value>((size_t)-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Largest positive value of type Py_ssize_t. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_MAX</name></cpp:macro> <cpp:value>((Py_ssize_t)(((size_t)-1)&gt;&gt;1))</cpp:value></cpp:define>
<comment type="block">/* Smallest negative value of type Py_ssize_t. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_MIN</name></cpp:macro> <cpp:value>(-PY_SSIZE_T_MAX-1)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_PID_T</name> &gt; <name>SIZEOF_LONG</name></expr></cpp:if>
<cpp:error>#   <cpp:directive>error</cpp:directive> "Python doesn't support sizeof(pid_t) &gt; sizeof(long)"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* PY_FORMAT_SIZE_T is a platform-specific modifier for use in a printf
 * format to convert an argument with the width of a size_t or Py_ssize_t.
 * C99 introduced "z" for this purpose, but not all platforms support that;
 * e.g., MS compilers use "I" instead.
 *
 * These "high level" Python format functions interpret "z" correctly on
 * all platforms (Python interprets the format string itself, and does whatever
 * the platform C requires to convert a size_t/Py_ssize_t argument):
 *
 *     PyString_FromFormat
 *     PyErr_Format
 *     PyString_FromFormatV
 *
 * Lower-level uses require that you interpolate the correct format modifier
 * yourself (e.g., calling printf, fprintf, sprintf, PyOS_snprintf); for
 * example,
 *
 *     Py_ssize_t index;
 *     fprintf(stderr, "index %" PY_FORMAT_SIZE_T "d sucks\n", index);
 *
 * That will expand to %ld, or %Id, or to something else correct for a
 * Py_ssize_t on the platform.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PY_FORMAT_SIZE_T</name></cpp:ifndef>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> == <name>SIZEOF_INT</name> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#       <cpp:directive>define</cpp:directive> <cpp:macro><name>PY_FORMAT_SIZE_T</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:elif>#   <cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> == <name>SIZEOF_LONG</name></expr></cpp:elif>
<cpp:define>#       <cpp:directive>define</cpp:directive> <cpp:macro><name>PY_FORMAT_SIZE_T</name></cpp:macro> <cpp:value>"l"</cpp:value></cpp:define>
<cpp:elif>#   <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#       <cpp:directive>define</cpp:directive> <cpp:macro><name>PY_FORMAT_SIZE_T</name></cpp:macro> <cpp:value>"I"</cpp:value></cpp:define>
<cpp:else>#   <cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#       <cpp:directive>error</cpp:directive> "This platform's pyconfig.h needs to define PY_FORMAT_SIZE_T"</cpp:error>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_LOCAL can be used instead of static to get the fastest possible calling
 * convention for functions that are local to a given module.
 *
 * Py_LOCAL_INLINE does the same thing, and also explicitly requests inlining,
 * for platforms that support that.
 *
 * If PY_LOCAL_AGGRESSIVE is defined before python.h is included, more
 * "aggressive" inlining/optimizaion is enabled for the entire module.  This
 * may lead to code bloat, and may slow things down for those reasons.  It may
 * also lead to errors, if the code relies on pointer aliasing.  Use with
 * care.
 *
 * NOTE: You can only use this for functions that are entirely local to a
 * module; functions that are exported via method tables, callbacks, etc,
 * should keep using static.
 */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_INLINE</name></cpp:undef> <comment type="block">/* XXX - set via configure? */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_LOCAL_AGGRESSIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* enable more aggressive optimization for visual studio */</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> optimize("agtw", on)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* ignore warnings if the compiler decides not to inline a function */</comment> 
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(disable: 4710)</cpp:pragma>
<comment type="block">/* fastest possible local call under MSVC */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_LOCAL</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static type __fastcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_LOCAL_INLINE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static __inline type __fastcall</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_INLINE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_LOCAL</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_LOCAL_INLINE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static inline type</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_LOCAL</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_LOCAL_INLINE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static type</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_MEMCPY can be used instead of memcpy in cases where the copied blocks
 * are often very short.  While most platforms have highly optimized code for
 * large transfers, the setup costs for memcpy are often quite high.  MEMCPY
 * solves this by doing short copies "in line".
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_MEMCPY</name><parameter_list>(<param><type><name>target</name></type></param>, <param><type><name>source</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {				\
		size_t i_, n_ = (length);				\
		char *t_ = (void*) (target);				\
		const char *s_ = (void*) (source);			\
		if (n_ &gt;= 16)						\
			memcpy(t_, s_, n_);				\
		else							\
			for (i_ = 0; i_ &lt; n_; i_++)			\
				t_[i_] = s_[i_];			\
	} while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_MEMCPY</name></cpp:macro> <cpp:value>memcpy</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include> <comment type="block">/* Moved here from the math section, before extern "C" */</comment>

<comment type="block">/********************************************
 * WRAPPER FOR &lt;time.h&gt; and/or &lt;sys/time.h&gt; *
 ********************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TIME_WITH_SYS_TIME</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TIME_WITH_SYS_TIME */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_TIME_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !HAVE_SYS_TIME_H */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_SYS_TIME_H */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TIME_WITH_SYS_TIME */</comment>


<comment type="block">/******************************
 * WRAPPER FOR &lt;sys/select.h&gt; *
 ******************************/</comment>

<comment type="block">/* NB caller must include &lt;sys/types.h&gt; */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !HAVE_SYS_SELECT_H */</comment>

<comment type="block">/*******************************
 * stat() and fstat() fiddling *
 *******************************/</comment>

<comment type="block">/* We expect that stat and fstat exist on most systems.
 *  It's confirmed on Unix, Mac and Windows.
 *  If you don't have them, add
 *      #define DONT_HAVE_STAT
 * and/or
 *      #define DONT_HAVE_FSTAT
 * to your pyconfig.h. Python code beyond this should check HAVE_STAT and
 * HAVE_FSTAT instead.
 * Also
 *      #define HAVE_SYS_STAT_H
 * if &lt;sys/stat.h&gt; exists on your platform, and
 *      #define HAVE_STAT_H
 * if &lt;stat.h&gt; does.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DONT_HAVE_STAT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_STAT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DONT_HAVE_FSTAT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FSTAT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RISCOS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unixstuff.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_STAT_H</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYCC_VACPP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* VisualAge C/C++ Failed to Define MountType Field in sys/stat.h */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFMT</name></cpp:macro> <cpp:value>(S_IFDIR|S_IFCHR|S_IFREG)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_ISREG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISREG</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((x) &amp; S_IFMT) == S_IFREG)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_ISDIR</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISDIR</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((x) &amp; S_IFMT) == S_IFDIR)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<comment type="block">/* Move this down here since some C++ #include's don't like to be included
   inside an extern "C" */</comment>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Py_ARITHMETIC_RIGHT_SHIFT
 * C doesn't define whether a right-shift of a signed integer sign-extends
 * or zero-fills.  Here a macro to force sign extension:
 * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
 *    Return I &gt;&gt; J, forcing sign extension.
 * Requirements:
 *    I is of basic signed type TYPE (char, short, int, long, or long long).
 *    TYPE is one of char, short, int, long, or long long, although long long
 *    must not be used except on platforms that support it.
 *    J is an integer &gt;= 0 and strictly less than the number of bits in TYPE
 *    (because C doesn't define what happens for J outside that range either).
 * Caution:
 *    I may be evaluated more than once.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGNED_RIGHT_SHIFT_ZERO_FILLS</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_ARITHMETIC_RIGHT_SHIFT</name><parameter_list>(<param><type><name>TYPE</name></type></param>, <param><type><name>I</name></type></param>, <param><type><name>J</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>((I) &lt; 0 ? ~((~(unsigned TYPE)(I)) &gt;&gt; (J)) : (I) &gt;&gt; (J))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_ARITHMETIC_RIGHT_SHIFT</name><parameter_list>(<param><type><name>TYPE</name></type></param>, <param><type><name>I</name></type></param>, <param><type><name>J</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((I) &gt;&gt; (J))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_FORCE_EXPANSION(X)
 * "Simply" returns its argument.  However, macro expansions within the
 * argument are evaluated.  This unfortunate trickery is needed to get
 * token-pasting to work as desired in some cases.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_FORCE_EXPANSION</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>X</cpp:value></cpp:define>

<comment type="block">/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
 * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
 * assert-fails if any information is lost.
 * Caution:
 *    VALUE may be evaluated more than once.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_SAFE_DOWNCAST</name><parameter_list>(<param><type><name>VALUE</name></type></param>, <param><type><name>WIDE</name></type></param>, <param><type><name>NARROW</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>(assert((WIDE)(NARROW)(VALUE) == (VALUE)), (NARROW)(VALUE))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_SAFE_DOWNCAST</name><parameter_list>(<param><type><name>VALUE</name></type></param>, <param><type><name>WIDE</name></type></param>, <param><type><name>NARROW</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(NARROW)(VALUE)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_SET_ERRNO_ON_MATH_ERROR(x)
 * If a libm function did not set errno, but it looks like the result
 * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno
 * to 0 before calling a libm function, and invoke this macro after,
 * passing the function result.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X is evaluated more than once.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call> || (<call><name>defined</name><argument_list>(<argument><expr><name>__hpux</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call>)</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_Py_SET_EDOM_FOR_NAN</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (isnan(X)) errno = EDOM;</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_Py_SET_EDOM_FOR_NAN</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>;</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_SET_ERRNO_ON_MATH_ERROR</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (errno == 0) { \
			if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL) \
				errno = ERANGE; \
			else _Py_SET_EDOM_FOR_NAN(X) \
		} \
	} while(0)</cpp:value></cpp:define>

<comment type="block">/* Py_SET_ERANGE_ON_OVERFLOW(x)
 * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_SET_ERANGE_IF_OVERFLOW</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_SET_ERRNO_ON_MATH_ERROR(X)</cpp:value></cpp:define>

<comment type="block">/* Py_ADJUST_ERANGE1(x)
 * Py_ADJUST_ERANGE2(x, y)
 * Set errno to 0 before calling a libm function, and invoke one of these
 * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful
 * for functions returning complex results).  This makes two kinds of
 * adjustments to errno:  (A) If it looks like the platform libm set
 * errno=ERANGE due to underflow, clear errno. (B) If it looks like the
 * platform libm overflowed but didn't set errno, force errno to ERANGE.  In
 * effect, we're trying to force a useful implementation of C89 errno
 * behavior.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X and Y may be evaluated more than once.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_ADJUST_ERANGE1</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro>						\
	<cpp:value>do {								\
		if (errno == 0) {					\
			if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)	\
				errno = ERANGE;				\
		}							\
		else if (errno == ERANGE &amp;&amp; (X) == 0.0)			\
			errno = 0;					\
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_ADJUST_ERANGE2</name><parameter_list>(<param><type><name>X</name></type></param>, <param><type><name>Y</name></type></param>)</parameter_list></cpp:macro>						\
	<cpp:value>do {								\
		if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL ||	\
		    (Y) == Py_HUGE_VAL || (Y) == -Py_HUGE_VAL) {	\
				if (errno == 0)				\
					errno = ERANGE;			\
		}							\
		else if (errno == ERANGE)				\
			errno = 0;					\
	} while(0)</cpp:value></cpp:define>

<comment type="block">/* Py_DEPRECATED(version)
 * Declare a variable, type, or function deprecated.
 * Usage:
 *    extern int old_var Py_DEPRECATED(2.3);
 *    typedef int T1 Py_DEPRECATED(2.4);
 *    extern int x() Py_DEPRECATED(2.5);
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>__GNUC__</name> &gt;= 4) || \
			  (<name>__GNUC__</name> == 3) &amp;&amp; (<name>__GNUC_MINOR__</name> &gt;= 1))</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_DEPRECATED</name><parameter_list>(<param><type><name>VERSION_UNUSED</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__attribute__((__deprecated__))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_DEPRECATED</name><parameter_list>(<param><type><name>VERSION_UNUSED</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**************************************************************************
Prototypes that are missing from the standard include files on some systems
(and possibly only some versions of such systems.)

Please be conservative with adding new ones, document them and enclose them
in platform-specific #ifdefs.
**************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SOLARIS</name></cpp:ifdef>
<comment type="block">/* Unchecked */</comment>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>gethostname</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__BEOS__</name></cpp:ifdef>
<comment type="block">/* Unchecked */</comment>
<comment type="block">/* It's in the libs, but not the headers... - [cjh] */</comment>
<function_decl><type><name>int</name></type> <name>shutdown</name><parameter_list>( <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param> )</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE__GETPTY</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>		<comment type="block">/* we need to import mode_t */</comment>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type> <name>_getpty</name><parameter_list>(<param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>mode_t</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* On QNX 6, struct termio must be declared by including sys/termio.h
   if TCGETA, TCSETA, TCSETAW, or TCSETAF are used.  sys/termio.h must
   be included before termios.h or it will generate an error. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_TERMIO_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/termio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENPTY</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FORKPTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTY_H</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBUTIL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* BSDI does not supply a prototype for the 'openpty' and 'forkpty'
   functions, even though they are included in libutil. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;termios.h&gt;</cpp:file></cpp:include>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>openpty</name><parameter_list>(<param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type>struct</type> <name>termios</name> *</decl></param>, <param><decl><type>struct</type> <name>winsize</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>pid_t</name></type> <name>forkpty</name><parameter_list>(<param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type>struct</type> <name>termios</name> *</decl></param>, <param><decl><type>struct</type> <name>winsize</name> *</decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(HAVE_PTY_H) &amp;&amp; !defined(HAVE_LIBUTIL_H) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) */</comment>


<comment type="block">/* These are pulled from various places. It isn't obvious on what platforms
   they are necessary, nor what the exact prototype should look like (which
   is likely to vary between platforms!) If you find you need one of these
   declarations, please move them to a platform-specific block and include
   proper prototypes. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>

<comment type="block">/* From Modules/resource.c */</comment>
extern int getrusage();
extern int getpagesize();

<comment type="block">/* From Python/sysmodule.c and Modules/posixmodule.c */</comment>
extern int fclose(FILE *);

<comment type="block">/* From Modules/posixmodule.c */</comment>
extern int fdatasync(int);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* 0 */</comment>


<comment type="block">/* On 4.4BSD-descendants, ctype functions serves the whole range of
 * wchar_t character set rather than single byte code points only.
 * This characteristic can break some operations of string object
 * including str.upper() and str.split() on UTF-8 locales.  This
 * workaround was provided by Tim Robbins of FreeBSD project.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__FreeBSD__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;osreldate.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__FreeBSD_version</name> &gt; 500039</expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wctype.h&gt;</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isalnum</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isalnum</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswalnum(btowc(c))</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isalpha</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isalpha</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswalpha(btowc(c))</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>islower</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>islower</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswlower(btowc(c))</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isspace</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isspace</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswspace(btowc(c))</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isupper</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isupper</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>iswupper(btowc(c))</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>tolower</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tolower</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>towlower(btowc(c))</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>toupper</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>toupper</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>towupper(btowc(c))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Declarations for symbol visibility.

  PyAPI_FUNC(type): Declares a public Python API function and return type
  PyAPI_DATA(type): Declares public Python data and its type
  PyMODINIT_FUNC:   A Python module init function.  If these functions are
                    inside the Python core, they are private to the core.
                    If in an extension module, it may be declared with
                    external linkage depending on the platform.

  As a number of platforms support/require "__declspec(dllimport/dllexport)",
  we support a HAVE_DECLSPEC_DLL macro to save duplication.
*/</comment>

<comment type="block">/*
  All windows ports, except cygwin, are handled in PC/pyconfig.h.

  BeOS and cygwin are the only other autoconf platform requiring special
  linkage handling and both of these use __declspec().
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_DECLSPEC_DLL</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* only get special linkage if built as shared or platform is Cygwin */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_ENABLE_SHARED</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#	<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECLSPEC_DLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifdef>#		<cpp:directive>ifdef</cpp:directive> <name>Py_BUILD_CORE</name></cpp:ifdef>
<cpp:define>#			<cpp:directive>define</cpp:directive> <cpp:macro><name>PyAPI_FUNC</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__declspec(dllexport) RTYPE</cpp:value></cpp:define>
<cpp:define>#			<cpp:directive>define</cpp:directive> <cpp:macro><name>PyAPI_DATA</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>extern __declspec(dllexport) RTYPE</cpp:value></cpp:define>
			<comment type="block">/* module init functions inside the core need no external linkage */</comment>
			<comment type="block">/* except for Cygwin to handle embedding (FIXME: BeOS too?) */</comment>
<cpp:if>#			<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#				<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>__declspec(dllexport) void</cpp:value></cpp:define>
<cpp:else>#			<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* __CYGWIN__ */</comment>
<cpp:define>#				<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>void</cpp:value></cpp:define>
<cpp:endif>#			<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __CYGWIN__ */</comment>
<cpp:else>#		<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* Py_BUILD_CORE */</comment>
			<comment type="block">/* Building an extension module, or an embedded situation */</comment>
			<comment type="block">/* public Python functions and data are imported */</comment>
			<comment type="block">/* Under Cygwin, auto-import functions to prevent compilation */</comment>
			<comment type="block">/* failures similar to http://python.org/doc/FAQ.html#3.24 */</comment>
<cpp:if>#			<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#				<cpp:directive>define</cpp:directive> <cpp:macro><name>PyAPI_FUNC</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__declspec(dllimport) RTYPE</cpp:value></cpp:define>
<cpp:endif>#			<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !__CYGWIN__ */</comment>
<cpp:define>#			<cpp:directive>define</cpp:directive> <cpp:macro><name>PyAPI_DATA</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>extern __declspec(dllimport) RTYPE</cpp:value></cpp:define>
			<comment type="block">/* module init functions outside the core must be exported */</comment>
<cpp:if>#			<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#				<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>extern "C" __declspec(dllexport) void</cpp:value></cpp:define>
<cpp:else>#			<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* __cplusplus */</comment>
<cpp:define>#				<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>__declspec(dllexport) void</cpp:value></cpp:define>
<cpp:endif>#			<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>
<cpp:endif>#		<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_BUILD_CORE */</comment>
<cpp:endif>#	<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_DECLSPEC */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_ENABLE_SHARED */</comment>

<comment type="block">/* If no external linkage macros defined by now, create defaults */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyAPI_FUNC</name></cpp:ifndef>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>PyAPI_FUNC</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>RTYPE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyAPI_DATA</name></cpp:ifndef>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>PyAPI_DATA</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>extern RTYPE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyMODINIT_FUNC</name></cpp:ifndef>
<cpp:if>#	<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#		<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>extern "C" void</cpp:value></cpp:define>
<cpp:else>#	<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* __cplusplus */</comment>
<cpp:define>#		<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>void</cpp:value></cpp:define>
<cpp:endif>#	<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Deprecated DL_IMPORT and DL_EXPORT macros */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_ENABLE_SHARED</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name> <argument_list>(<argument><expr><name>HAVE_DECLSPEC_DLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#	<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_BUILD_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#		<cpp:directive>define</cpp:directive> <cpp:macro><name>DL_IMPORT</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__declspec(dllexport) RTYPE</cpp:value></cpp:define>
<cpp:define>#		<cpp:directive>define</cpp:directive> <cpp:macro><name>DL_EXPORT</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__declspec(dllexport) RTYPE</cpp:value></cpp:define>
<cpp:else>#	<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#		<cpp:directive>define</cpp:directive> <cpp:macro><name>DL_IMPORT</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__declspec(dllimport) RTYPE</cpp:value></cpp:define>
<cpp:define>#		<cpp:directive>define</cpp:directive> <cpp:macro><name>DL_EXPORT</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__declspec(dllexport) RTYPE</cpp:value></cpp:define>
<cpp:endif>#	<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DL_EXPORT</name></cpp:ifndef>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>DL_EXPORT</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>RTYPE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DL_IMPORT</name></cpp:ifndef>
<cpp:define>#	<cpp:directive>define</cpp:directive> <cpp:macro><name>DL_IMPORT</name><parameter_list>(<param><type><name>RTYPE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>RTYPE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* End of deprecated DL_* macros */</comment>

<comment type="block">/* If the fd manipulation macros aren't defined,
   here is a set that should do the job */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if> <comment type="block">/* disabled and probably obsolete */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>	<name>FD_SETSIZE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>FD_SETSIZE</name></cpp:macro>	<cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FD_SET</name></cpp:ifndef>

typedef long fd_mask;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NFDBITS</name></cpp:macro>	<cpp:value>(sizeof(fd_mask) * NBBY)</cpp:value></cpp:define>	<comment type="block">/* bits per mask */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>howmany</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>howmany</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>(((x)+((y)-1))/(y))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* howmany */</comment>

typedef	struct fd_set {
	fd_mask	fds_bits[howmany(FD_SETSIZE, NFDBITS)];
} fd_set;

<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>FD_SET</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((p)-&gt;fds_bits[(n)/NFDBITS] |= (1 &lt;&lt; ((n) % NFDBITS)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>FD_CLR</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((p)-&gt;fds_bits[(n)/NFDBITS] &amp;= ~(1 &lt;&lt; ((n) % NFDBITS)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>FD_ISSET</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>p</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>((p)-&gt;fds_bits[(n)/NFDBITS] &amp; (1 &lt;&lt; ((n) % NFDBITS)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_ZERO</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>memset((char *)(p), '\0', sizeof(*(p)))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FD_SET */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* fd manipulation macros */</comment>


<comment type="block">/* limits.h constants that may be missing */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INT_MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_MAX</name></cpp:macro> <cpp:value>2147483647</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LONG_MAX</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> == 4</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_MAX</name></cpp:macro> <cpp:value>0X7FFFFFFFL</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG</name> == 8</expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_MAX</name></cpp:macro> <cpp:value>0X7FFFFFFFFFFFFFFFL</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "could not set LONG_MAX in pyport.h"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LONG_MIN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_MIN</name></cpp:macro> <cpp:value>(-LONG_MAX-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LONG_BIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_BIT</name></cpp:macro> <cpp:value>(8 * SIZEOF_LONG)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LONG_BIT</name> != 8 * <name>SIZEOF_LONG</name></expr></cpp:if>
<comment type="block">/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
 * 32-bit platforms using gcc.  We try to catch that here at compile-time
 * rather than waiting for integer multiplication to trigger bogus
 * overflows.
 */</comment>
<cpp:error>#<cpp:directive>error</cpp:directive> "LONG_BIT definition appears wrong for platform (bad gcc/glibc config?)."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Hide GCC attributes from compilers that don't support them.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(!<call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> || <name>__GNUC__</name> &lt; 2 || \
     (<name>__GNUC__</name> == 2 &amp;&amp; <name>__GNUC_MINOR__</name> &lt; 7) ) &amp;&amp; \
    !<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_GCC_ATTRIBUTE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_GCC_ATTRIBUTE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__attribute__(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Add PyArg_ParseTuple format where available.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ATTRIBUTE_FORMAT_PARSETUPLE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_FORMAT_PARSETUPLE</name><parameter_list>(<param><type><name>func</name></type></param>,<param><type><name>p1</name></type></param>,<param><type><name>p2</name></type></param>)</parameter_list></cpp:macro> <cpp:value>__attribute__((format(func,p1,p2)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_FORMAT_PARSETUPLE</name><parameter_list>(<param><type><name>func</name></type></param>,<param><type><name>p1</name></type></param>,<param><type><name>p2</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Eliminate end-of-loop code not reached warnings from SunPro C
 * when using do{...}while(0) macros
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_C</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Older Microsoft compilers don't support the C99 long long literal suffixes,
 * so these will be defined in PC/pyconfig.h for those compilers.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_LL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_LL</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x##LL</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_ULL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_ULL</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_LL(x##U)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_PYPORT_H */</comment>
</unit>
