<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/symtable.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_SYMTABLE_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_SYMTABLE_H</name></cpp:macro></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum <name>_block_type</name> <block>{ <decl><name>FunctionBlock</name></decl>, <decl><name>ClassBlock</name></decl>, <decl><name>ModuleBlock</name></decl> }</block></enum></type>
    <name>_Py_block_ty</name>;</typedef>

<struct_decl>struct <name>_symtable_entry</name>;</struct_decl>

<struct>struct <name>symtable</name> <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>st_filename</name></decl>;</decl_stmt> <comment type="block">/* name of file being compiled */</comment>
	<decl_stmt><decl><type>struct <name>_symtable_entry</name> *</type><name>st_cur</name></decl>;</decl_stmt> <comment type="block">/* current symbol table entry */</comment>
	<decl_stmt><decl><type>struct <name>_symtable_entry</name> *</type><name>st_top</name></decl>;</decl_stmt> <comment type="block">/* module entry */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>st_symbols</name></decl>;</decl_stmt>    <comment type="block">/* dictionary of symbol table entries */</comment>
        <decl_stmt><decl><type><name>PyObject</name> *</type><name>st_stack</name></decl>;</decl_stmt>      <comment type="block">/* stack of namespace info */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>st_global</name></decl>;</decl_stmt>     <comment type="block">/* borrowed ref to MODULE in st_symbols */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>st_nblocks</name></decl>;</decl_stmt>          <comment type="block">/* number of blocks */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>st_private</name></decl>;</decl_stmt>        <comment type="block">/* name of current class or NULL */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>st_tmpname</name></decl>;</decl_stmt>          <comment type="block">/* temporary name counter */</comment>
	<decl_stmt><decl><type><name>PyFutureFeatures</name> *</type><name>st_future</name></decl>;</decl_stmt> <comment type="block">/* module's future features */</comment>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>_symtable_entry</name> <block>{
	<decl_stmt><decl><type><name>PyObject_HEAD</name>
	<name>PyObject</name> *</type><name>ste_id</name></decl>;</decl_stmt>        <comment type="block">/* int: key in st_symbols */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ste_symbols</name></decl>;</decl_stmt>   <comment type="block">/* dict: name to flags */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ste_name</name></decl>;</decl_stmt>      <comment type="block">/* string: name of block */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ste_varnames</name></decl>;</decl_stmt>  <comment type="block">/* list of variable names */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ste_children</name></decl>;</decl_stmt>  <comment type="block">/* list of child ids */</comment>
	<decl_stmt><decl><type><name>_Py_block_ty</name></type> <name>ste_type</name></decl>;</decl_stmt>   <comment type="block">/* module, class, or function */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ste_unoptimized</name></decl>;</decl_stmt>     <comment type="block">/* false if namespace is optimized */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ste_nested</name></decl>;</decl_stmt>      <comment type="block">/* true if block is nested */</comment>
	<expr_stmt><expr><name>unsigned</name> <name>ste_free</name> : 1</expr>;</expr_stmt>        <comment type="block">/* true if block has free variables */</comment>
	<expr_stmt><expr><name>unsigned</name> <name>ste_child_free</name> : 1</expr>;</expr_stmt>  <comment type="block">/* true if a child block has free vars,
				         including free refs to globals */</comment>
	<expr_stmt><expr><name>unsigned</name> <name>ste_generator</name> : 1</expr>;</expr_stmt>   <comment type="block">/* true if namespace is a generator */</comment>
	<expr_stmt><expr><name>unsigned</name> <name>ste_varargs</name> : 1</expr>;</expr_stmt>     <comment type="block">/* true if block has varargs */</comment>
	<expr_stmt><expr><name>unsigned</name> <name>ste_varkeywords</name> : 1</expr>;</expr_stmt> <comment type="block">/* true if block has varkeywords */</comment>
	<expr_stmt><expr><name>unsigned</name> <name>ste_returns_value</name> : 1</expr>;</expr_stmt>  <comment type="block">/* true if namespace uses return with
	                                    an argument */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ste_lineno</name></decl>;</decl_stmt>          <comment type="block">/* first line of block */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ste_opt_lineno</name></decl>;</decl_stmt>      <comment type="block">/* lineno of last exec or import * */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ste_tmpname</name></decl>;</decl_stmt>         <comment type="block">/* counter for listcomp temp vars */</comment>
	<decl_stmt><decl><type>struct <name>symtable</name> *</type><name>ste_table</name></decl>;</decl_stmt>
}</block></struct></type> <name>PySTEntryObject</name>;</typedef>

<macro><name>PyAPI_DATA</name><argument_list>(<argument>PyTypeObject</argument>)</argument_list></macro> <expr_stmt><expr><name>PySTEntry_Type</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PySTEntry_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PySTEntry_Type)</cpp:value></cpp:define>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyST_GetScope</name><argument_list>(<argument><expr><name>PySTEntryObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>struct symtable *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySymtable_Build</name><argument_list>(<argument><expr><name>mod_ty</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, 
					      <argument><expr><name>PyFutureFeatures</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PySTEntryObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySymtable_Lookup</name><argument_list>(<argument>struct <expr><name>symtable</name> *</expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PySymtable_Free</name><argument_list>(<argument>struct <expr><name>symtable</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Flags for def-use information */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_GLOBAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>           <comment type="block">/* global stmt */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_LOCAL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>            <comment type="block">/* assignment in code block */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_PARAM</name></cpp:macro> <cpp:value>2&lt;&lt;1</cpp:value></cpp:define>         <comment type="block">/* formal parameter */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE</name></cpp:macro> <cpp:value>2&lt;&lt;2</cpp:value></cpp:define>               <comment type="block">/* name is used */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_STAR</name></cpp:macro> <cpp:value>2&lt;&lt;3</cpp:value></cpp:define>          <comment type="block">/* parameter is star arg */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_DOUBLESTAR</name></cpp:macro> <cpp:value>2&lt;&lt;4</cpp:value></cpp:define>    <comment type="block">/* parameter is star-star arg */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_INTUPLE</name></cpp:macro> <cpp:value>2&lt;&lt;5</cpp:value></cpp:define>       <comment type="block">/* name defined in tuple in parameters */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_FREE</name></cpp:macro> <cpp:value>2&lt;&lt;6</cpp:value></cpp:define>          <comment type="block">/* name used but not defined in nested block */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_FREE_GLOBAL</name></cpp:macro> <cpp:value>2&lt;&lt;7</cpp:value></cpp:define>   <comment type="block">/* free variable is actually implicit global */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_FREE_CLASS</name></cpp:macro> <cpp:value>2&lt;&lt;8</cpp:value></cpp:define>    <comment type="block">/* free variable from class's method */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_IMPORT</name></cpp:macro> <cpp:value>2&lt;&lt;9</cpp:value></cpp:define>        <comment type="block">/* assignment occurred via import */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_BOUND</name></cpp:macro> <cpp:value>(DEF_LOCAL | DEF_PARAM | DEF_IMPORT)</cpp:value></cpp:define>

<comment type="block">/* GLOBAL_EXPLICIT and GLOBAL_IMPLICIT are used internally by the symbol
   table.  GLOBAL is returned from PyST_GetScope() for either of them. 
   It is stored in ste_symbols at bits 12-14.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCOPE_OFF</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCOPE_MASK</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOBAL_EXPLICIT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOBAL_IMPLICIT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CELL</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/* The following three names are used for the ste_unoptimized bit field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_IMPORT_STAR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_EXEC</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_BARE_EXEC</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_TOPLEVEL</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>  <comment type="block">/* top-level names, including eval and exec */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GENERATOR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GENERATOR_EXPRESSION</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_SYMTABLE_H */</comment>
</unit>
