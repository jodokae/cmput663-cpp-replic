<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/objimpl.h"><comment type="block">/* The PyObject_ memory family:  high-level object memory interfaces.
   See pymem.h for the low-level PyMem_ family.
*/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_OBJIMPL_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_OBJIMPL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pymem.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyObject_ memory functions with calls to the platform
   malloc/realloc/ calloc/free, or with calls to PyMem_.
*/</comment>

<comment type="block">/*
Functions and macros for modules that implement new object types.

 - PyObject_New(type, typeobj) allocates memory for a new object of the given
   type, and initializes part of it.  'type' must be the C structure type used
   to represent the object, and 'typeobj' the address of the corresponding
   type object.  Reference count and type pointer are filled in; the rest of
   the bytes of the object are *undefined*!  The resulting expression type is
   'type *'.  The size of the object is determined by the tp_basicsize field
   of the type object.

 - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
   object with room for n items.  In addition to the refcount and type pointer
   fields, this also fills in the ob_size field.

 - PyObject_Del(op) releases the memory allocated for an object.  It does not
   run a destructor -- it only frees the memory.  PyObject_Free is identical.

 - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
   new object (allocated by an arbitrary allocator), and initialize its object
   header fields.

Note that objects created with PyObject_{New, NewVar} are allocated using the
specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
enabled.  In addition, a special debugging allocator is used if PYMALLOC_DEBUG
is also #defined.

In case a specific form of memory management is needed (for example, if you
must use the platform malloc heap(s), or shared memory, or C++ local storage or
operator new), you must first allocate the object with your custom allocator,
then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
specific fields:  reference count, type pointer, possibly others.  You should
be aware that Python no control over these objects because they don't
cooperate with the Python memory manager.  Such objects may not be eligible
for automatic garbage collection and you have to make sure that they are
released accordingly whenever their destructor gets called (cf. the specific
form of memory management you're using).

Unless you have specific memory management requirements, use
PyObject_{New, NewVar, Del}.
*/</comment>

<comment type="block">/*
 * Raw object memory interface
 * ===========================
 */</comment>

<comment type="block">/* Functions to call the same malloc/realloc/free as used by Python's
   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
   the platform malloc/realloc/free.  The Python object allocator is
   designed for fast, cache-conscious allocation of many "small" objects,
   and with low hidden memory overhead.

   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.

   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
   at p.

   Returned pointers must be checked for NULL explicitly; no action is
   performed on failure other than to return NULL (no warning it printed, no
   exception is set, etc).

   For allocating objects, use PyObject_{New, NewVar} instead whenever
   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
   so that you can exploit Python's small-block allocator for non-object
   uses.  If you must use these routines to allocate object memory, make sure
   the object gets initialized via PyObject_{Init, InitVar} after obtaining
   the raw memory.
*/</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Malloc</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Realloc</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* Macros */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WITH_PYMALLOC</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PYMALLOC_DEBUG</name></cpp:ifdef>	<comment type="block">/* WITH_PYMALLOC &amp;&amp; PYMALLOC_DEBUG */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>_PyObject_DebugMalloc</name><argument_list>(<argument>size_t nbytes</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>_PyObject_DebugRealloc</name><argument_list>(<argument>void *p</argument>, <argument>size_t nbytes</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_DebugFree</name><argument_list>(<argument><expr><name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_DebugDumpAddress</name><argument_list>(<argument><expr>const <name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_DebugCheckAddress</name><argument_list>(<argument><expr>const <name>void</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_DebugMallocStats</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_MALLOC</name></cpp:macro>		<cpp:value>_PyObject_DebugMalloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Malloc</name></cpp:macro>		<cpp:value>_PyObject_DebugMalloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_REALLOC</name></cpp:macro>	<cpp:value>_PyObject_DebugRealloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Realloc</name></cpp:macro>	<cpp:value>_PyObject_DebugRealloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_FREE</name></cpp:macro>		<cpp:value>_PyObject_DebugFree</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Free</name></cpp:macro>		<cpp:value>_PyObject_DebugFree</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* WITH_PYMALLOC &amp;&amp; ! PYMALLOC_DEBUG */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_MALLOC</name></cpp:macro>		<cpp:value>PyObject_Malloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_REALLOC</name></cpp:macro>	<cpp:value>PyObject_Realloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_FREE</name></cpp:macro>		<cpp:value>PyObject_Free</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* ! WITH_PYMALLOC */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_MALLOC</name></cpp:macro>		<cpp:value>PyMem_MALLOC</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_REALLOC</name></cpp:macro>	<cpp:value>PyMem_REALLOC</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_FREE</name></cpp:macro>		<cpp:value>PyMem_FREE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* WITH_PYMALLOC */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_Del</name></cpp:macro>		<cpp:value>PyObject_Free</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_DEL</name></cpp:macro>		<cpp:value>PyObject_FREE</cpp:value></cpp:define>

<comment type="block">/* for source compatibility with 2.2 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_Del</name></cpp:macro>		<cpp:value>PyObject_Free</cpp:value></cpp:define>

<comment type="block">/*
 * Generic object allocator interface
 * ==================================
 */</comment>

<comment type="block">/* Functions */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_Init</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyTypeObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyVarObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_InitVar</name><argument_list>(<argument><expr><name>PyVarObject</name> *</expr></argument>,
                                                 <argument><expr><name>PyTypeObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_New</name><argument_list>(<argument><expr><name>PyTypeObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyVarObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_NewVar</name><argument_list>(<argument><expr><name>PyTypeObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_New</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> \
		<cpp:value>( (type *) _PyObject_New(typeobj) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_NewVar</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
		<cpp:value>( (type *) _PyObject_NewVar((typeobj), (n)) )</cpp:value></cpp:define>

<comment type="block">/* Macros trading binary compatibility for speed. See also pymem.h.
   Note that these macros expect non-NULL object pointers.*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_INIT</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_INIT_VAR</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>typeobj</name></type></param>, <param><type><name>size</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>( Py_SIZE(op) = (size), PyObject_INIT((op), (typeobj)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_SIZE</name><parameter_list>(<param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (typeobj)-&gt;tp_basicsize )</cpp:value></cpp:define>

<comment type="block">/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
   value is rounded up to the closest multiple of sizeof(void *), in order to
   ensure that pointer fields at the end of the object are correctly aligned
   for the platform (this is of special importance for subclasses of, e.g.,
   str or long, so that pointers can be stored after the embedded data).

   Note that there's no memory wastage in doing this, as malloc has to
   return (at worst) pointer-aligned memory anyway.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>((<name>SIZEOF_VOID_P</name> - 1) &amp; <name>SIZEOF_VOID_P</name>) != 0</expr></cpp:if>
<cpp:error>#   <cpp:directive>error</cpp:directive> "_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_VAR_SIZE</name><parameter_list>(<param><type><name>typeobj</name></type></param>, <param><type><name>nitems</name></type></param>)</parameter_list></cpp:macro>	\
	<cpp:value>(size_t)				\
	( ( (typeobj)-&gt;tp_basicsize +		\
	    (nitems)*(typeobj)-&gt;tp_itemsize +	\
	    (SIZEOF_VOID_P - 1)			\
	  ) &amp; ~(SIZEOF_VOID_P - 1)		\
	)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_NEW</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>( (type *) PyObject_Init( \
	(PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_NEW_VAR</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>( (type *) PyObject_InitVar( \
      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\
      (typeobj), (n)) )</cpp:value></cpp:define>

<comment type="block">/* This example code implements an object constructor with a custom
   allocator, where PyObject_New is inlined, and shows the important
   distinction between two steps (at least):
       1) the actual allocation of the object storage;
       2) the initialization of the Python specific fields
          in this storage with PyObject_{Init, InitVar}.

   PyObject *
   YourObject_New(...)
   {
       PyObject *op;

       op = (PyObject *) Your_Allocator(_PyObject_SIZE(YourTypeStruct));
       if (op == NULL)
           return PyErr_NoMemory();

       PyObject_Init(op, &amp;YourTypeStruct);

       op-&gt;ob_field = value;
       ...
       return op;
   }

   Note that in C++, the use of the new operator usually implies that
   the 1st step is performed automatically for you, so in a C++ class
   constructor you would start directly with PyObject_Init/InitVar
*/</comment>

<comment type="block">/*
 * Garbage Collection Support
 * ==========================
 */</comment>

<comment type="block">/* C equivalent of gc.collect(). */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>Py_ssize_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyGC_Collect</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Test if a type has a GC head */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyType_IS_GC</name><parameter_list>(<param><type><name>t</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)</cpp:value></cpp:define>

<comment type="block">/* Test if an object has a GC head */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_IS_GC</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyType_IS_GC(Py_TYPE(o)) &amp;&amp; \
	(Py_TYPE(o)-&gt;tp_is_gc == NULL || Py_TYPE(o)-&gt;tp_is_gc(o)))</cpp:value></cpp:define>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyVarObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_GC_Resize</name><argument_list>(<argument><expr><name>PyVarObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_Resize</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>op</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
		<cpp:value>( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )</cpp:value></cpp:define>

<comment type="block">/* for source compatibility with 2.2 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_GC_Del</name></cpp:macro> <cpp:value>PyObject_GC_Del</cpp:value></cpp:define>

<comment type="block">/* GC information is stored BEFORE the object structure. */</comment>
<typedef>typedef <type><union>union <name>_gc_head</name> <block>{
	<struct>struct <block>{
		<decl_stmt><decl><type>union <name>_gc_head</name> *</type><name>gc_next</name></decl>;</decl_stmt>
		<decl_stmt><decl><type>union <name>_gc_head</name> *</type><name>gc_prev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>gc_refs</name></decl>;</decl_stmt>
	}</block> <decl><name>gc</name></decl>;</struct>
	<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>dummy</name></decl>;</decl_stmt>  <comment type="block">/* force worst-case alignment */</comment>
}</block></union></type> <name>PyGC_Head</name>;</typedef>

<decl_stmt><decl><type><specifier>extern</specifier> <name>PyGC_Head</name> *</type><name>_PyGC_generation0</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_Py_AS_GC</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((PyGC_Head *)(o)-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyGC_REFS_UNTRACKED</name></cpp:macro>			<cpp:value>(-2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyGC_REFS_REACHABLE</name></cpp:macro>			<cpp:value>(-3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyGC_REFS_TENTATIVELY_UNREACHABLE</name></cpp:macro>	<cpp:value>(-4)</cpp:value></cpp:define>

<comment type="block">/* Tell the GC to track this object.  NB: While the object is tracked the
 * collector it must be safe to call the ob_traverse method. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_GC_TRACK</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { \
	PyGC_Head *g = _Py_AS_GC(o); \
	if (g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED) \
		Py_FatalError("GC object already tracked"); \
	g-&gt;gc.gc_refs = _PyGC_REFS_REACHABLE; \
	g-&gt;gc.gc_next = _PyGC_generation0; \
	g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; \
	g-&gt;gc.gc_prev-&gt;gc.gc_next = g; \
	_PyGC_generation0-&gt;gc.gc_prev = g; \
    } while (0);</cpp:value></cpp:define>

<comment type="block">/* Tell the GC to stop tracking this object.
 * gc_next doesn't need to be set to NULL, but doing so is a good
 * way to provoke memory errors if calling code is confused.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyObject_GC_UNTRACK</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { \
	PyGC_Head *g = _Py_AS_GC(o); \
	assert(g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED); \
	g-&gt;gc.gc_refs = _PyGC_REFS_UNTRACKED; \
	g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; \
	g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; \
	g-&gt;gc.gc_next = NULL; \
    } while (0);</cpp:value></cpp:define>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_GC_Malloc</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_GC_New</name><argument_list>(<argument><expr><name>PyTypeObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyVarObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyObject_GC_NewVar</name><argument_list>(<argument><expr><name>PyTypeObject</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_New</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>)</parameter_list></cpp:macro> \
		<cpp:value>( (type *) _PyObject_GC_New(typeobj) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_NewVar</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>typeobj</name></type></param>, <param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
		<cpp:value>( (type *) _PyObject_GC_NewVar((typeobj), (n)) )</cpp:value></cpp:define>


<comment type="block">/* Utility macro to help write tp_traverse functions.
 * To use this macro, the tp_traverse function must name its arguments
 * "visit" and "arg".  This is intended to keep tp_traverse functions
 * looking as much alike as possible.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_VISIT</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>							\
        <cpp:value>do { 								\
                if (op) {						\
                        int vret = visit((PyObject *)(op), arg);	\
                        if (vret)					\
                                return vret;				\
                }							\
        } while (0)</cpp:value></cpp:define>

<comment type="block">/* This is here for the sake of backwards compatibility.  Extensions that
 * use the old GC API will still compile but the objects will not be
 * tracked by the GC. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyGC_HEAD_SIZE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_Init</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GC_Fini</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_AS_GC</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(op)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_FROM_GC</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(op)</cpp:value></cpp:define>


<comment type="block">/* Test if a type supports weak references */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyType_SUPPORTS_WEAKREFS</name><parameter_list>(<param><type><name>t</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>(PyType_HasFeature((t), Py_TPFLAGS_HAVE_WEAKREFS) \
         &amp;&amp; ((t)-&gt;tp_weaklistoffset &gt; 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyObject_GET_WEAKREFS_LISTPTR</name><parameter_list>(<param><type><name>o</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>((PyObject **) (((char *) (o)) + Py_TYPE(o)-&gt;tp_weaklistoffset))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_OBJIMPL_H */</comment>
</unit>
