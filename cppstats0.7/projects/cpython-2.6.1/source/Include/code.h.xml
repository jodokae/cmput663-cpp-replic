<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/code.h"><comment type="block">/* Definitions for bytecode */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_CODE_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_CODE_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Bytecode object */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>PyObject_HEAD</name>
    <name>int</name></type> <name>co_argcount</name></decl>;</decl_stmt>		<comment type="block">/* #arguments, except *args */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>co_nlocals</name></decl>;</decl_stmt>		<comment type="block">/* #local variables */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>co_stacksize</name></decl>;</decl_stmt>		<comment type="block">/* #entries needed for evaluation stack */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>co_flags</name></decl>;</decl_stmt>		<comment type="block">/* CO_..., see below */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_code</name></decl>;</decl_stmt>		<comment type="block">/* instruction opcodes */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_consts</name></decl>;</decl_stmt>	<comment type="block">/* list (constants used) */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_names</name></decl>;</decl_stmt>		<comment type="block">/* list of strings (names used) */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_varnames</name></decl>;</decl_stmt>	<comment type="block">/* tuple of strings (local variable names) */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_freevars</name></decl>;</decl_stmt>	<comment type="block">/* tuple of strings (free variable names) */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_cellvars</name></decl>;</decl_stmt>      <comment type="block">/* tuple of strings (cell variable names) */</comment>
    <comment type="block">/* The rest doesn't count for hash/cmp */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_filename</name></decl>;</decl_stmt>	<comment type="block">/* string (where it was loaded from) */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_name</name></decl>;</decl_stmt>		<comment type="block">/* string (name, for reference) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>co_firstlineno</name></decl>;</decl_stmt>		<comment type="block">/* first source line number */</comment>
    <decl_stmt><decl><type><name>PyObject</name> *</type><name>co_lnotab</name></decl>;</decl_stmt>	<comment type="block">/* string (encoding addr&lt;-&gt;lineno mapping) */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>co_zombieframe</name></decl>;</decl_stmt>     <comment type="block">/* for optimization only (see frameobject.c) */</comment>
}</block></struct></type> <name>PyCodeObject</name>;</typedef>

<comment type="block">/* Masks for co_flags above */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_OPTIMIZED</name></cpp:macro>	<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_NEWLOCALS</name></cpp:macro>	<cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_VARARGS</name></cpp:macro>	<cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_VARKEYWORDS</name></cpp:macro>	<cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_NESTED</name></cpp:macro>       <cpp:value>0x0010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_GENERATOR</name></cpp:macro>    <cpp:value>0x0020</cpp:value></cpp:define>
<comment type="block">/* The CO_NOFREE flag is set if there are no free or cell variables.
   This information is redundant, but it allows a single flag test
   to determine whether there is any extra work to be done when the
   call frame it setup.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_NOFREE</name></cpp:macro>       <cpp:value>0x0040</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/* This is no longer used.  Stopped defining in 2.5, do not re-use. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_GENERATOR_ALLOWED</name></cpp:macro>    <cpp:value>0x1000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_FUTURE_DIVISION</name></cpp:macro>    	<cpp:value>0x2000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_FUTURE_ABSOLUTE_IMPORT</name></cpp:macro> <cpp:value>0x4000</cpp:value></cpp:define> <comment type="block">/* do absolute imports by default */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_FUTURE_WITH_STATEMENT</name></cpp:macro>  <cpp:value>0x8000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_FUTURE_PRINT_FUNCTION</name></cpp:macro>  <cpp:value>0x10000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_FUTURE_UNICODE_LITERALS</name></cpp:macro> <cpp:value>0x20000</cpp:value></cpp:define>

<comment type="block">/* This should be defined if a future statement modifies the syntax.
   For example, when a keyword is added.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>1</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_PARSER_REQUIRES_FUTURE_KEYWORD</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO_MAXBLOCKS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define> <comment type="block">/* Max static block nesting within a function */</comment>

<macro><name>PyAPI_DATA</name><argument_list>(<argument>PyTypeObject</argument>)</argument_list></macro> <expr_stmt><expr><name>PyCode_Type</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyCode_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PyCode_Type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyCode_GetNumFree</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyTuple_GET_SIZE((op)-&gt;co_freevars))</cpp:value></cpp:define>

<comment type="block">/* Public interface */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyCodeObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCode_New</name><argument_list>(
	<argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>,
	<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <comment type="block">/* same as struct above */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCode_Addr2Line</name><argument_list>(<argument><expr><name>PyCodeObject</name> *</expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* for internal use only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyCode_GETCODEPTR</name><parameter_list>(<param><type><name>co</name></type></param>, <param><type><name>pp</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>((*Py_TYPE((co)-&gt;co_code)-&gt;tp_as_buffer-&gt;bf_getreadbuffer) \
	 ((co)-&gt;co_code, 0, (void **)(pp)))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>_addr_pair</name> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>ap_lower</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ap_upper</name></decl>;</decl_stmt>
}</block></struct></type> <name>PyAddrPair</name>;</typedef>

<comment type="block">/* Check whether lasti (an instruction offset) falls outside bounds
   and whether it is a line number that should be traced.  Returns
   a line number if it should be traced or -1 if the line should not.

   If lasti is not within bounds, updates bounds.
*/</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyCode_CheckLineNumber</name><argument_list>(<argument>PyCodeObject* co</argument>,
                                       <argument>int lasti</argument>, <argument>PyAddrPair *bounds</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCode_Optimize</name><argument_list>(<argument><expr><name>PyObject</name> *<name>code</name></expr></argument>, <argument><expr><name>PyObject</name>* <name>consts</name></expr></argument>,
                                      <argument><expr><name>PyObject</name> *<name>names</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>lineno_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_CODE_H */</comment>
</unit>
