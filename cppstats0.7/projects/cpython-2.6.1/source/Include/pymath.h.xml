<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/pymath.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_PYMATH_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_PYMATH_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyconfig.h"</cpp:file></cpp:include> <comment type="block">/* include for defines */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STDINT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/**************************************************************************
Symbols and macros to supply platform-independent interfaces to mathematical
functions and constants
**************************************************************************/</comment>

<comment type="block">/* Python provides implementations for copysign, acosh, asinh, atanh, 
 * log1p and hypot in Python/pymath.c just in case your math library doesn't
 * provide the functions.
 *
 *Note: PC/pyconfig.h defines copysign as _copysign
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_COPYSIGN</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>copysign</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_ACOSH</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>acosh</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_ASINH</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>asinh</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_ATANH</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>atanh</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LOG1P</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>log1p</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_HYPOT</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>hypot</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* extra declarations */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_MSC_VER</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__STDC__</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>fmod</name> <parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>frexp</name> <parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>ldexp</name> <parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>modf</name> <parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>double</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>pow</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __STDC__ */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _MSC_VER */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSF_SOURCE</name></cpp:ifdef>
<comment type="block">/* OSF1 5.1 doesn't make these available with XOPEN_SOURCE_EXTENDED defined */</comment>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>finite</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>copysign</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* High precision defintion of pi and e (Euler)
 * The values are taken from libc6's math.h.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_MATH_PIl</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_MATH_PIl</name></cpp:macro> <cpp:value>3.1415926535897932384626433832795029L</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_MATH_PI</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_MATH_PI</name></cpp:macro> <cpp:value>3.14159265358979323846</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_MATH_El</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_MATH_El</name></cpp:macro> <cpp:value>2.7182818284590452353602874713526625L</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_MATH_E</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_MATH_E</name></cpp:macro> <cpp:value>2.7182818284590452354</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_IS_NAN(X)
 * Return 1 if float or double arg is a NaN, else 0.
 * Caution:
 *     X is evaluated more than once.
 *     This may not work on all platforms.  Each platform has *some*
 *     way to spell this, though -- override in pyconfig.h if you have
 *     a platform where it doesn't work.
 * Note: PC/pyconfig.h defines Py_IS_NAN as _isnan
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_IS_NAN</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ISNAN</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_IS_NAN</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>isnan(X)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_IS_NAN</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((X) != (X))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_IS_INFINITY(X)
 * Return 1 if float or double arg is an infinity, else 0.
 * Caution:
 *    X is evaluated more than once.
 *    This implementation may set the underflow flag if |X| is very small;
 *    it really can't be implemented correctly (&amp; easily) before C99.
 *    Override in pyconfig.h if you have a better spelling on your platform.
 * Note: PC/pyconfig.h defines Py_IS_INFINITY as _isinf
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_IS_INFINITY</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ISINF</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_IS_INFINITY</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>isinf(X)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_IS_INFINITY</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((X) &amp;&amp; (X)*0.5 == (X))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_IS_FINITE(X)
 * Return 1 if float or double arg is neither infinite nor NAN, else 0.
 * Some compilers (e.g. VisualStudio) have intrisics for this, so a special
 * macro for this particular test is useful
 * Note: PC/pyconfig.h defines Py_IS_FINITE as _finite
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_IS_FINITE</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_FINITE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_IS_FINITE</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>finite(X)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_IS_FINITE</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(!Py_IS_INFINITY(X) &amp;&amp; !Py_IS_NAN(X))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* HUGE_VAL is supposed to expand to a positive double infinity.  Python
 * uses Py_HUGE_VAL instead because some platforms are broken in this
 * respect.  We used to embed code in pyport.h to try to worm around that,
 * but different platforms are broken in conflicting ways.  If you're on
 * a platform where HUGE_VAL is defined incorrectly, fiddle your Python
 * config to #define Py_HUGE_VAL to something that works on your platform.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_HUGE_VAL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_HUGE_VAL</name></cpp:macro> <cpp:value>HUGE_VAL</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_NAN
 * A value that evaluates to a NaN. On IEEE 754 platforms INF*0 or
 * INF/INF works. Define Py_NO_NAN in pyconfig.h if your platform
 * doesn't support NaNs.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_NAN</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>Py_NO_NAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_NAN</name></cpp:macro> <cpp:value>(Py_HUGE_VAL * 0.)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Py_OVERFLOWED(X)
 * Return 1 iff a libm function overflowed.  Set errno to 0 before calling
 * a libm function, and invoke this macro after, passing the function
 * result.
 * Caution:
 *    This isn't reliable.  C99 no longer requires libm to set errno under
 *	  any exceptional condition, but does require +- HUGE_VAL return
 *	  values on overflow.  A 754 box *probably* maps HUGE_VAL to a
 *	  double infinity, and we're cool if that's so, unless the input
 *	  was an infinity and an infinity is the expected result.  A C89
 *	  system sets errno to ERANGE, so we check for that too.  We're
 *	  out of luck if a C99 754 box doesn't map HUGE_VAL to +Inf, or
 *	  if the returned result is a NaN, or if a C89 box returns HUGE_VAL
 *	  in non-overflow cases.
 *    X is evaluated more than once.
 * Some platforms have better way to spell this, so expect some #ifdef'ery.
 *
 * OpenBSD uses 'isinf()' because a compiler bug on that platform causes
 * the longer macro version to be mis-compiled. This isn't optimal, and
 * should be removed once a newer compiler is available on that platform.
 * The system that had the failure was running OpenBSD 3.2 on Intel, with
 * gcc 2.95.3.
 *
 * According to Tim's checkin, the FreeBSD systems use isinf() to work
 * around a FPE bug on that platform.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_OVERFLOWED</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>isinf(X)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_OVERFLOWED</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((X) != 0.0 &amp;&amp; (errno == ERANGE ||    \
					 (X) == Py_HUGE_VAL || \
					 (X) == -Py_HUGE_VAL))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* Py_PYMATH_H */</comment>
</unit>
