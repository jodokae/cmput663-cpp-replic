<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/modsupport.h">
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_MODSUPPORT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_MODSUPPORT_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Module support interface */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<comment type="block">/* If PY_SSIZE_T_CLEAN is defined, each functions treats #-specifier
   to mean Py_ssize_t */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PY_SSIZE_T_CLEAN</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyArg_Parse</name></cpp:macro>			<cpp:value>_PyArg_Parse_SizeT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyArg_ParseTuple</name></cpp:macro>		<cpp:value>_PyArg_ParseTuple_SizeT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyArg_ParseTupleAndKeywords</name></cpp:macro>	<cpp:value>_PyArg_ParseTupleAndKeywords_SizeT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyArg_VaParse</name></cpp:macro>			<cpp:value>_PyArg_VaParse_SizeT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyArg_VaParseTupleAndKeywords</name></cpp:macro>	<cpp:value>_PyArg_VaParseTupleAndKeywords_SizeT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_BuildValue</name></cpp:macro>			<cpp:value>_Py_BuildValue_SizeT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_VaBuildValue</name></cpp:macro>			<cpp:value>_Py_VaBuildValue_SizeT</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_Py_VaBuildValue_SizeT</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>va_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyArg_Parse</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>PyArg_ParseTuple</name><argument_list>(<argument>PyObject *</argument>, <argument>const char *</argument>, <argument>...</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Py_FORMAT_PARSETUPLE</name><argument_list>(<argument><expr><name>PyArg_ParseTuple</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>,
                                                  <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>char</name> **</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_Py_BuildValue_SizeT</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument>...<expr/></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>const <name>char</name> *<name>funcname</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyArg_VaParse</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>va_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyArg_VaParseTupleAndKeywords</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>,
                                                  <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>char</name> **</expr></argument>, <argument><expr><name>va_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Py_VaBuildValue</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>va_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyModule_AddStringConstant</name><argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyModule_AddIntMacro</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyModule_AddIntConstant(m, #c, c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyModule_AddStringMacro</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyModule_AddStringConstant(m, #c, c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYTHON_API_VERSION</name></cpp:macro> <cpp:value>1013</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYTHON_API_STRING</name></cpp:macro> <cpp:value>"1013"</cpp:value></cpp:define>
<comment type="block">/* The API version is maintained (independently from the Python version)
   so we can detect mismatches between the interpreter and dynamically
   loaded modules.  These are diagnosed by an error message but
   the module is still loaded (because the mismatch can only be tested
   after loading the module).  The error message is intended to
   explain the core dump a few seconds later.

   The symbol PYTHON_API_STRING defines the same value as a string
   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***

   Please add a line or two to the top of this log for each API
   version change:

   22-Feb-2006  MvL	1013	PEP 353 - long indices for sequence lengths

   19-Aug-2002  GvR	1012	Changes to string object struct for
   				interning changes, saving 3 bytes.

   17-Jul-2001	GvR	1011	Descr-branch, just to be on the safe side

   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and
                                PyFrame_New(); Python 2.1a2

   14-Mar-2000  GvR     1009    Unicode API added

   3-Jan-1999	GvR	1007	Decided to change back!  (Don't reuse 1008!)

   3-Dec-1998	GvR	1008	Python 1.5.2b1

   18-Jan-1997	GvR	1007	string interning and other speedups

   11-Oct-1996	GvR	renamed Py_Ellipses to Py_Ellipsis :-(

   30-Jul-1996	GvR	Slice and ellipses syntax added

   23-Jul-1996	GvR	For 1.4 -- better safe than sorry this time :-)

   7-Nov-1995	GvR	Keyword arguments (should've been done at 1.3 :-( )

   10-Jan-1995	GvR	Renamed globals to new naming scheme

   9-Jan-1995	GvR	Initial version (incompatible with older API)
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MS_WINDOWS</name></cpp:ifdef>
<comment type="block">/* Special defines for Windows versions used to live here.  Things
   have changed, and the "Version" is now in a global string variable.
   Reason for this is that this for easier branding of a "custom DLL"
   without actually needing a recompile.  */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MS_WINDOWS */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> != <name>SIZEOF_INT</name></expr></cpp:if>
<comment type="block">/* On a 64-bit system, rename the Py_InitModule4 so that 2.4
   modules cannot get loaded into a 2.5 interpreter */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_InitModule4</name></cpp:macro> <cpp:value>Py_InitModule4_64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_TRACE_REFS</name></cpp:ifdef>
 <comment type="block">/* When we are tracing reference counts, rename Py_InitModule4 so
    modules compiled with incompatible settings will generate a
    link-time error. */</comment>
 <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> != <name>SIZEOF_INT</name></expr></cpp:if>
 <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Py_InitModule4</name></cpp:undef>
 <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_InitModule4</name></cpp:macro> <cpp:value>Py_InitModule4TraceRefs_64</cpp:value></cpp:define>
 <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
 <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_InitModule4</name></cpp:macro> <cpp:value>Py_InitModule4TraceRefs</cpp:value></cpp:define>
 <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <macro><name>Py_InitModule4</name><argument_list>(<argument>const char *name</argument>, <argument>PyMethodDef *methods</argument>,
                                      <argument>const char *doc</argument>, <argument>PyObject *self</argument>,
                                      <argument>int apiver</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_InitModule</name><parameter_list>(<param><type><name>name</name></type></param>, <param><type><name>methods</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>Py_InitModule4(name, methods, (char *)NULL, (PyObject *)NULL, \
		       PYTHON_API_VERSION)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_InitModule3</name><parameter_list>(<param><type><name>name</name></type></param>, <param><type><name>methods</name></type></param>, <param><type><name>doc</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>Py_InitModule4(name, methods, doc, (PyObject *)NULL, \
		       PYTHON_API_VERSION)</cpp:value></cpp:define>

<macro><name>PyAPI_DATA</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><name>_Py_PackageContext</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_MODSUPPORT_H */</comment>
</unit>
