<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/structmember.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_STRUCTMEMBER_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_STRUCTMEMBER_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Interface to map C struct members to Python object attributes */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include> <comment type="block">/* For offsetof */</comment>

<comment type="block">/* The offsetof() macro calculates the offset of a structure member
   in its structure.  Unfortunately this cannot be written down
   portably, hence it is provided by a Standard C header file.
   For pre-Standard C compilers, here is a version that usually works
   (but watch out!): */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>offsetof</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>offsetof</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>member</name></type></param>)</parameter_list></cpp:macro> <cpp:value>( (int) &amp; ((type*)0) -&gt; member )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* An array of memberlist structures defines the name, type and offset
   of selected members of a C structure.  These can be read by
   PyMember_Get() and set by PyMember_Set() (except if their READONLY flag
   is set).  The array must be terminated with an entry whose name
   pointer is NULL. */</comment>

<struct>struct <name>memberlist</name> <block>{
	<comment type="block">/* Obsolete version, for binary backwards compatibility */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>PyMemberDef</name> <block>{
	<comment type="block">/* Current version, use this */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>doc</name></decl>;</decl_stmt>
}</block></struct></type> <name>PyMemberDef</name>;</typedef>

<comment type="block">/* Types */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_SHORT</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_INT</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_LONG</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_FLOAT</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_DOUBLE</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_STRING</name></cpp:macro>	<cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_OBJECT</name></cpp:macro>	<cpp:value>6</cpp:value></cpp:define>
<comment type="block">/* XXX the ordering here is weird for binary compatibility */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_CHAR</name></cpp:macro>		<cpp:value>7</cpp:value></cpp:define>	<comment type="block">/* 1-character string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_BYTE</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* 8-bit signed int */</comment>
<comment type="block">/* unsigned variants: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_UBYTE</name></cpp:macro>		<cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_USHORT</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_UINT</name></cpp:macro>		<cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_ULONG</name></cpp:macro>		<cpp:value>12</cpp:value></cpp:define>

<comment type="block">/* Added by Jack: strings contained in the structure */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_STRING_INPLACE</name></cpp:macro>	<cpp:value>13</cpp:value></cpp:define>

<comment type="block">/* Added by Lillo: bools contained in the structure (assumed char) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_BOOL</name></cpp:macro>		<cpp:value>14</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_OBJECT_EX</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>	<comment type="block">/* Like T_OBJECT, but raises AttributeError
				   when the value is NULL, instead of
				   converting to None. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_LONG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_LONGLONG</name></cpp:macro>      <cpp:value>17</cpp:value></cpp:define>  
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_ULONGLONG</name></cpp:macro>      <cpp:value>18</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LONG_LONG */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_PYSSIZET</name></cpp:macro>       <cpp:value>19</cpp:value></cpp:define> <comment type="block">/* Py_ssize_t */</comment>


<comment type="block">/* Flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READONLY</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RO</name></cpp:macro>		<cpp:value>READONLY</cpp:value></cpp:define>		<comment type="block">/* Shorthand */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_RESTRICTED</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_WRITE_RESTRICTED</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTRICTED</name></cpp:macro>	<cpp:value>(READ_RESTRICTED | PY_WRITE_RESTRICTED)</cpp:value></cpp:define>


<comment type="block">/* Obsolete API, for binary backwards compatibility */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMember_Get</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument>struct <expr><name>memberlist</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMember_Set</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument>struct <expr><name>memberlist</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Current API, use this */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMember_GetOne</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument>struct <expr><name>PyMemberDef</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyMember_SetOne</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>, <argument>struct <expr><name>PyMemberDef</name> *</expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_STRUCTMEMBER_H */</comment>
</unit>
