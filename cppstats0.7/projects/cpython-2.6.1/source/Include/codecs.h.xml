<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Include/codecs.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_CODECREGISTRY_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_CODECREGISTRY_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ------------------------------------------------------------------------

   Python Codec Registry and support functions


Written by Marc-Andre Lemburg (mal@lemburg.com).

Copyright (c) Corporation for National Research Initiatives.

   ------------------------------------------------------------------------ */</comment>

<comment type="block">/* Register a new codec search function.

   As side effect, this tries to load the encodings package, if not
   yet done, to make sure that it is always first in the list of
   search functions.

   The search_function's refcount is incremented by this function. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_Register</name><argument_list>(
       <argument><expr><name>PyObject</name> *<name>search_function</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Codec register lookup API.

   Looks up the given encoding and returns a CodecInfo object with
   function attributes which implement the different aspects of
   processing the encoding.

   The encoding string is looked up converted to all lower-case
   characters. This makes encodings looked up through this mechanism
   effectively case-insensitive.

   If no codec is found, a KeyError is set and NULL returned.

   As side effect, this tries to load the encodings package, if not
   yet done. This is part of the lazy load strategy for the encodings
   package.

 */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>_PyCodec_Lookup</name><argument_list>(
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Generic codec based encoding API.

   object is passed through the encoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.
   
   Raises a LookupError in case no encoder can be found.

 */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_Encode</name><argument_list>(
       <argument><expr><name>PyObject</name> *<name>object</name></expr></argument>,
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>,
       <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Generic codec based decoding API.

   object is passed through the decoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.
   
   Raises a LookupError in case no encoder can be found.

 */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_Decode</name><argument_list>(
       <argument><expr><name>PyObject</name> *<name>object</name></expr></argument>,
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>,
       <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* --- Codec Lookup APIs -------------------------------------------------- 

   All APIs return a codec object with incremented refcount and are
   based on _PyCodec_Lookup().  The same comments w/r to the encoding
   name also apply to these APIs.

*/</comment>

<comment type="block">/* Get an encoder function for the given encoding. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_Encoder</name><argument_list>(
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Get a decoder function for the given encoding. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_Decoder</name><argument_list>(
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Get a IncrementalEncoder object for the given encoding. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_IncrementalEncoder</name><argument_list>(
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>,
       <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Get a IncrementalDecoder object function for the given encoding. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_IncrementalDecoder</name><argument_list>(
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>,
       <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Get a StreamReader factory function for the given encoding. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_StreamReader</name><argument_list>(
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>,
       <argument><expr><name>PyObject</name> *<name>stream</name></expr></argument>,
       <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Get a StreamWriter factory function for the given encoding. */</comment>

<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_StreamWriter</name><argument_list>(
       <argument><expr>const <name>char</name> *<name>encoding</name></expr></argument>,
       <argument><expr><name>PyObject</name> *<name>stream</name></expr></argument>,
       <argument><expr>const <name>char</name> *<name>errors</name></expr></argument>
       )</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Unicode encoding error handling callback registry API */</comment>

<comment type="block">/* Register the error handling callback function error under the name
   name. This function will be called by the codec when it encounters
   unencodable characters/undecodable bytes and doesn't know the
   callback name, when name is specified as the error parameter
   in the call to the encode/decode function.
   Return 0 on success, -1 on error */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_RegisterError</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>, <argument><expr><name>PyObject</name> *<name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Lookup the error handling callback function registered under the
   name error. As a special case NULL can be passed, in which case
   the error handling callback for "strict" will be returned. */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_LookupError</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* raise exc as an exception */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_StrictErrors</name><argument_list>(<argument><expr><name>PyObject</name> *<name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ignore the unicode error, skipping the faulty input */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_IgnoreErrors</name><argument_list>(<argument><expr><name>PyObject</name> *<name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* replace the unicode error with ? or U+FFFD */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_ReplaceErrors</name><argument_list>(<argument><expr><name>PyObject</name> *<name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* replace the unicode encode error with XML character references */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_XMLCharRefReplaceErrors</name><argument_list>(<argument><expr><name>PyObject</name> *<name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* replace the unicode encode error with backslash escapes (\x, \u and \U) */</comment>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>PyCodec_BackslashReplaceErrors</name><argument_list>(<argument><expr><name>PyObject</name> *<name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_CODECREGISTRY_H */</comment>
</unit>
