<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Parser/printgrammar.c">
<comment type="block">/* Print a bunch of C initializers that represent a grammar */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgenheaders.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>

<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printarcs</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>dfa</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printstates</name><parameter_list>(<param><decl><type><name>grammar</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printdfas</name><parameter_list>(<param><decl><type><name>grammar</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printlabels</name><parameter_list>(<param><decl><type><name>grammar</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>printgrammar</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"/* Generated by Parser/pgen */\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"#include \"pgenheaders.h\"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"#include \"grammar.h\"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printdfas</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printlabels</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"grammar _PyParser_Grammar = {\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t%d,\n"</expr></argument>, <argument><expr><name><name>g</name>-&gt;<name>g_ndfas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\tdfas,\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t{%d, labels},\n"</expr></argument>, <argument><expr><name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_nlabels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t%d\n"</expr></argument>, <argument><expr><name><name>g</name>-&gt;<name>g_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"};\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>printnonterminals</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>dfa</name> *</type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"/* Generated by Parser/pgen */\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>d</name> = <name><name>g</name>-&gt;<name>g_dfa</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name><name>g</name>-&gt;<name>g_ndfas</name></name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>d</name>++</expr></incr>)
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"#define %s %d\n"</expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>d_name</name></name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>d_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printarcs</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>dfa</name> *</type><name>d</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>arc</name> *</type><name>a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>state</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>s</name> = <name><name>d</name>-&gt;<name>d_state</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>d</name>-&gt;<name>d_nstates</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>s</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"static arc arcs_%d_%d[%d] = {\n"</expr></argument>,
			<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>s_narcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>a</name> = <name><name>s</name>-&gt;<name>s_arc</name></name></expr>;</expr_stmt>
		<for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <name><name>s</name>-&gt;<name>s_narcs</name></name></expr>;</condition> <incr><expr><name>k</name>++</expr>, <expr><name>a</name>++</expr></incr>)
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t{%d, %d},\n"</expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>a_lbl</name></name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>a_arrow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"};\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printstates</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>state</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dfa</name> *</type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>d</name> = <name><name>g</name>-&gt;<name>g_dfa</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>g</name>-&gt;<name>g_ndfas</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>d</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>printarcs</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"static state states_%d[%d] = {\n"</expr></argument>,
			<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>d_nstates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> = <name><name>d</name>-&gt;<name>d_state</name></name></expr>;</expr_stmt>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>d</name>-&gt;<name>d_nstates</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>s</name>++</expr></incr>)
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t{%d, arcs_%d_%d},\n"</expr></argument>,
				<argument><expr><name><name>s</name>-&gt;<name>s_narcs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"};\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printdfas</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>dfa</name> *</type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>printstates</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"static dfa dfas[%d] = {\n"</expr></argument>, <argument><expr><name><name>g</name>-&gt;<name>g_ndfas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> = <name><name>g</name>-&gt;<name>g_dfa</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>g</name>-&gt;<name>g_ndfas</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>d</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t{%d, \"%s\", %d, %d, states_%d,\n"</expr></argument>,
			<argument><expr><name><name>d</name>-&gt;<name>d_type</name></name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>d_name</name></name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>d_initial</name></name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>d_nstates</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t \""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>NBYTES</name><argument_list>(<argument><expr><name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_nlabels</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\\%03o"</expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>d_first</name><index>[<expr><name>j</name></expr>]</index></name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\"},\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"};\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printlabels</name><parameter_list>(<param><decl><type><name>grammar</name> *</type><name>g</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>label</name> *</type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"static label labels[%d] = {\n"</expr></argument>, <argument><expr><name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_nlabels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>l</name> = <name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_label</name></name></expr>;</expr_stmt>
	<for>for (<init><expr><name>i</name> = <name><name>g</name>-&gt;<name>g_ll</name>.<name>ll_nlabels</name></name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>l</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>l</name>-&gt;<name>lb_str</name></name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t{%d, 0},\n"</expr></argument>, <argument><expr><name><name>l</name>-&gt;<name>lb_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\t{%d, \"%s\"},\n"</expr></argument>,
				<argument><expr><name><name>l</name>-&gt;<name>lb_type</name></name></expr></argument>, <argument><expr><name><name>l</name>-&gt;<name>lb_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></for>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"};\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
