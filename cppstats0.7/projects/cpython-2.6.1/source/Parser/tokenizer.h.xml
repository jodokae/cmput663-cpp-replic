<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Parser/tokenizer.h"><cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_TOKENIZER_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py_TOKENIZER_H</name></cpp:macro></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"object.h"</cpp:file></cpp:include>

<comment type="block">/* Tokenizer interface */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"token.h"</cpp:file></cpp:include>	<comment type="block">/* For token types */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXINDENT</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>	<comment type="block">/* Max indentation level */</comment>

<comment type="block">/* Tokenizer state */</comment>
<struct>struct <name>tok_state</name> <block>{
	<comment type="block">/* Input state; buf &lt;= cur &lt;= inp &lt;= end */</comment>
	<comment type="block">/* NB an entire line is held in the buffer */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>	<comment type="block">/* Input buffer, or NULL; malloc'ed if fp != NULL */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>cur</name></decl>;</decl_stmt>	<comment type="block">/* Next character in buffer */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>inp</name></decl>;</decl_stmt>	<comment type="block">/* End of data in buffer */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>	<comment type="block">/* End of input buffer if buf != NULL */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>;</decl_stmt>	<comment type="block">/* Start of current token if not NULL */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>	<comment type="block">/* E_OK normally, E_EOF at EOF, otherwise error code */</comment>
	<comment type="block">/* NB If done != E_OK, cur must be == inp!!! */</comment>
	<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>	<comment type="block">/* Rest of input; NULL if tokenizing a string */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>tabsize</name></decl>;</decl_stmt>	<comment type="block">/* Tab spacing */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>indent</name></decl>;</decl_stmt>	<comment type="block">/* Current indentation index */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name><name>indstack</name><index>[<expr><name>MAXINDENT</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Stack of indents */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>atbol</name></decl>;</decl_stmt>	<comment type="block">/* Nonzero if at begin of new line */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>pendin</name></decl>;</decl_stmt>	<comment type="block">/* Pending indents (if &gt; 0) or dedents (if &lt; 0) */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>prompt</name></decl>, *<decl><type ref="prev"/><name>nextprompt</name></decl>;</decl_stmt>	<comment type="block">/* For interactive prompting */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>;</decl_stmt>	<comment type="block">/* Current line number */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>	<comment type="block">/* () [] {} Parentheses nesting level */</comment>
			<comment type="block">/* Used to allow free continuations inside them */</comment>
	<comment type="block">/* Stuff for checking on different tab sizes */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl>;</decl_stmt>	<comment type="block">/* For error messages */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>altwarning</name></decl>;</decl_stmt>	<comment type="block">/* Issue warning if alternate tabs don't match */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>alterror</name></decl>;</decl_stmt>	<comment type="block">/* Issue error if alternate tabs don't match */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>alttabsize</name></decl>;</decl_stmt>	<comment type="block">/* Alternate tab spacing */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name><name>altindstack</name><index>[<expr><name>MAXINDENT</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Stack of alternate indents */</comment>
	<comment type="block">/* Stuff for PEP 0263 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>decoding_state</name></decl>;</decl_stmt>	<comment type="block">/* -1:decoding, 0:init, 1:raw */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>decoding_erred</name></decl>;</decl_stmt>	<comment type="block">/* whether erred in decoding  */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>read_coding_spec</name></decl>;</decl_stmt>	<comment type="block">/* whether 'coding:...' has been read  */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>encoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cont_line</name></decl>;</decl_stmt>          <comment type="block">/* whether we are in a continuation line. */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>line_start</name></decl>;</decl_stmt>	<comment type="block">/* pointer to start of current line */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PGEN</name></cpp:ifndef>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>decoding_readline</name></decl>;</decl_stmt> <comment type="block">/* codecs.open(...).readline */</comment>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>decoding_buffer</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>enc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>str</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> struct <name>tok_state</name> *</type><name>PyTokenizer_FromString</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> struct <name>tok_state</name> *</type><name>PyTokenizer_FromFile</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>PyTokenizer_Free</name><parameter_list>(<param><decl><type>struct</type> <name>tok_state</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>PyTokenizer_Get</name><parameter_list>(<param><decl><type>struct</type> <name>tok_state</name> *</decl></param>, <param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>char</name> **</type></decl></param>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PGEN</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type> <name>PyTokenizer_RestoreEncoding</name><parameter_list>(<param><decl><type>struct <name>tok_state</name>*</type> <name>tok</name></decl></param>, 
					  <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name> *</type><name>offset</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Py_TOKENIZER_H */</comment>
</unit>
