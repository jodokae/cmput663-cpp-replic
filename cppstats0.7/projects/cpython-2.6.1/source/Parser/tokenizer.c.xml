<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Parser/tokenizer.c">
<comment type="block">/* Tokenizer implementation */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgenheaders.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tokenizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errcode.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PGEN</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unicodeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fileobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"codecs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"abstract.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pydebug.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGEN */</comment>

<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>PyOS_Readline</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/* Return malloc'ed string including trailing \n;
   empty malloc'ed string for EOF;
   NULL if interrupted */</comment>

<comment type="block">/* Don't ever change this -- it would break the portability of Python code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TABSIZE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/* Forward */</comment>
<function_decl><type><specifier>static</specifier> struct <name>tok_state</name> *</type><name>tok_new</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>tok_nextc</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tok_backup</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Token names */</comment>

<decl_stmt><decl><type><name>char</name> *</type><name><name>_PyParser_TokenNames</name><index>[]</index></name> <init>= <expr><block>{
	<expr>"ENDMARKER"</expr>,
	<expr>"NAME"</expr>,
	<expr>"NUMBER"</expr>,
	<expr>"STRING"</expr>,
	<expr>"NEWLINE"</expr>,
	<expr>"INDENT"</expr>,
	<expr>"DEDENT"</expr>,
	<expr>"LPAR"</expr>,
	<expr>"RPAR"</expr>,
	<expr>"LSQB"</expr>,
	<expr>"RSQB"</expr>,
	<expr>"COLON"</expr>,
	<expr>"COMMA"</expr>,
	<expr>"SEMI"</expr>,
	<expr>"PLUS"</expr>,
	<expr>"MINUS"</expr>,
	<expr>"STAR"</expr>,
	<expr>"SLASH"</expr>,
	<expr>"VBAR"</expr>,
	<expr>"AMPER"</expr>,
	<expr>"LESS"</expr>,
	<expr>"GREATER"</expr>,
	<expr>"EQUAL"</expr>,
	<expr>"DOT"</expr>,
	<expr>"PERCENT"</expr>,
	<expr>"BACKQUOTE"</expr>,
	<expr>"LBRACE"</expr>,
	<expr>"RBRACE"</expr>,
	<expr>"EQEQUAL"</expr>,
	<expr>"NOTEQUAL"</expr>,
	<expr>"LESSEQUAL"</expr>,
	<expr>"GREATEREQUAL"</expr>,
	<expr>"TILDE"</expr>,
	<expr>"CIRCUMFLEX"</expr>,
	<expr>"LEFTSHIFT"</expr>,
	<expr>"RIGHTSHIFT"</expr>,
	<expr>"DOUBLESTAR"</expr>,
	<expr>"PLUSEQUAL"</expr>,
	<expr>"MINEQUAL"</expr>,
	<expr>"STAREQUAL"</expr>,
	<expr>"SLASHEQUAL"</expr>,
	<expr>"PERCENTEQUAL"</expr>,
	<expr>"AMPEREQUAL"</expr>,
	<expr>"VBAREQUAL"</expr>,
	<expr>"CIRCUMFLEXEQUAL"</expr>,
	<expr>"LEFTSHIFTEQUAL"</expr>,
	<expr>"RIGHTSHIFTEQUAL"</expr>,
	<expr>"DOUBLESTAREQUAL"</expr>,
	<expr>"DOUBLESLASH"</expr>,
	<expr>"DOUBLESLASHEQUAL"</expr>,
	<expr>"AT"</expr>,
	<comment type="block">/* This table must match the #defines in token.h! */</comment>
	<expr>"OP"</expr>,
	<expr>"&lt;ERRORTOKEN&gt;"</expr>,
	<expr>"&lt;N_TOKENS&gt;"</expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Create and initialize a new tok_state structure */</comment>

<function><type><specifier>static</specifier> struct <name>tok_state</name> *</type>
<name>tok_new</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>tok_state</name> *</type><name>tok</name> <init>= <expr>(struct <name>tok_state</name> *)<call><name>PyMem_MALLOC</name><argument_list>(
                                                <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>tok_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>tok</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = <name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>end</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name> = <name><name>tok</name>-&gt;<name>start</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>fp</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>tabsize</name></name> = <name>TABSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>indent</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>indstack</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>atbol</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>pendin</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>prompt</name></name> = <name><name>tok</name>-&gt;<name>nextprompt</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>lineno</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>level</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>filename</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>altwarning</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>alterror</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>alttabsize</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>altindstack</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_state</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_erred</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>read_coding_spec</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>encoding</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tok</name>-&gt;<name>cont_line</name></name> = 0</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PGEN</name></cpp:ifndef>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_readline</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>tok</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGEN</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>decoding_fgets</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>, <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>fgets</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>decoding_feof</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><call><name>feof</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>decode_str</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>str</name></expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* PGEN */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>error_ret</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list> <comment type="block">/* XXX */</comment>
<block>{
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_erred</name></name> = 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>fp</name></name> != <name>NULL</name> &amp;&amp; <name><name>tok</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr>)</condition><then> <comment type="block">/* see PyTokenizer_Free */</comment>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>		<comment type="block">/* as if it were EOF */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>new_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name>*</type> <name>result</name> <init>= <expr>(<name>char</name> *)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>get_normal_name</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>)</parameter_list>	<comment type="block">/* for utf-8 and latin-1 */</comment>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>13</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 12</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>c</name> == '\0'</expr>)</condition><then> <break>break;</break></then>
		<else>else <if>if <condition>(<expr><name>c</name> == '_'</expr>)</condition><then> <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = '-'</expr>;</expr_stmt></then>
		<else>else <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
	}</block></for>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"utf-8"</expr></argument>)</argument_list></call> == 0 ||
	    <call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"utf-8-"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <return>return <expr>"utf-8"</expr>;</return></then>
	<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"latin-1"</expr></argument>)</argument_list></call> == 0 ||
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"iso-8859-1"</expr></argument>)</argument_list></call> == 0 ||
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"iso-latin-1"</expr></argument>)</argument_list></call> == 0 ||
		 <call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"latin-1-"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0 ||
		 <call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"iso-8859-1-"</expr></argument>, <argument><expr>11</expr></argument>)</argument_list></call> == 0 ||
		 <call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"iso-latin-1-"</expr></argument>, <argument><expr>12</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <return>return <expr>"iso-8859-1"</expr>;</return></then>
	<else>else <return>return <expr><name>s</name></expr>;</return></else></if></else></if>
}</block></function>

<comment type="block">/* Return the coding spec in S, or NULL if none is found.  */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>get_coding_spec</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
	<comment type="block">/* Coding spec must be in a comment, and that comment must be
         * the only statement on the source code line. */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name> - 6</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '#'</expr>)</condition><then>
			<break>break;</break></then></if>
		<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != ' ' &amp;&amp; <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != '\t' &amp;&amp; <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != '\014'</expr>)</condition><then>
			<return>return <expr><name>NULL</name></expr>;</return></then></if>
	}</block></for>
	<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>size</name> - 6</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{ <comment type="block">/* XXX inefficient search */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>t</name> <init>= <expr><name>s</name> + <name>i</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>"coding"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>begin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>t</name> += 6</expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>t</name><index>[<expr>0</expr>]</index></name> != ':' &amp;&amp; <name><name>t</name><index>[<expr>0</expr>]</index></name> != '='</expr>)</condition><then>
				<continue>continue;</continue></then></if>
			<do>do <block>{
				<expr_stmt><expr><name>t</name>++</expr>;</expr_stmt>
			}</block> while <condition>(<expr><name><name>t</name><index>[<expr>0</expr>]</index></name> == '\x20' || <name><name>t</name><index>[<expr>0</expr>]</index></name> == '\t'</expr>)</condition>;</do>

			<expr_stmt><expr><name>begin</name> = <name>t</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ||
			       <name><name>t</name><index>[<expr>0</expr>]</index></name> == '-' || <name><name>t</name><index>[<expr>0</expr>]</index></name> == '_' || <name><name>t</name><index>[<expr>0</expr>]</index></name> == '.'</expr>)</condition>
				<expr_stmt><expr><name>t</name>++</expr>;</expr_stmt></while>

			<if>if <condition>(<expr><name>begin</name> &lt; <name>t</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name>*</type> <name>r</name> <init>= <expr><call><name>new_string</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>t</name> - <name>begin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>*</type> <name>q</name> <init>= <expr><call><name>get_normal_name</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>r</name> != <name>q</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>r</name> = <call><name>new_string</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<return>return <expr><name>r</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Check whether the line contains a coding spec. If it does,
   invoke the set_readline function for the new encoding.
   This function receives the tok_state and the new encoding.
   Return 1 on success, 0 on failure.  */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_coding_spec</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>line</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>,
		  <param><function_decl><type><name>int</name></type> <name>set_readline</name><parameter_list>(<param><decl><type>struct</type> <name>tok_state</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type> <name>cs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>tok</name>-&gt;<name>cont_line</name></name></expr>)</condition><then>
		<comment type="block">/* It's a continuation line, so it can't be a coding spec. */</comment>
		<return>return <expr>1</expr>;</return></then></if>
	<expr_stmt><expr><name>cs</name> = <call><name>get_coding_spec</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>cs</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>read_coding_spec</name></name> = 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>encoding</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>decoding_state</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* raw */</comment>
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr>"utf-8"</expr></argument>)</argument_list></call> == 0 ||
			    <call><name>strcmp</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr>"iso-8859-1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>encoding</name></name> = <name>cs</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
				<expr_stmt><expr><name>r</name> = <call><name>set_readline</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>r</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>encoding</name></name> = <name>cs</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_state</name></name> = -1</expr>;</expr_stmt>
				}</block></then>
				<else>else
					<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                <comment type="block">/* Without Unicode support, we cannot
                                   process the coding spec. Since there
                                   won't be any Unicode literals, that
                                   won't matter. */</comment>
				<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			}</block></else></if>
		}</block></then> <else>else <block>{	<comment type="block">/* then, compare cs with BOM */</comment>
			<expr_stmt><expr><name>r</name> = (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>encoding</name></name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call> == 0)</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>
	<if>if <condition>(<expr>!<name>r</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>cs</name> = <name><name>tok</name>-&gt;<name>encoding</name></name></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>cs</name></expr>)</condition><then>
			<expr_stmt><expr><name>cs</name> = "with BOM"</expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr>"encoding problem: %s"</expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>r</name></expr>;</return>
}</block></function>

<comment type="block">/* See whether the file starts with a BOM. If it does,
   invoke the set_readline function with the new encoding.
   Return 1 on success, 0 on failure.  */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_bom</name><parameter_list>(<param><function_decl><type><name>int</name></type> <name>get_char</name><parameter_list>(<param><decl><type>struct</type> <name>tok_state</name> *</decl></param>)</parameter_list></function_decl></param>,
	  <param><function_decl><type><name>void</name></type> <name>unget_char</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type>struct</type> <name>tok_state</name> *</decl></param>)</parameter_list></function_decl></param>,
	  <param><function_decl><type><name>int</name></type> <name>set_readline</name><parameter_list>(<param><decl><type>struct</type> <name>tok_state</name> *</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list></function_decl></param>,
	  <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><call><name>get_char</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_state</name></name> = 1</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ch</name> == <name>EOF</name></expr>)</condition><then> <block>{
		<return>return <expr>1</expr>;</return>
	}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0xEF</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ch</name> = <call><name>get_char</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr><name>ch</name> != 0xBB</expr>)</condition><then> <goto>goto <name>NON_BOM</name>;</goto></then></if>
		<expr_stmt><expr><name>ch</name> = <call><name>get_char</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr><name>ch</name> != 0xBF</expr>)</condition><then> <goto>goto <name>NON_BOM</name>;</goto></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
	<comment type="block">/* Disable support for UTF-16 BOMs until a decision
	   is made whether this needs to be supported.  */</comment>
	} else if (ch == 0xFE) {
		ch = get_char(tok); if (ch != 0xFF) goto NON_BOM;
		if (!set_readline(tok, "utf-16-be")) return 0;
		tok-&gt;decoding_state = -1;
	} else if (ch == 0xFF) {
		ch = get_char(tok); if (ch != 0xFE) goto NON_BOM;
		if (!set_readline(tok, "utf-16-le")) return 0;
		tok-&gt;decoding_state = -1;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>unget_char</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></else></if></else></if>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>encoding</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>encoding</name></name> = <call><name>new_string</name><argument_list>(<argument><expr>"utf-8"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* resulting is in utf-8 */</comment>
	<return>return <expr>1</expr>;</return>
  <label><name>NON_BOM</name>:</label>
	<comment type="block">/* any token beginning with '\xEF', '\xFE', '\xFF' is a bad token */</comment>
	<expr_stmt><expr><call><name>unget_char</name><argument_list>(<argument><expr>0xFF</expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* XXX this will cause a syntax error */</comment>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Read a line of text from TOK into S, using the stream in TOK.
   Return NULL on failure, else S.

   On entry, tok-&gt;decoding_buffer will be one of:
     1) NULL: need to call tok-&gt;decoding_readline to get a new line
     2) PyUnicodeObject *: decoding_feof has called tok-&gt;decoding_readline and
           stored the result in tok-&gt;decoding_buffer
     3) PyStringObject *: previous call to fp_readl did not have enough room
           (in the s buffer) to copy entire contents of the line read
           by tok-&gt;decoding_readline.  tok-&gt;decoding_buffer has the overflow.
           In this case, fp_readl is called in a loop (with an expanded buffer)
           until the buffer ends with a '\n' (or until the end of the file is
           reached): see tok_nextc and its calls to decoding_fgets.
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>fp_readl</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>, <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifndef>
	<comment type="block">/* In a non-Unicode built, this should never be called. */</comment>
	<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"fp_readl should not be called in this build."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* Keep compiler happy (not reachable) */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>utf8</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>buf</name> <init>= <expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>utf8len</name></decl>;</decl_stmt>

	<comment type="block">/* Ask for one less byte so we can terminate it */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>

	<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>buf</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>decoding_readline</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>utf8</name> = <name>buf</name></expr>;</expr_stmt></then></if>
	}</block></else></if>
	<if>if <condition>(<expr><name>utf8</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>utf8</name> = <call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>utf8</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	}</block></then></if>
	<expr_stmt><expr><name>str</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>utf8len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>utf8len</name> &gt; <name>size</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>str</name>+<name>size</name></expr></argument>, <argument><expr><name>utf8len</name>-<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>utf8len</name> = <name>size</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>utf8len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><index>[<expr><name>utf8len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>utf8len</name> == 0</expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if> <comment type="block">/* EOF */</comment>
	<return>return <expr><name>s</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* Set the readline function for TOK to a StreamReader's
   readline function. The StreamReader is named ENC.

   This function is called from check_bom and check_coding_spec.

   ENC is usually identical to the future value of tok-&gt;encoding,
   except for the (currently unsupported) case of UTF-16.

   Return 1 on success, 0 on failure. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fp_setreadl</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>enc</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>reader</name></decl>, *<decl><type ref="prev"/><name>stream</name></decl>, *<decl><type ref="prev"/><name>readline</name></decl>;</decl_stmt>

	<comment type="block">/* XXX: constify filename argument. */</comment>
	<expr_stmt><expr><name>stream</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr>(<name>char</name>*)<name><name>tok</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"rb"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>stream</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name>reader</name> = <call><name>PyCodec_StreamReader</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>reader</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name>readline</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr>"readline"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>readline</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_readline</name></name> = <name>readline</name></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Fetch the next byte from TOK. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fp_getc</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>getc</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Unfetch the last byte back into TOK.  */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fp_ungetc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>, <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list> <block>{
	<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Read a line of input from TOK. Determine encoding
   if necessary.  */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>decoding_fgets</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>, <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>badchar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>decoding_state</name></name> &lt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* We already have a codec associated with
			   this input. */</comment>
			<expr_stmt><expr><name>line</name> = <call><name>fp_readl</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then> <else>else <if>if <condition>(<expr><name><name>tok</name>-&gt;<name>decoding_state</name></name> &gt; 0</expr>)</condition><then> <block>{
			<comment type="block">/* We want a 'raw' read. */</comment>
			<expr_stmt><expr><name>line</name> = <call><name>Py_UniversalNewlineFgets</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
							<argument><expr><name><name>tok</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		}</block></then> <else>else <block>{
			<comment type="block">/* We have not yet determined the encoding.
			   If an encoding is found, use the file-pointer
			   reader functions from now on. */</comment>
			<if>if <condition>(<expr>!<call><name>check_bom</name><argument_list>(<argument><expr><name>fp_getc</name></expr></argument>, <argument><expr><name>fp_ungetc</name></expr></argument>, <argument><expr><name>fp_setreadl</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>decoding_state</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if></else></if>
	}</block></for>
	<if>if <condition>(<expr><name>line</name> != <name>NULL</name> &amp;&amp; <name><name>tok</name>-&gt;<name>lineno</name></name> &lt; 2 &amp;&amp; !<name><name>tok</name>-&gt;<name>read_coding_spec</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>check_coding_spec</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>fp_setreadl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
	}</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PGEN</name></cpp:ifndef>
	<comment type="block">/* The default encoding is ASCII, so make sure we don't have any
           non-ASCII bytes in it. */</comment>
	<if>if <condition>(<expr><name>line</name> &amp;&amp; !<name><name>tok</name>-&gt;<name>encoding</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>c</name></decl>;</decl_stmt>
		<for>for (<init><expr><name>c</name> = (<name>unsigned</name> <name>char</name> *)<name>line</name></expr>;</init> <condition><expr>*<name>c</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>)
			<if>if <condition>(<expr>*<name>c</name> &gt; 127</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>badchar</name> = *<name>c</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if></for>
	}</block></then></if>
	<if>if <condition>(<expr><name>badchar</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>500</expr>]</index></name></decl>;</decl_stmt>
		<comment type="block">/* Need to add 1 to the line number, since this line
		   has not been counted, yet.  */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
			<argument><expr>"Non-ASCII character '\\x%.2x' "
			"in file %.200s on line %i, "
			"but no encoding declared; "
			"see http://www.python.org/peps/pep-0263.html for details"</expr></argument>,
			<argument><expr><name>badchar</name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>lineno</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>line</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>decoding_feof</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>decoding_state</name></name> &gt;= 0</expr>)</condition><then> <block>{
		<return>return <expr><call><name>feof</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <block>{
		<decl_stmt><decl><type><name>PyObject</name>*</type> <name>buf</name> <init>= <expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>buf</name> = <call><name>PyObject_CallObject</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>decoding_readline</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>1</expr>;</return>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name> = <name>buf</name></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then></if>
		<return>return <expr><call><name>PyObject_Length</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
	}</block></else></if>
}</block></function>

<comment type="block">/* Fetch a byte from TOK, using the string buffer. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>buf_getc</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list> <block>{
	<return>return <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name><name>tok</name>-&gt;<name>str</name></name>++</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Unfetch a byte from TOK, using the string buffer. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>buf_ungetc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>, <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list> <block>{
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>str</name></name>--</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name><name>tok</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call> == <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* tok-&gt;cur may point to read-only segment */</comment>
}</block></function>

<comment type="block">/* Set the readline function for TOK to ENC. For the string-based
   tokenizer, this means to just record the encoding. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>buf_setreadl</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>enc</name></decl></param>)</parameter_list> <block>{
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>enc</name></name> = <name>enc</name></expr>;</expr_stmt>
	<return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* Return a UTF-8 encoding Python string object from the
   C byte string STR, which is encoded with ENC. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>translate_into_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>enc</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>utf8</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>buf</name> <init>= <expr><call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>utf8</name> = <call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>utf8</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Decode a byte string STR for use as the buffer of TOK.
   Look for encoding declarations inside STR, and record them
   inside TOK.  */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>decode_str</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name>*</type> <name>utf8</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>newl</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>enc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>str</name></name> = <name>str</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>check_bom</name><argument_list>(<argument><expr><name>buf_getc</name></expr></argument>, <argument><expr><name>buf_ungetc</name></expr></argument>, <argument><expr><name>buf_setreadl</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><name>str</name> = <name><name>tok</name>-&gt;<name>str</name></name></expr>;</expr_stmt>		<comment type="block">/* string after BOM if any */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>enc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>utf8</name> = <call><name>translate_into_utf8</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>utf8</name> == <name>NULL</name></expr>)</condition><then>
			<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name>str</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<for>for (<init><expr><name>s</name> = <name>str</name></expr>;</init><condition>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr>*<name>s</name> == '\0'</expr>)</condition><then> <break>break;</break></then>
		<else>else <if>if <condition>(<expr>*<name>s</name> == '\n'</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lineno</name> &lt; 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newl</name><index>[<expr><name>lineno</name></expr>]</index></name> = <name>s</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lineno</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>lineno</name> == 2</expr>)</condition><then> <break>break;</break></then></if>
		}</block></then></if></else></if>
	}</block></for>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>enc</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* need to check line 1 and 2 separately since check_coding_spec
	   assumes a single line as input */</comment>
	<if>if <condition>(<expr><name><name>newl</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>!<call><name>check_coding_spec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>newl</name><index>[<expr>0</expr>]</index></name> - <name>str</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>buf_setreadl</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>enc</name></name> == <name>NULL</name> &amp;&amp; <name><name>newl</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>!<call><name>check_coding_spec</name><argument_list>(<argument><expr><name><name>newl</name><index>[<expr>0</expr>]</index></name>+1</expr></argument>, <argument><expr><name><name>newl</name><index>[<expr>1</expr>]</index></name> - <name><name>newl</name><index>[<expr>0</expr>]</index></name></expr></argument>,
					       <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>buf_setreadl</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
		}</block></then></if>
	}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>enc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>utf8</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>utf8</name> = <call><name>translate_into_utf8</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>utf8</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>,
				<argument><expr>"unknown encoding: %s"</expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>error_ret</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><name>str</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name> = <name>utf8</name></expr>;</expr_stmt> <comment type="block">/* CAUTION */</comment>
	<return>return <expr><name>str</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGEN */</comment>

<comment type="block">/* Set up tokenizer for string */</comment>

<function><type>struct <name>tok_state</name> *</type>
<name>PyTokenizer_FromString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>tok_state</name> *</type><name>tok</name> <init>= <expr><call><name>tok_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>tok</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>str</name> = (<name>char</name> *)<call><name>decode_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyTokenizer_Free</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* XXX: constify members. */</comment>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = <name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>end</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name> = (<name>char</name>*)<name>str</name></expr>;</expr_stmt>
	<return>return <expr><name>tok</name></expr>;</return>
}</block></function>


<comment type="block">/* Set up tokenizer for file */</comment>

<function><type>struct <name>tok_state</name> *</type>
<name>PyTokenizer_FromFile</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ps1</name></decl></param>, <param><decl><type><name>char</name> *</type><name>ps2</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>tok_state</name> *</type><name>tok</name> <init>= <expr><call><name>tok_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>tok</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<if>if <condition>(<expr>(<name><name>tok</name>-&gt;<name>buf</name></name> = (<name>char</name> *)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyTokenizer_Free</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>end</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name> + <name>BUFSIZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>fp</name></name> = <name>fp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>prompt</name></name> = <name>ps1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>nextprompt</name></name> = <name>ps2</name></expr>;</expr_stmt>
	<return>return <expr><name>tok</name></expr>;</return>
}</block></function>


<comment type="block">/* Free a tok_state structure */</comment>

<function><type><name>void</name></type>
<name>PyTokenizer_Free</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>encoding</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PGEN</name></cpp:ifndef>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>decoding_readline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>decoding_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>fp</name></name> != <name>NULL</name> &amp;&amp; <name><name>tok</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PGEN</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tok_stdin_decode</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>, <param><decl><type><name>char</name> **</type><name>inp</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>enc</name></decl>, *<decl><type ref="prev"/><name>sysstdin</name></decl>, *<decl><type ref="prev"/><name>decoded</name></decl>, *<decl><type ref="prev"/><name>utf8</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>converted</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PySys_GetFile</name><argument_list>(<argument><expr>(<name>char</name> *)"stdin"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>stdin</name></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>sysstdin</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stdin"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>sysstdin</name> == <name>NULL</name> || !<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>sysstdin</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name>enc</name> = ((<name>PyFileObject</name> *)<name>sysstdin</name>)-&gt;<name>f_encoding</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>enc</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>encoding</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>decoded</name> = <call><name>PyUnicode_Decode</name><argument_list>(<argument><expr>*<name>inp</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr>*<name>inp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>decoded</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error_clear</name>;</goto></then></if>

	<expr_stmt><expr><name>utf8</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr>"utf-8"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>utf8</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error_clear</name>;</goto></then></if>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>converted</name> = <call><name>new_string</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr></argument>,
			       <argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>converted</name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error_nomem</name>;</goto></then></if>

	<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr>*<name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>inp</name> = <name>converted</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>encoding</name></name> != <name>NULL</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>encoding</name></name> = <call><name>new_string</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>encoding</name></name> == <name>NULL</name></expr>)</condition><then>
		<goto>goto <name>error_nomem</name>;</goto></then></if>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>

<label><name>error_nomem</name>:</label>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_NOMEM</name></expr>;</expr_stmt>
	<return>return <expr>-1</expr>;</return>

<label><name>error_clear</name>:</label>
	<comment type="block">/* Fallback to iso-8859-1: for backward compatibility */</comment>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Get next char, updating state; error code goes into tok-&gt;done */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>
<name>tok_nextc</name><argument_list>(<argument><expr><name>register</name> struct <name>tok_state</name> *<name>tok</name></expr></argument>)</argument_list>
<block>{
	<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>cur</name></name> != <name><name>tok</name>-&gt;<name>inp</name></name></expr>)</condition><then> <block>{
			<return>return <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name><name>tok</name>-&gt;<name>cur</name></name>++</expr></argument>)</argument_list></call></expr>;</return> <comment type="block">/* Fast path */</comment>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>done</name></name> != <name>E_OK</name></expr>)</condition><then>
			<return>return <expr><name>EOF</name></expr>;</return></then></if>
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>fp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>end</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>inp</name></name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>end</name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>end</name>++</expr>;</expr_stmt></then>
			<else>else <block>{
				<expr_stmt><expr><name>end</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>inp</name></name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>end</name> == <name><name>tok</name>-&gt;<name>inp</name></name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_EOF</name></expr>;</expr_stmt>
					<return>return <expr><name>EOF</name></expr>;</return>
				}</block></then></if>
			}</block></else></if>
			<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>start</name></name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>line_start</name></name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>lineno</name></name>++</expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>inp</name></name> = <name>end</name></expr>;</expr_stmt>
			<return>return <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name><name>tok</name>-&gt;<name>cur</name></name>++</expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>prompt</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>char</name> *</type><name>newtok</name> <init>= <expr><call><name>PyOS_Readline</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>prompt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>nextprompt</name></name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>prompt</name></name> = <name><name>tok</name>-&gt;<name>nextprompt</name></name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>newtok</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_INTR</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr>*<name>newtok</name> == '\0'</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>newtok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_EOF</name></expr>;</expr_stmt>
			}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PGEN</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<else>else <if>if <condition>(<expr><call><name>tok_stdin_decode</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>&amp;<name>newtok</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
				<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>newtok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else <if>if <condition>(<expr><name><name>tok</name>-&gt;<name>start</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>size_t</name></type> <name>start</name> <init>= <expr><name><name>tok</name>-&gt;<name>start</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type> <name>oldlen</name> <init>= <expr><name><name>tok</name>-&gt;<name>cur</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type> <name>newlen</name> <init>= <expr><name>oldlen</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>newtok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>buf</name> = (<name>char</name> *)<call><name>PyMem_REALLOC</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>newlen</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>lineno</name></name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>newtok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_NOMEM</name></expr>;</expr_stmt>
					<return>return <expr><name>EOF</name></expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = <name>buf</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name> + <name>oldlen</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>line_start</name></name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>buf</name></name> + <name>oldlen</name></expr></argument>, <argument><expr><name>newtok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>newtok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>inp</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name> + <name>newlen</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>end</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name> + 1</expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>start</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name> + <name>start</name></expr>;</expr_stmt>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>lineno</name></name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = <name>newtok</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>line_start</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>line_start</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>inp</name></name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>end</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name> + 1</expr>;</expr_stmt>
			}</block></else></if></else></if></else></if></else></if>
		}</block></then>
		<else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cur</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type><name>pt</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>start</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>buf</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = (<name>char</name> *)
						<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>buf</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_NOMEM</name></expr>;</expr_stmt>
						<return>return <expr><name>EOF</name></expr>;</return>
					}</block></then></if>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>end</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name> + <name>BUFSIZ</name></expr>;</expr_stmt>
				}</block></then></if>
				<if>if <condition>(<expr><call><name>decoding_fgets</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>end</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>tok</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_EOF</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>done</name> = 1</expr>;</expr_stmt>
				}</block></then>
				<else>else <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_OK</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>inp</name></name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>done</name> = <name><name>tok</name>-&gt;<name>inp</name><index>[<expr>-1</expr>]</index></name> == '\n'</expr>;</expr_stmt>
				}</block></else></if>
			}</block></then>
			<else>else <block>{
				<expr_stmt><expr><name>cur</name> = <name><name>tok</name>-&gt;<name>cur</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>decoding_feof</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_EOF</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>done</name> = 1</expr>;</expr_stmt>
				}</block></then>
				<else>else
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_OK</name></expr>;</expr_stmt></else></if>
			}</block></else></if>
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>lineno</name></name>++</expr>;</expr_stmt>
			<comment type="block">/* Read until '\n' or EOF */</comment>
			<while>while <condition>(<expr>!<name>done</name></expr>)</condition> <block>{
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>curstart</name> <init>= <expr><name><name>tok</name>-&gt;<name>start</name></name> == <name>NULL</name> ? -1 :
					          <name><name>tok</name>-&gt;<name>start</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>curvalid</name> <init>= <expr><name><name>tok</name>-&gt;<name>inp</name></name> - <name><name>tok</name>-&gt;<name>buf</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newsize</name> <init>= <expr><name>curvalid</name> + <name>BUFSIZ</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> *</type><name>newbuf</name> <init>= <expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>newbuf</name> = (<name>char</name> *)<call><name>PyMem_REALLOC</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>,
							       <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>newbuf</name> == <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_NOMEM</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name></expr>;</expr_stmt>
					<return>return <expr><name>EOF</name></expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>buf</name></name> = <name>newbuf</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>inp</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name> + <name>curvalid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>end</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name> + <name>newsize</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>start</name></name> = <name>curstart</name> &lt; 0 ? <name>NULL</name> :
					     <name><name>tok</name>-&gt;<name>buf</name></name> + <name>curstart</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>decoding_fgets</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>inp</name></name></expr></argument>,
					       <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>end</name></name> - <name><name>tok</name>-&gt;<name>inp</name></name></expr></argument>)</argument_list></call></expr></argument>,
					       <argument><expr><name>tok</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
					<comment type="block">/* Break out early on decoding
					   errors, as tok-&gt;buf will be NULL
					 */</comment>
					<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>decoding_erred</name></name></expr>)</condition><then>
						<return>return <expr><name>EOF</name></expr>;</return></then></if>
					<comment type="block">/* Last line does not end in \n,
					   fake one */</comment>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>inp</name></name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>inp</name></name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>inp</name></name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>done</name> = <name><name>tok</name>-&gt;<name>inp</name><index>[<expr>-1</expr>]</index></name> == '\n'</expr>;</expr_stmt>
			}</block></while>
			<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>buf</name></name> + <name>cur</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>line_start</name></name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
				<comment type="block">/* replace "\r\n" with "\n" */</comment>
				<comment type="block">/* For Mac leave the \r, giving a syntax error */</comment>
				<expr_stmt><expr><name>pt</name> = <name><name>tok</name>-&gt;<name>inp</name></name> - 2</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>pt</name> &gt;= <name><name>tok</name>-&gt;<name>buf</name></name> &amp;&amp; *<name>pt</name> == '\r'</expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>pt</name>++ = '\n'</expr>;</expr_stmt>
					<expr_stmt><expr>*<name>pt</name> = '\0'</expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>inp</name></name> = <name>pt</name></expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>
		}</block></else></if>
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>done</name></name> != <name>E_OK</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>prompt</name></name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
		}</block></then></if>
	}</block></for>
	<comment type="block">/*NOTREACHED*/</comment>
}</block></decl></decl_stmt>


<comment type="block">/* Back-up one character */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>tok_backup</name><argument_list>(<argument><expr><name>register</name> struct <name>tok_state</name> *<name>tok</name></expr></argument>, <argument><expr><name>register</name> <name>int</name> <name>c</name></expr></argument>)</argument_list>
<block>{
	<if>if <condition>(<expr><name>c</name> != <name>EOF</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>--<name><name>tok</name>-&gt;<name>cur</name></name> &lt; <name><name>tok</name>-&gt;<name>buf</name></name></expr>)</condition><then>
			<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"tok_backup: begin of buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>*<name><name>tok</name>-&gt;<name>cur</name></name> != <name>c</name></expr>)</condition><then>
			<expr_stmt><expr>*<name><name>tok</name>-&gt;<name>cur</name></name> = <name>c</name></expr>;</expr_stmt></then></if>
	}</block></then></if>
}</block></decl></decl_stmt>


<comment type="block">/* Return the token corresponding to a single character */</comment>

<function><type><name>int</name></type>
<name>PyToken_OneChar</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
	<case>case <expr>'('</expr>:	<return>return <expr><name>LPAR</name></expr>;</return>
	</case><case>case <expr>')'</expr>:	<return>return <expr><name>RPAR</name></expr>;</return>
	</case><case>case <expr>'['</expr>:	<return>return <expr><name>LSQB</name></expr>;</return>
	</case><case>case <expr>']'</expr>:	<return>return <expr><name>RSQB</name></expr>;</return>
	</case><case>case <expr>':'</expr>:	<return>return <expr><name>COLON</name></expr>;</return>
	</case><case>case <expr>','</expr>:	<return>return <expr><name>COMMA</name></expr>;</return>
	</case><case>case <expr>';'</expr>:	<return>return <expr><name>SEMI</name></expr>;</return>
	</case><case>case <expr>'+'</expr>:	<return>return <expr><name>PLUS</name></expr>;</return>
	</case><case>case <expr>'-'</expr>:	<return>return <expr><name>MINUS</name></expr>;</return>
	</case><case>case <expr>'*'</expr>:	<return>return <expr><name>STAR</name></expr>;</return>
	</case><case>case <expr>'/'</expr>:	<return>return <expr><name>SLASH</name></expr>;</return>
	</case><case>case <expr>'|'</expr>:	<return>return <expr><name>VBAR</name></expr>;</return>
	</case><case>case <expr>'&amp;'</expr>:	<return>return <expr><name>AMPER</name></expr>;</return>
	</case><case>case <expr>'&lt;'</expr>:	<return>return <expr><name>LESS</name></expr>;</return>
	</case><case>case <expr>'&gt;'</expr>:	<return>return <expr><name>GREATER</name></expr>;</return>
	</case><case>case <expr>'='</expr>:	<return>return <expr><name>EQUAL</name></expr>;</return>
	</case><case>case <expr>'.'</expr>:	<return>return <expr><name>DOT</name></expr>;</return>
	</case><case>case <expr>'%'</expr>:	<return>return <expr><name>PERCENT</name></expr>;</return>
	</case><case>case <expr>'`'</expr>:	<return>return <expr><name>BACKQUOTE</name></expr>;</return>
	</case><case>case <expr>'{'</expr>:	<return>return <expr><name>LBRACE</name></expr>;</return>
	</case><case>case <expr>'}'</expr>:	<return>return <expr><name>RBRACE</name></expr>;</return>
	</case><case>case <expr>'^'</expr>:	<return>return <expr><name>CIRCUMFLEX</name></expr>;</return>
	</case><case>case <expr>'~'</expr>:	<return>return <expr><name>TILDE</name></expr>;</return>
	</case><case>case <expr>'@'</expr>:       <return>return <expr><name>AT</name></expr>;</return>
	</case><default>default:	<return>return <expr><name>OP</name></expr>;</return>
	</default>}</block></switch>
}</block></function>


<function><type><name>int</name></type>
<name>PyToken_TwoChars</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c1</name></decl></param>, <param><decl><type><name>int</name></type> <name>c2</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>c1</name></expr>)</condition> <block>{
	<case>case <expr>'='</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>EQEQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'!'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>NOTEQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'&lt;'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'&gt;'</expr>:	<return>return <expr><name>NOTEQUAL</name></expr>;</return>
		</case><case>case <expr>'='</expr>:	<return>return <expr><name>LESSEQUAL</name></expr>;</return>
		</case><case>case <expr>'&lt;'</expr>:	<return>return <expr><name>LEFTSHIFT</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'&gt;'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>GREATEREQUAL</name></expr>;</return>
		</case><case>case <expr>'&gt;'</expr>:	<return>return <expr><name>RIGHTSHIFT</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'+'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>PLUSEQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'-'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>MINEQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'*'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'*'</expr>:	<return>return <expr><name>DOUBLESTAR</name></expr>;</return>
		</case><case>case <expr>'='</expr>:	<return>return <expr><name>STAREQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'/'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'/'</expr>:	<return>return <expr><name>DOUBLESLASH</name></expr>;</return>
		</case><case>case <expr>'='</expr>:	<return>return <expr><name>SLASHEQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'|'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>VBAREQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'%'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>PERCENTEQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'&amp;'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>AMPEREQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'^'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'='</expr>:	<return>return <expr><name>CIRCUMFLEXEQUAL</name></expr>;</return>
		</case>}</block></switch>
		<break>break;</break>
	</case>}</block></switch>
	<return>return <expr><name>OP</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name>PyToken_ThreeChars</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c1</name></decl></param>, <param><decl><type><name>int</name></type> <name>c2</name></decl></param>, <param><decl><type><name>int</name></type> <name>c3</name></decl></param>)</parameter_list>
<block>{
	<switch>switch <condition>(<expr><name>c1</name></expr>)</condition> <block>{
	<case>case <expr>'&lt;'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'&lt;'</expr>:
			<switch>switch <condition>(<expr><name>c3</name></expr>)</condition> <block>{
			<case>case <expr>'='</expr>:
				<return>return <expr><name>LEFTSHIFTEQUAL</name></expr>;</return>
			</case>}</block></switch>
			<break>break;</break>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'&gt;'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'&gt;'</expr>:
			<switch>switch <condition>(<expr><name>c3</name></expr>)</condition> <block>{
			<case>case <expr>'='</expr>:
				<return>return <expr><name>RIGHTSHIFTEQUAL</name></expr>;</return>
			</case>}</block></switch>
			<break>break;</break>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'*'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'*'</expr>:
			<switch>switch <condition>(<expr><name>c3</name></expr>)</condition> <block>{
			<case>case <expr>'='</expr>:
				<return>return <expr><name>DOUBLESTAREQUAL</name></expr>;</return>
			</case>}</block></switch>
			<break>break;</break>
		</case>}</block></switch>
		<break>break;</break>
	</case><case>case <expr>'/'</expr>:
		<switch>switch <condition>(<expr><name>c2</name></expr>)</condition> <block>{
		<case>case <expr>'/'</expr>:
			<switch>switch <condition>(<expr><name>c3</name></expr>)</condition> <block>{
			<case>case <expr>'='</expr>:
				<return>return <expr><name>DOUBLESLASHEQUAL</name></expr>;</return>
			</case>}</block></switch>
			<break>break;</break>
		</case>}</block></switch>
		<break>break;</break>
	</case>}</block></switch>
	<return>return <expr><name>OP</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>indenterror</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>)</parameter_list>
<block>{
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>alterror</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_TABSPACE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then></if>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>altwarning</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"%s: inconsistent use of tabs and spaces "
                                  "in indentation\n"</expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>altwarning</name></name> = 0</expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Get next token, after space stripping etc. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>
<name>tok_get</name><argument_list>(<argument><expr><name>register</name> struct <name>tok_state</name> *<name>tok</name></expr></argument>, <argument><expr><name>char</name> **<name>p_start</name></expr></argument>, <argument><expr><name>char</name> **<name>p_end</name></expr></argument>)</argument_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>blankline</name></decl>;</decl_stmt>

	<expr_stmt><expr>*<name>p_start</name> = *<name>p_end</name> = <name>NULL</name></expr>;</expr_stmt>
  <label><name>nextline</name>:</label>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>start</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>blankline</name> = 0</expr>;</expr_stmt>

	<comment type="block">/* Get indentation level */</comment>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>atbol</name></name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>col</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>altcol</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>atbol</name></name> = 0</expr>;</expr_stmt>
		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
			<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == ' '</expr>)</condition><then>
				<expr_stmt><expr><name>col</name>++</expr>, <expr><name>altcol</name>++</expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>c</name> == '\t'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>col</name> = (<name>col</name>/<name><name>tok</name>-&gt;<name>tabsize</name></name> + 1) * <name><name>tok</name>-&gt;<name>tabsize</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>altcol</name> = (<name>altcol</name>/<name><name>tok</name>-&gt;<name>alttabsize</name></name> + 1)
					* <name><name>tok</name>-&gt;<name>alttabsize</name></name></expr>;</expr_stmt>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>c</name> == '\014'</expr>)</condition><then> <comment type="block">/* Control-L (formfeed) */</comment>
				<expr_stmt><expr><name>col</name> = <name>altcol</name> = 0</expr>;</expr_stmt></then> <comment type="block">/* For Emacs users */</comment>
			<else>else
				<break>break;</break></else></if></else></if></else></if>
		}</block></for>
		<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> == '#' || <name>c</name> == '\n'</expr>)</condition><then> <block>{
			<comment type="block">/* Lines with only whitespace and/or comments
			   shouldn't affect the indentation and are
			   not passed to the parser as NEWLINE tokens,
			   except *totally* empty lines in interactive
			   mode, which signal the end of a command group. */</comment>
			<if>if <condition>(<expr><name>col</name> == 0 &amp;&amp; <name>c</name> == '\n' &amp;&amp; <name><name>tok</name>-&gt;<name>prompt</name></name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>blankline</name> = 0</expr>;</expr_stmt></then> <comment type="block">/* Let it through */</comment>
			<else>else
				<expr_stmt><expr><name>blankline</name> = 1</expr>;</expr_stmt></else></if> <comment type="block">/* Ignore completely */</comment>
			<comment type="block">/* We can't jump back right here since we still
			   may need to skip to the end of a comment */</comment>
		}</block></then></if>
		<if>if <condition>(<expr>!<name>blankline</name> &amp;&amp; <name><name>tok</name>-&gt;<name>level</name></name> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>col</name> == <name><name>tok</name>-&gt;<name>indstack</name><index>[<expr><name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name></expr>)</condition><then> <block>{
				<comment type="block">/* No change */</comment>
				<if>if <condition>(<expr><name>altcol</name> != <name><name>tok</name>-&gt;<name>altindstack</name><index>[<expr><name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><call><name>indenterror</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<return>return <expr><name>ERRORTOKEN</name></expr>;</return></then></if>
				}</block></then></if>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>col</name> &gt; <name><name>tok</name>-&gt;<name>indstack</name><index>[<expr><name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name></expr>)</condition><then> <block>{
				<comment type="block">/* Indent -- always one */</comment>
				<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>indent</name></name>+1 &gt;= <name>MAXINDENT</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_TOODEEP</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name></expr>;</expr_stmt>
					<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
				}</block></then></if>
				<if>if <condition>(<expr><name>altcol</name> &lt;= <name><name>tok</name>-&gt;<name>altindstack</name><index>[<expr><name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><call><name>indenterror</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<return>return <expr><name>ERRORTOKEN</name></expr>;</return></then></if>
				}</block></then></if>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>pendin</name></name>++</expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>indstack</name><index>[<expr>++<name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name> = <name>col</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>altindstack</name><index>[<expr><name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name> = <name>altcol</name></expr>;</expr_stmt>
			}</block></then>
			<else>else <comment type="block">/* col &lt; tok-&gt;indstack[tok-&gt;indent] */</comment> <block>{
				<comment type="block">/* Dedent -- any number, must be consistent */</comment>
				<while>while <condition>(<expr><name><name>tok</name>-&gt;<name>indent</name></name> &gt; 0 &amp;&amp;
					<name>col</name> &lt; <name><name>tok</name>-&gt;<name>indstack</name><index>[<expr><name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name></expr>)</condition> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>pendin</name></name>--</expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>indent</name></name>--</expr>;</expr_stmt>
				}</block></while>
				<if>if <condition>(<expr><name>col</name> != <name><name>tok</name>-&gt;<name>indstack</name><index>[<expr><name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_DEDENT</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name></expr>;</expr_stmt>
					<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
				}</block></then></if>
				<if>if <condition>(<expr><name>altcol</name> != <name><name>tok</name>-&gt;<name>altindstack</name><index>[<expr><name><name>tok</name>-&gt;<name>indent</name></name></expr>]</index></name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><call><name>indenterror</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><then>
						<return>return <expr><name>ERRORTOKEN</name></expr>;</return></then></if>
				}</block></then></if>
			}</block></else></if></else></if>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><name><name>tok</name>-&gt;<name>start</name></name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>

	<comment type="block">/* Return pending indents/dedents */</comment>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>pendin</name></name> != 0</expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>pendin</name></name> &lt; 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>pendin</name></name>++</expr>;</expr_stmt>
			<return>return <expr><name>DEDENT</name></expr>;</return>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>pendin</name></name>--</expr>;</expr_stmt>
			<return>return <expr><name>INDENT</name></expr>;</return>
		}</block></else></if>
	}</block></then></if>

 <label><name>again</name>:</label>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>start</name></name> = <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* Skip spaces */</comment>
	<do>do <block>{
		<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block> while <condition>(<expr><name>c</name> == ' ' || <name>c</name> == '\t' || <name>c</name> == '\014'</expr>)</condition>;</do>

	<comment type="block">/* Set start of current token */</comment>
	<expr_stmt><expr><name><name>tok</name>-&gt;<name>start</name></name> = <name><name>tok</name>-&gt;<name>cur</name></name> - 1</expr>;</expr_stmt>

	<comment type="block">/* Skip comment, while looking for tab-setting magic */</comment>
	<if>if <condition>(<expr><name>c</name> == '#'</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>tabforms</name><index>[]</index></name> <init>= <expr><block>{
			<expr>"tab-width:"</expr>,		<comment type="block">/* Emacs */</comment>
			<expr>":tabstop="</expr>,		<comment type="block">/* vim, full form */</comment>
			<expr>":ts="</expr>,			<comment type="block">/* vim, abbreviated form */</comment>
			<expr>"set tabsize="</expr>,		<comment type="block">/* will vi never die? */</comment>
		<comment type="block">/* more templates can be added here to support other editors */</comment>
		}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>cbuf</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>tp</name></decl>, **<decl><type ref="prev"/><name>cp</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>tp</name> = <name>cbuf</name></expr>;</expr_stmt>
		<do>do <block>{
			<expr_stmt><expr>*<name>tp</name>++ = <name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block> while <condition>(<expr><name>c</name> != <name>EOF</name> &amp;&amp; <name>c</name> != '\n' &amp;&amp;
			 <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>tp</name> - <name>cbuf</name> + 1</expr></argument>)</argument_list></call> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition>;</do>
		<expr_stmt><expr>*<name>tp</name> = '\0'</expr>;</expr_stmt>
		<for>for (<init><expr><name>cp</name> = <name>tabforms</name></expr>;</init>
		     <condition><expr><name>cp</name> &lt; <name>tabforms</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>tabforms</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>tabforms</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition>
		     <incr><expr><name>cp</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr>(<name>tp</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>, <argument><expr>*<name>cp</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>newsize</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>tp</name> + <call><name>strlen</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if>if <condition>(<expr><name>newsize</name> &gt;= 1 &amp;&amp; <name>newsize</name> &lt;= 40</expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>tabsize</name></name> = <name>newsize</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
					    <expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
						<argument><expr>"Tab size set to %d\n"</expr></argument>,
						<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				}</block></then></if>
			}</block></then></if>
		}</block></for>
		<while>while <condition>(<expr><name>c</name> != <name>EOF</name> &amp;&amp; <name>c</name> != '\n'</expr>)</condition>
			<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
	}</block></then></if>

	<comment type="block">/* Check for EOF and errors now */</comment>
	<if>if <condition>(<expr><name>c</name> == <name>EOF</name></expr>)</condition><then> <block>{
		<return>return <expr><name><name>tok</name>-&gt;<name>done</name></name> == <name>E_EOF</name> ? <name>ENDMARKER</name> : <name>ERRORTOKEN</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Identifier (most frequent token!) */</comment>
	<if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> || <name>c</name> == '_'</expr>)</condition><then> <block>{
		<comment type="block">/* Process r"", u"" and ur"" */</comment>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
		<case>case <expr>'b'</expr>:
		</case><case>case <expr>'B'</expr>:
			<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == 'r' || <name>c</name> == 'R'</expr>)</condition><then>
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>c</name> == '"' || <name>c</name> == '\''</expr>)</condition><then>
				<goto>goto <name>letter_quote</name>;</goto></then></if>
			<break>break;</break>
		</case><case>case <expr>'r'</expr>:
		</case><case>case <expr>'R'</expr>:
			<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == '"' || <name>c</name> == '\''</expr>)</condition><then>
				<goto>goto <name>letter_quote</name>;</goto></then></if>
			<break>break;</break>
		</case><case>case <expr>'u'</expr>:
		</case><case>case <expr>'U'</expr>:
			<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == 'r' || <name>c</name> == 'R'</expr>)</condition><then>
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>c</name> == '"' || <name>c</name> == '\''</expr>)</condition><then>
				<goto>goto <name>letter_quote</name>;</goto></then></if>
			<break>break;</break>
		</case>}</block></switch>
		<while>while <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> || <name>c</name> == '_'</expr>)</condition> <block>{
			<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p_start</name> = <name><name>tok</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p_end</name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
		<return>return <expr><name>NAME</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Newline */</comment>
	<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>atbol</name></name> = 1</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>blankline</name> || <name><name>tok</name>-&gt;<name>level</name></name> &gt; 0</expr>)</condition><then>
			<goto>goto <name>nextline</name>;</goto></then></if>
		<expr_stmt><expr>*<name>p_start</name> = <name><name>tok</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p_end</name> = <name><name>tok</name>-&gt;<name>cur</name></name> - 1</expr>;</expr_stmt> <comment type="block">/* Leave '\n' out of the string */</comment>
                <expr_stmt><expr><name><name>tok</name>-&gt;<name>cont_line</name></name> = 0</expr>;</expr_stmt>
		<return>return <expr><name>NEWLINE</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Period or number starting with period? */</comment>
	<if>if <condition>(<expr><name>c</name> == '.'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<goto>goto <name>fraction</name>;</goto>
		}</block></then>
		<else>else <block>{
			<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p_start</name> = <name><name>tok</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p_end</name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
			<return>return <expr><name>DOT</name></expr>;</return>
		}</block></else></if>
	}</block></then></if>

	<comment type="block">/* Number */</comment>
	<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>c</name> == '0'</expr>)</condition><then> <block>{
			<comment type="block">/* Hex, octal or binary -- maybe. */</comment>
			<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == '.'</expr>)</condition><then>
				<goto>goto <name>fraction</name>;</goto></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITHOUT_COMPLEX</name></cpp:ifndef>
			<if>if <condition>(<expr><name>c</name> == 'j' || <name>c</name> == 'J'</expr>)</condition><then>
				<goto>goto <name>imaginary</name>;</goto></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if>if <condition>(<expr><name>c</name> == 'x' || <name>c</name> == 'X'</expr>)</condition><then> <block>{

				<comment type="block">/* Hex */</comment>
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!<call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_TOKEN</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
				}</block></then></if>
				<do>do <block>{
					<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block> while <condition>(<expr><call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
			}</block></then>
                        <else>else <if>if <condition>(<expr><name>c</name> == 'o' || <name>c</name> == 'O'</expr>)</condition><then> <block>{
				<comment type="block">/* Octal */</comment>
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>c</name> &lt; '0' || <name>c</name> &gt;= '8'</expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_TOKEN</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
				}</block></then></if>
				<do>do <block>{
					<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block> while <condition>(<expr>'0' &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt; '8'</expr>)</condition>;</do>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>c</name> == 'b' || <name>c</name> == 'B'</expr>)</condition><then> <block>{
				<comment type="block">/* Binary */</comment>
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>c</name> != '0' &amp;&amp; <name>c</name> != '1'</expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_TOKEN</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
				}</block></then></if>
				<do>do <block>{
					<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block> while <condition>(<expr><name>c</name> == '0' || <name>c</name> == '1'</expr>)</condition>;</do>
			}</block></then>
			<else>else <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>found_decimal</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
				<comment type="block">/* Octal; c is first char of it */</comment>
				<comment type="block">/* There's no 'isoctdigit' macro, sigh */</comment>
				<while>while <condition>(<expr>'0' &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt; '8'</expr>)</condition> <block>{
					<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></while>
				<if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>found_decimal</name> = 1</expr>;</expr_stmt>
					<do>do <block>{
						<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block> while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
				}</block></then></if>
				<if>if <condition>(<expr><name>c</name> == '.'</expr>)</condition><then>
					<goto>goto <name>fraction</name>;</goto></then>
				<else>else <if>if <condition>(<expr><name>c</name> == 'e' || <name>c</name> == 'E'</expr>)</condition><then>
					<goto>goto <name>exponent</name>;</goto></then>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITHOUT_COMPLEX</name></cpp:ifndef>
				<else>else <if>if <condition>(<expr><name>c</name> == 'j' || <name>c</name> == 'J'</expr>)</condition><then>
					<goto>goto <name>imaginary</name>;</goto></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<else>else <if>if <condition>(<expr><name>found_decimal</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_TOKEN</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
				}</block></then></if></else></if></else></if></else></if>
			}</block></else></if></else></if></else></if>
			<if>if <condition>(<expr><name>c</name> == 'l' || <name>c</name> == 'L'</expr>)</condition><then>
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then>
		<else>else <block>{
			<comment type="block">/* Decimal */</comment>
			<do>do <block>{
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block> while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
			<if>if <condition>(<expr><name>c</name> == 'l' || <name>c</name> == 'L'</expr>)</condition><then>
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <block>{
				<comment type="block">/* Accept floating point numbers. */</comment>
				<if>if <condition>(<expr><name>c</name> == '.'</expr>)</condition><then> <block>{
		<label><name>fraction</name>:</label>
					<comment type="block">/* Fraction */</comment>
					<do>do <block>{
						<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block> while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
				}</block></then></if>
				<if>if <condition>(<expr><name>c</name> == 'e' || <name>c</name> == 'E'</expr>)</condition><then> <block>{
		<label><name>exponent</name>:</label>
					<comment type="block">/* Exponent part */</comment>
					<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>c</name> == '+' || <name>c</name> == '-'</expr>)</condition><then>
						<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
					<if>if <condition>(<expr>!<call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
						<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_TOKEN</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
					}</block></then></if>
					<do>do <block>{
						<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block> while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
				}</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WITHOUT_COMPLEX</name></cpp:ifndef>
				<if>if <condition>(<expr><name>c</name> == 'j' || <name>c</name> == 'J'</expr>)</condition><then>
					<comment type="block">/* Imaginary part */</comment>
		<label><name>imaginary</name>:</label>
					<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			}</block></else></if>
		}</block></else></if>
		<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p_start</name> = <name><name>tok</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p_end</name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
		<return>return <expr><name>NUMBER</name></expr>;</return>
	}</block></then></if>

  <label><name>letter_quote</name>:</label>
	<comment type="block">/* String */</comment>
	<if>if <condition>(<expr><name>c</name> == '\'' || <name>c</name> == '"'</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>quote2</name> <init>= <expr><name><name>tok</name>-&gt;<name>cur</name></name> - <name><name>tok</name>-&gt;<name>start</name></name> + 1</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>quote</name> <init>= <expr><name>c</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>triple</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>tripcount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
			<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<name>triple</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_EOLS</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
				}</block></then></if>
				<expr_stmt><expr><name>tripcount</name> = 0</expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>tok</name>-&gt;<name>cont_line</name></name> = 1</expr>;</expr_stmt> <comment type="block">/* multiline string. */</comment>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>c</name> == <name>EOF</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>triple</name></expr>)</condition><then>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_EOFS</name></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_EOLS</name></expr>;</expr_stmt></else></if>
				<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name></expr>;</expr_stmt>
				<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>c</name> == <name>quote</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>tripcount</name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>cur</name></name> - <name><name>tok</name>-&gt;<name>start</name></name> == <name>quote2</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>c</name> == <name>quote</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>triple</name> = 1</expr>;</expr_stmt>
						<expr_stmt><expr><name>tripcount</name> = 0</expr>;</expr_stmt>
						<continue>continue;</continue>
					}</block></then></if>
					<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<if>if <condition>(<expr>!<name>triple</name> || <name>tripcount</name> == 3</expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></then>
			<else>else <if>if <condition>(<expr><name>c</name> == '\\'</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>tripcount</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>c</name> == <name>EOF</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_EOLS</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name></expr>;</expr_stmt>
					<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
				}</block></then></if>
			}</block></then>
			<else>else
				<expr_stmt><expr><name>tripcount</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
		}</block></for>
		<expr_stmt><expr>*<name>p_start</name> = <name><name>tok</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p_end</name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
		<return>return <expr><name>STRING</name></expr>;</return>
	}</block></then></if>

	<comment type="block">/* Line continuation */</comment>
	<if>if <condition>(<expr><name>c</name> == '\\'</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>c</name> = <call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c</name> != '\n'</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_LINECONT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tok</name>-&gt;<name>cur</name></name> = <name><name>tok</name>-&gt;<name>inp</name></name></expr>;</expr_stmt>
			<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
		}</block></then></if>
                <expr_stmt><expr><name><name>tok</name>-&gt;<name>cont_line</name></name> = 1</expr>;</expr_stmt>
		<goto>goto <name>again</name>;</goto> <comment type="block">/* Read next line */</comment>
	}</block></then></if>

	<comment type="block">/* Check for two-character token */</comment>
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>c2</name> <init>= <expr><call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>token</name> <init>= <expr><call><name>PyToken_TwoChars</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PGEN</name></cpp:ifndef>
		<if>if <condition>(<expr><name>Py_Py3kWarningFlag</name> &amp;&amp; <name>token</name> == <name>NOTEQUAL</name> &amp;&amp; <name>c</name> == '&lt;'</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>PyErr_WarnExplicit</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
					       <argument><expr>"&lt;&gt; not supported in 3.x; use !="</expr></argument>,
					       <argument><expr><name><name>tok</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>lineno</name></name></expr></argument>,
					       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<return>return <expr><name>ERRORTOKEN</name></expr>;</return>
			}</block></then></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if>if <condition>(<expr><name>token</name> != <name>OP</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>c3</name> <init>= <expr><call><name>tok_nextc</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>token3</name> <init>= <expr><call><name>PyToken_ThreeChars</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>, <argument><expr><name>c3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>token3</name> != <name>OP</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>token</name> = <name>token3</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr>*<name>p_start</name> = <name><name>tok</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p_end</name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
			<return>return <expr><name>token</name></expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>tok_backup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block>

	<comment type="block">/* Keep track of parentheses nesting level */</comment>
	<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
	<case>case <expr>'('</expr>:
	</case><case>case <expr>'['</expr>:
	</case><case>case <expr>'{'</expr>:
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>level</name></name>++</expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr>')'</expr>:
	</case><case>case <expr>']'</expr>:
	</case><case>case <expr>'}'</expr>:
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>level</name></name>--</expr>;</expr_stmt>
		<break>break;</break>
	</case>}</block></switch>

	<comment type="block">/* Punctuation character */</comment>
	<expr_stmt><expr>*<name>p_start</name> = <name><name>tok</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>p_end</name> = <name><name>tok</name>-&gt;<name>cur</name></name></expr>;</expr_stmt>
	<return>return <expr><call><name>PyToken_OneChar</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl></decl_stmt>

<function><type><name>int</name></type>
<name>PyTokenizer_Get</name><parameter_list>(<param><decl><type>struct <name>tok_state</name> *</type><name>tok</name></decl></param>, <param><decl><type><name>char</name> **</type><name>p_start</name></decl></param>, <param><decl><type><name>char</name> **</type><name>p_end</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>tok_get</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>p_start</name></expr></argument>, <argument><expr><name>p_end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>decoding_erred</name></name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>result</name> = <name>ERRORTOKEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tok</name>-&gt;<name>done</name></name> = <name>E_DECODE</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* This function is only called from parsetok. However, it cannot live
   there, as it must be empty for PGEN, and we can check for PGEN only
   in this file. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PGEN</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>char</name>*</type>
<name>PyTokenizer_RestoreEncoding</name><parameter_list>(<param><decl><type>struct <name>tok_state</name>*</type> <name>tok</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name>*</type> <name>offset</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_USING_UNICODE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dec_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode_text</name> <init>= <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>unicode_text</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>ret</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>unicode_text</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>PyTokenizer_RestoreEncoding</name><parameter_list>(<param><decl><type>struct <name>tok_state</name>*</type> <name>tok</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name> *</type><name>offset</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name><name>tok</name>-&gt;<name>encoding</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* convert source to original encondig */</comment>
		<decl_stmt><decl><type><name>PyObject</name> *</type><name>lineobj</name> <init>= <expr><call><name>dec_utf8</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>encoding</name></name></expr></argument>, <argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>lineobj</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>linelen</name> <init>= <expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>lineobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>line</name> <init>= <expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>lineobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>text</name> = <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>linelen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>text</name> != <name>NULL</name> &amp;&amp; <name>line</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>linelen</name></expr>)</condition><then>
					<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>linelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name><name>text</name><index>[<expr><name>linelen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>lineobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
			<comment type="block">/* adjust error offset */</comment>
			<if>if <condition>(<expr>*<name>offset</name> &gt; 1</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>PyObject</name> *</type><name>offsetobj</name> <init>= <expr><call><name>dec_utf8</name><argument_list>(<argument><expr><name><name>tok</name>-&gt;<name>encoding</name></name></expr></argument>, 
							       <argument><expr><name><name>tok</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr>*<name>offset</name>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>offsetobj</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>offset</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr><name>offsetobj</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>offsetobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></then></if>
			
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>text</name></expr>;</return>

}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(Py_USING_UNICODE) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Py_DEBUG</name></cpp:ifdef>

<function><type><name>void</name></type>
<name>tok_dump</name><parameter_list>(<param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>char</name> *</type><name>start</name></decl></param>, <param><decl><type><name>char</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s"</expr></argument>, <argument><expr><name><name>_PyParser_TokenNames</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>type</name> == <name>NAME</name> || <name>type</name> == <name>NUMBER</name> || <name>type</name> == <name>STRING</name> || <name>type</name> == <name>OP</name></expr>)</condition><then>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"(%.*s)"</expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>end</name> - <name>start</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
