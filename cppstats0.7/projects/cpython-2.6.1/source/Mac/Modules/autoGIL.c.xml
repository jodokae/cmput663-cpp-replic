<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Mac/Modules/autoGIL.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;CoreFoundation/CFRunLoop.h&gt;</cpp:file></cpp:include>

<comment type="block">/* These macros are defined in Python 2.3 but not 2.2 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyMODINIT_FUNC</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyMODINIT_FUNC</name></cpp:macro> <cpp:value>void</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PyDoc_STRVAR</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyDoc_STRVAR</name><parameter_list>(<param><type><name>Var</name></type></param>,<param><type><name>Str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static char Var[] = Str</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>AUTOGIL_DEBUG</name></cpp:undef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>AutoGILError</name></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>void</name></type> <name>autoGILCallback</name><parameter_list>(<param><decl><type><name>CFRunLoopObserverRef</name></type> <name>observer</name></decl></param>,
			    <param><decl><type><name>CFRunLoopActivity</name></type> <name>activity</name></decl></param>,
			    <param><decl><type><name>void</name> *</type><name>info</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>PyThreadState</name> **</type><name>p_tstate</name> <init>= <expr>(<name>PyThreadState</name> **)<name>info</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>activity</name></expr>)</condition> <block>{
	<case>case <expr><name>kCFRunLoopBeforeWaiting</name></expr>:
		<comment type="block">/* going to sleep, release GIL */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOGIL_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"going to sleep, release GIL\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr>*<name>p_tstate</name> = <call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</case><case>case <expr><name>kCFRunLoopAfterWaiting</name></expr>:
		<comment type="block">/* waking up, acquire GIL */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOGIL_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"waking up, acquire GIL\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr>*<name>p_tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p_tstate</name> = <name>NULL</name></expr>;</expr_stmt>
		<break>break;</break>
	</case><default>default:
		<break>break;</break>
	</default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>infoRelease</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>info</name></decl></param>)</parameter_list> <block>{
	<comment type="block">/* XXX This should get called when the run loop is deallocated,
	   but this doesn't seem to happen. So for now: leak. */</comment>
	<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr>(<name>void</name> *)<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>autoGIL_installAutoGIL</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>tstate_dict</name> <init>= <expr><call><name>PyThreadState_GetDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFRunLoopRef</name></type> <name>rl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyThreadState</name> **</type><name>p_tstate</name></decl>;</decl_stmt>  <comment type="block">/* for use in the info field */</comment>
	<decl_stmt><decl><type><name>CFRunLoopObserverContext</name></type> <name>context</name> <init>= <expr><block>{<expr>0</expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFRunLoopObserverRef</name></type> <name>observer</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>tstate_dict</name> == <name>NULL</name></expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>
	<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>tstate_dict</name></expr></argument>, <argument><expr>"autoGIL.InstalledAutoGIL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
		<comment type="block">/* we've already installed a callback for this thread */</comment>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>Py_None</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>rl</name> = <call><name>CFRunLoopGetCurrent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rl</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AutoGILError</name></expr></argument>,
				<argument><expr>"can't get run loop for current thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>

	<expr_stmt><expr><name>p_tstate</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyThreadState</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>p_tstate</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>,
				<argument><expr>"not enough memory to allocate "
				"tstate pointer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr>*<name>p_tstate</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name>.<name>info</name></name> = (<name>void</name> *)<name>p_tstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name>.<name>release</name></name> = <name>infoRelease</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>observer</name> = <call><name>CFRunLoopObserverCreate</name><argument_list>(
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><name>kCFRunLoopBeforeWaiting</name> | <name>kCFRunLoopAfterWaiting</name></expr></argument>,
		<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>autoGILCallback</name></expr></argument>, <argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>observer</name> == <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>AutoGILError</name></expr></argument>,
				<argument><expr>"can't create event loop observer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>CFRunLoopAddObserver</name><argument_list>(<argument><expr><name>rl</name></expr></argument>, <argument><expr><name>observer</name></expr></argument>, <argument><expr><name>kCFRunLoopDefaultMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* XXX how to check for errors? */</comment>

	<comment type="block">/* register that we have installed a callback for this thread */</comment>
	<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>tstate_dict</name></expr></argument>, <argument><expr>"autoGIL.InstalledAutoGIL"</expr></argument>,
				 <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return <expr><name>NULL</name></expr>;</return></then></if>

	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>autoGIL_installAutoGIL_doc</name></expr></argument>,
<argument><expr>"installAutoGIL() -&gt; None\n\
Install an observer callback in the event loop (CFRunLoop) for the\n\
current thread, that will lock and unlock the Global Interpreter Lock\n\
(GIL) at appropriate times, allowing other Python threads to run while\n\
the event loop is idle."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>autoGIL_methods</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{
		<expr>"installAutoGIL"</expr>,
		<expr>(<name>PyCFunction</name>)<name>autoGIL_installAutoGIL</name></expr>,
		<expr><name>METH_NOARGS</name></expr>,
		<expr><name>autoGIL_installAutoGIL_doc</name></expr>
	}</block></expr>,
	<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr> <comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>autoGIL_docs</name></expr></argument>,
<argument><expr>"The autoGIL module provides a function (installAutoGIL) that\n\
automatically locks and unlocks Python's Global Interpreter Lock\n\
when running an event loop."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>

<function><type><name>PyMODINIT_FUNC</name></type>
<name>initautoGIL</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"In 3.x, the autoGIL module is removed."</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name>mod</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"autoGIL"</expr></argument>, <argument><expr><name>autoGIL_methods</name></expr></argument>, <argument><expr><name>autoGIL_docs</name></expr></argument>,
			     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><name>AutoGILError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"autoGIL.AutoGILError"</expr></argument>,
					  <argument><expr><name>PyExc_Exception</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>AutoGILError</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>
	<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>AutoGILError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"AutoGILError"</expr></argument>,
			       <argument><expr><name>AutoGILError</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
		<return>return;</return></then></if>
}</block></function>
</unit>
