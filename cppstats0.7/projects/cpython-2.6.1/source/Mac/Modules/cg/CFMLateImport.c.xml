<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/cpython-2.6.1/source/Mac/Modules/cg/CFMLateImport.c"><comment type="block">/*
	File:		CFMLateImport.c

	Contains:	Implementation of CFM late import library.

	Written by:	Quinn

	Copyright:	Copyright © 1999 by Apple Computer, Inc., all rights reserved.

				You may incorporate this Apple sample source code into your program(s) without
				restriction. This Apple sample source code has been provided "AS IS" and the
				responsibility for its operation is yours. You are not permitted to redistribute
				this Apple sample source code as "Apple sample source code" after having made
				changes. If you're going to re-distribute the source, we require that you make
				it clear in the source that the code was descended from Apple sample source
				code, but that you've made changes.

	Change History (most recent first):

        &lt;13&gt;     24/9/01    Quinn   Fixes to compile with C++ activated.
        &lt;12&gt;     21/9/01    Quinn   [2710489] Fix typo in the comments for FragmentLookup.
        &lt;11&gt;     21/9/01    Quinn   Changes for CWPro7 Mach-O build.
        &lt;10&gt;     19/9/01    Quinn   Corrected implementation of kPEFRelocSmBySection. Added
                                    implementations of kPEFRelocSetPosition and kPEFRelocLgByImport
                                    (from code contributed by Eric Grant, Ned Holbrook, and Steve
                                    Kalkwarf), although I can't test them yet.
         &lt;9&gt;     19/9/01    Quinn   We now handle unpacked data sections, courtesy of some code from
                                    Ned Holbrook.
         &lt;8&gt;     19/9/01    Quinn   Minor fixes for the previous checkin. Updated some comments and
                                    killed some dead code.
         &lt;7&gt;     19/9/01    Quinn   Simplified API and implementation after a suggestion by Eric
                                    Grant. You no longer have to CFM export a dummy function; you
                                    can just pass in the address of your fragment's init routine.
         &lt;6&gt;     15/2/01    Quinn   Modify compile-time warnings to complain if you try to build
                                    this module into a Mach-O binary.
         &lt;5&gt;      5/2/01    Quinn   Removed redundant assignment in CFMLateImportCore.
         &lt;4&gt;    30/11/00    Quinn   Added comment about future of data symbols in CF.
         &lt;3&gt;    16/11/00    Quinn   Allow symbol finding via a callback and use that to implement
                                    CFBundle support.
         &lt;2&gt;    18/10/99    Quinn   Renamed CFMLateImport to CFMLateImportLibrary to allow for
                                    possible future API expansion.
         &lt;1&gt;     15/6/99    Quinn   First checked in.
*/</comment>

<comment type="line">// To Do List:</comment>
<comment type="line">//</comment>
<comment type="line">// o get rid of dependence on ANSI "string.h", but how?</comment>
<comment type="line">//</comment>
<comment type="line">// Done:</comment>
<comment type="line">//</comment>
<comment type="line">// Ã investigate alternative APIs, like an external lookup routine</comment>
<comment type="line">//   renamed CFMLateImport to CFMLateImportLibrary to allow for</comment>
<comment type="line">//   future expansion of the APIs for things like CFMLateImportSymbol</comment>
<comment type="line">// Ã test with non-zero fragment offset in the file</comment>
<comment type="line">// Ã test more with MPW fragments</comment>
<comment type="line">// Ã test data imports</comment>

<comment type="line">/////////////////////////////////////////////////////////////////</comment>

<comment type="line">// MoreIsBetter Setup</comment>

<comment type="line">//#include "MoreSetup.h"</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MoreAssert</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(true)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MoreAssertQ</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>

<comment type="line">// Mac OS Interfaces</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>! <name>MORE_FRAMEWORK_INCLUDES</name></expr></cpp:if>
	<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;CodeFragments.h&gt;</cpp:file></cpp:include>
	<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;PEFBinaryFormat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Standard C Interfaces</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="line">// MIB Prototypes</comment>

<comment type="line">//#include "MoreInterfaceLib.h"</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MoreBlockZero</name></cpp:macro> <cpp:value>BlockZero</cpp:value></cpp:define>

<comment type="line">// Our Prototypes</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CFMLateImport.h"</cpp:file></cpp:include>

<comment type="line">/////////////////////////////////////////////////////////////////</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TARGET_RT_MAC_MACHO</name></expr></cpp:if>
	<cpp:error>#<cpp:directive>error</cpp:directive> CFMLateImport is not suitable for use in a Mach-O project.</cpp:error>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>!<name>TARGET_RT_MAC_CFM</name> || !<name>TARGET_CPU_PPC</name></expr></cpp:elif>
	<cpp:error>#<cpp:directive>error</cpp:directive> CFMLateImport has not been qualified for 68K or CFM-68K use.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">/////////////////////////////////////////////////////////////////</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> mark ----- Utility Routines -----</cpp:pragma>

<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>FSReadAtOffset</name><parameter_list>(<param><decl><type><name>SInt16</name></type> <name>refNum</name></decl></param>, <param><decl><type><name>SInt32</name></type> <name>offset</name></decl></param>, <param><decl><type><name>SInt32</name></type> <name>count</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buffer</name></decl></param>)</parameter_list>
	<comment type="line">// A convenient wrapper around PBRead which has two advantages</comment>
	<comment type="line">// over FSRead.  First, it takes count as a value parameter.</comment>
	<comment type="line">// Second, it reads from an arbitrary offset into the file,</comment>
	<comment type="line">// which avoids a bunch of SetFPos calls.</comment>
	<comment type="line">//</comment>
	<comment type="line">// I guess this should go into "MoreFiles.h", but I'm not sure</comment>
	<comment type="line">// how we're going to integrate such a concept into MIB yet.</comment>
<block>{
	<decl_stmt><decl><type><name>ParamBlockRec</name></type> <name>pb</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioRefNum</name></name>     = <name>refNum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioBuffer</name></name>     = (<name>Ptr</name>) <name>buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioReqCount</name></name>   = <name>count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioPosMode</name></name>    = <name>fsFromStart</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pb</name>.<name>ioParam</name>.<name>ioPosOffset</name></name>  = <name>offset</name></expr>;</expr_stmt>
	
	<return>return <expr><call><name>PBReadSync</name><argument_list>(<argument><expr>&amp;<name>pb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">/////////////////////////////////////////////////////////////////</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> mark ----- Late Import Engine -----</cpp:pragma>

<comment type="line">// This structure represents the core data structure of the late import</comment>
<comment type="line">// engine.  It basically holds information about the fragment we're going</comment>
<comment type="line">// to fix up.  It starts off with the first three fields, which are</comment>
<comment type="line">// provided by the client.  Then, as we procede through the operation,</comment>
<comment type="line">// we fill out more fields.</comment>

<struct>struct <name>FragToFixInfo</name> <block>{
	<decl_stmt><decl><type><name>CFragSystem7DiskFlatLocator</name></type>	<name>locator</name></decl>;</decl_stmt>				<comment type="line">// How to find the fragment's container.</comment>
	<decl_stmt><decl><type><name>CFragConnectionID</name></type> 			<name>connID</name></decl>;</decl_stmt>					<comment type="line">// CFM connection to the fragment.</comment>
	<decl_stmt><decl><type><name>CFragInitFunction</name></type> 			<name>initRoutine</name></decl>;</decl_stmt>			<comment type="line">// The CFM init routine for the fragment.</comment>
	<decl_stmt><decl><type><name>PEFContainerHeader</name></type> 			<name>containerHeader</name></decl>;</decl_stmt>		<comment type="line">// The CFM header, read in from the container.</comment>
	<decl_stmt><decl><type><name>PEFSectionHeader</name>			*</type><name>sectionHeaders</name></decl>;</decl_stmt>		<comment type="line">// The CFM section headers.  A pointer block containing an array of containerHeader.sectionCount elements.</comment>
	<decl_stmt><decl><type><name>PEFLoaderInfoHeader</name>			*</type><name>loaderSection</name></decl>;</decl_stmt>			<comment type="line">// The entire CFM loader section in a pointer block.</comment>
	<decl_stmt><decl><type><name>SInt16</name></type>						<name>fileRef</name></decl>;</decl_stmt>				<comment type="line">// A read-only path to the CFM container.  We keep this here because one that one routine needs to read from the container.</comment>
	<decl_stmt><decl><type><name>void</name> 						*</type><name>section0Base</name></decl>;</decl_stmt>			<comment type="line">// The base address of section 0, which we go through hoops to calculate.</comment>
	<decl_stmt><decl><type><name>void</name> 						*</type><name>section1Base</name></decl>;</decl_stmt>			<comment type="line">// The base address of section 1, which we go through hoops to calculate.</comment>
	<decl_stmt><decl><type><name>Boolean</name></type>						<name>disposeSectionPointers</name></decl>;</decl_stmt>	<comment type="line">// See below.</comment>
}</block>;</struct>
<typedef>typedef <type>struct <name>FragToFixInfo</name></type> <name>FragToFixInfo</name>;</typedef>

<comment type="line">// The disposeSectionPointers Boolean is designed for future cool VM</comment>
<comment type="line">// support.  If VM is on, the entire code fragment is file mapped into</comment>
<comment type="line">// high memory, including the data we're forced to allocate the</comment>
<comment type="line">// sectionHeaders and loaderSection memory blocks to maintain.  If</comment>
<comment type="line">// we could find the address of the entire file mapped container,</comment>
<comment type="line">// we could access the information directly from there and thus</comment>
<comment type="line">// we wouldn't need to allocate (or dispose of) the memory blocks</comment>
<comment type="line">// for sectionHeaders and loaderSection.</comment>
<comment type="line">//</comment>
<comment type="line">// I haven't implemented this yet because a) I'm not sure how to do</comment>
<comment type="line">// it with documented APIs, and b) I couldn't be bothered, but</comment>
<comment type="line">// disposeSectionPointers remains as vestigial support for the concept.</comment>

<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>ReadContainerBasics</name><parameter_list>(<param><decl><type><name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>)</parameter_list>
	<comment type="line">// Reads some basic information from the container of the</comment>
	<comment type="line">// fragment to fix and stores it in various fields of</comment>
	<comment type="line">// fragToFix.  This includes:</comment>
	<comment type="line">//</comment>
	<comment type="line">// o containerHeader -- The contain header itself.</comment>
	<comment type="line">// o sectionHeaders  -- The array of section headers (in a newly allocated pointer block).</comment>
	<comment type="line">// o loaderSection   -- The entire loader section (in a newly allocated pointer block).</comment>
	<comment type="line">//</comment>
	<comment type="line">// Also sets disposeSectionPointers to indicate whether</comment>
	<comment type="line">// the last two pointers should be disposed of.</comment>
	<comment type="line">//</comment>
	<comment type="line">// Finally, it leaves the container file open for later</comment>
	<comment type="line">// folks who want to read data from it.</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> 	<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt16</name></type> 		<name>sectionIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Boolean</name></type> 	<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFix</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>fileSpec</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>connID</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name> == <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name></name> == <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>disposeSectionPointers</name></name> = <name>true</name></expr>;</expr_stmt>
	
	<comment type="line">// Open up the file, read the container head, then read in</comment>
	<comment type="line">// all the section headers, then go looking through the</comment>
	<comment type="line">// section headers for the loader section (PEF defines</comment>
	<comment type="line">// that there can be only one).</comment>
	
	<expr_stmt><expr><name>err</name> = <call><name>FSpOpenDF</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>fileSpec</name></name></expr></argument>, <argument><expr><name>fsRdPerm</name></expr></argument>, <argument><expr>&amp;<name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>,
								<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name></expr></argument>,
								<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
								<argument><expr>&amp;<name><name>fragToFix</name>-&gt;<name>containerHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
			<if>if <condition>(   <expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>tag1</name></name> != <name>kPEFTag1</name>
				|| <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>tag2</name></name> != <name>kPEFTag2</name>
				|| <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>architecture</name></name> != <name>kCompiledCFragArch</name>
				|| <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>formatVersion</name></name> != <name>kPEFVersion</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>err</name> = <name>cfragFragmentFormatErr</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name></name> = (<name>PEFSectionHeader</name> *) <call><name>NewPtr</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>sectionCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PEFSectionHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>MemError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>,
									<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>sectionCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PEFSectionHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
									<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>sectionIndex</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> = <name>false</name></expr>;</expr_stmt>
			<while>while <condition>( <expr><name>sectionIndex</name> &lt; <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>sectionCount</name></name> &amp;&amp; ! <name>found</name></expr> )</condition> <block>{
				<expr_stmt><expr><name>found</name> = (<name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>sectionIndex</name></expr>]</index></name>.<name>sectionKind</name> == <name>kPEFLoaderSection</name>)</expr>;</expr_stmt>
				<if>if <condition>( <expr>! <name>found</name></expr> )</condition><then> <block>{
					<expr_stmt><expr><name>sectionIndex</name> += 1</expr>;</expr_stmt>
				}</block></then></if>
			}</block></while>
		}</block></then></if>
		<if>if <condition>(<expr><name>err</name> == <name>noErr</name> &amp;&amp; ! <name>found</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err</name> = <name>cfragNoSectionErr</name></expr>;</expr_stmt>
		}</block></then></if>
		
		<comment type="line">// Now read allocate a pointer block and read the loader section into it.</comment>
		
		<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name> = (<name>PEFLoaderInfoHeader</name> *) <call><name>NewPtr</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>sectionIndex</name></expr>]</index></name>.<name>containerLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>MemError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>, 
									<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name> + <name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>sectionIndex</name></expr>]</index></name>.<name>containerOffset</name></expr></argument>,
									<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>sectionIndex</name></expr>]</index></name>.<name>containerLength</name></expr></argument>, 
									<argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>				
	}</block></then></if>
	
	<comment type="line">// No clean up.  The client must init fragToFix to zeros and then</comment>
	<comment type="line">// clean up regardless of whether we return an error.</comment>
		
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>UInt32</name></type> <name>DecodeVCountValue</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>start</name></decl></param>, <param><decl><type><name>UInt32</name> *</type><name>outCount</name></decl></param>)</parameter_list>
	<comment type="line">// Given a pointer to the start of a variable length PEF value, </comment>
	<comment type="line">// work out the value (in *outCount).  Returns the number of bytes </comment>
	<comment type="line">// consumed by the value.</comment>
<block>{
	<decl_stmt><decl><type><name>UInt8</name> *</type>			<name>bytePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt8</name></type>			<name>byte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt32</name></type>			<name>count</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>bytePtr</name> = (<name>UInt8</name> *)<name>start</name></expr>;</expr_stmt>
	
	<comment type="line">// Code taken from "PEFBinaryFormat.h".</comment>
	<expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
	<do>do <block>{
		<expr_stmt><expr><name>byte</name> = *<name>bytePtr</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name> = (<name>count</name> &lt;&lt; <name>kPEFPkDataVCountShift</name>) | (<name>byte</name> &amp; <name>kPEFPkDataVCountMask</name>)</expr>;</expr_stmt>
	}</block> while <condition>(<expr>(<name>byte</name> &amp; <name>kPEFPkDataVCountEndMask</name>) != 0</expr>)</condition>;</do>
	
	<expr_stmt><expr>*<name>outCount</name> = <name>count</name></expr>;</expr_stmt>
	<return>return <expr><name>bytePtr</name> - <name>start</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>UInt32</name></type> <name>DecodeInstrCountValue</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>inOpStart</name></decl></param>, <param><decl><type><name>UInt32</name> *</type><name>outCount</name></decl></param>)</parameter_list>
	<comment type="line">// Given a pointer to the start of an opcode (inOpStart), work out the </comment>
	<comment type="line">// count argument for that opcode (*outCount).  Returns the number of </comment>
	<comment type="line">// bytes consumed by the opcode and count combination.</comment>
<block>{
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>inOpStart</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>outCount</name>  != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if>if <condition>(<expr><call><name>PEFPkDataCount5</name><argument_list>(<argument><expr>*<name>inOpStart</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
	<block>{
		<comment type="line">// Simple case, count encoded in opcode.</comment>
		<expr_stmt><expr>*<name>outCount</name> = <call><name>PEFPkDataCount5</name><argument_list>(<argument><expr>*<name>inOpStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>1</expr>;</return>
	}</block></then>
	<else>else
	<block>{
		<comment type="line">// Variable-length case.</comment>
		<return>return <expr>1 + <call><name>DecodeVCountValue</name><argument_list>(<argument><expr><name>inOpStart</name> + 1</expr></argument>, <argument><expr><name>outCount</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>UnpackPEFDataSection</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>UInt8</name> * <specifier>const</specifier></type> <name>packedData</name></decl></param>,   <param><decl><type><name>UInt32</name></type> <name>packedSize</name></decl></param>,
								           <param><decl><type><name>UInt8</name> * <specifier>const</specifier></type> <name>unpackedData</name></decl></param>, <param><decl><type><name>UInt32</name></type> <name>unpackedSize</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>OSErr</name></type>			<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt32</name></type>			<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt8</name></type>			<name>opCode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt8</name> *</type>			<name>unpackCursor</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>packedData</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>unpackedData</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>unpackedSize</name> &gt;= <name>packedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// The following asserts assume that the client allocated the memory with NewPtr, </comment>
	<comment type="line">// which may not always be true.  However, the asserts' value in preventing accidental </comment>
	<comment type="line">// memory block overruns outweighs the possible maintenance effort.</comment>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name>packedSize</name>   == <call><name>GetPtrSize</name><argument_list>( <argument><expr>(<name>Ptr</name>) <name>packedData</name></expr></argument>  )</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name>unpackedSize</name> == <call><name>GetPtrSize</name><argument_list>( <argument><expr>(<name>Ptr</name>) <name>unpackedData</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>err</name>          = <name>noErr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name>       = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>unpackCursor</name> = <name>unpackedData</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>offset</name> &lt; <name>packedSize</name></expr>)</condition> <block>{
		<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>unpackCursor</name> &lt; &amp;<name><name>unpackedData</name><index>[<expr><name>unpackedSize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>opCode</name> = <name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
		
		<switch>switch <condition>(<expr><call><name>PEFPkDataOpcode</name><argument_list>(<argument><expr><name>opCode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<case>case <expr><name>kPEFPkDataZero</name></expr>:
				<block>{
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>count</name></decl>;</decl_stmt>
					
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
					<expr_stmt><expr><call><name>MoreBlockZero</name><argument_list>(<argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>unpackCursor</name> += <name>count</name></expr>;</expr_stmt>
				}</block>
				<break>break;</break>
			
			</case><case>case <expr><name>kPEFPkDataBlock</name></expr>:
				<block>{
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>blockSize</name></decl>;</decl_stmt>
					
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
					<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>unpackCursor</name> += <name>blockSize</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> += <name>blockSize</name></expr>;</expr_stmt>
				}</block>
				<break>break;</break>
			
			</case><case>case <expr><name>kPEFPkDataRepeat</name></expr>:
				<block>{
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>blockSize</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>repeatCount</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UInt32</name></type>  <name>loopCounter</name></decl>;</decl_stmt>
					
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>repeatCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>repeatCount</name> += 1</expr>;</expr_stmt>	<comment type="line">// stored value is (repeatCount - 1)</comment>
					
					<for>for (<init><expr><name>loopCounter</name> = 0</expr>;</init> <condition><expr><name>loopCounter</name> &lt; <name>repeatCount</name></expr>;</condition> <incr><expr><name>loopCounter</name>++</expr></incr>) <block>{
						<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>unpackCursor</name> += <name>blockSize</name></expr>;</expr_stmt>
					}</block></for>
					<expr_stmt><expr><name>offset</name> += <name>blockSize</name></expr>;</expr_stmt>
				}</block>
				<break>break;</break>
			
			</case><case>case <expr><name>kPEFPkDataRepeatBlock</name></expr>:
				<block>{
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>commonSize</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>customSize</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>repeatCount</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>commonData</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>customData</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UInt32</name></type> <name>loopCounter</name></decl>;</decl_stmt>
					
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>customSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>repeatCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
					<expr_stmt><expr><name>commonData</name> = &amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>customData</name> = &amp;<name><name>packedData</name><index>[<expr><name>offset</name> + <name>commonSize</name></expr>]</index></name></expr>;</expr_stmt>
					
					<for>for (<init><expr><name>loopCounter</name> = 0</expr>;</init> <condition><expr><name>loopCounter</name> &lt; <name>repeatCount</name></expr>;</condition> <incr><expr><name>loopCounter</name>++</expr></incr>) <block>{
						<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>commonData</name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>unpackCursor</name> += <name>commonSize</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>customData</name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>customSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>unpackCursor</name> += <name>customSize</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>customData</name> += <name>customSize</name></expr>;</expr_stmt>
					}</block></for>
					<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>commonData</name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>unpackCursor</name> += <name>commonSize</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> += (<call><name>repeatCount</name> * <argument_list>(<argument><expr><name>commonSize</name> + <name>customSize</name></expr></argument>)</argument_list></call>) + <name>commonSize</name></expr>;</expr_stmt>
				}</block>
				<break>break;</break>
			
			</case><case>case <expr><name>kPEFPkDataRepeatZero</name></expr>:
				<block>{
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>commonSize</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>customSize</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UInt32</name></type>	<name>repeatCount</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>UInt8</name> *</type><name>customData</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UInt32</name></type> <name>loopCounter</name></decl>;</decl_stmt>
					
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeInstrCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>customSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> += <call><name>DecodeVCountValue</name><argument_list>(<argument><expr>&amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>repeatCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
					<expr_stmt><expr><name>customData</name> = &amp;<name><name>packedData</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
					
					<for>for (<init><expr><name>loopCounter</name> = 0</expr>;</init> <condition><expr><name>loopCounter</name> &lt; <name>repeatCount</name></expr>;</condition> <incr><expr><name>loopCounter</name>++</expr></incr>) <block>{
						<expr_stmt><expr><call><name>MoreBlockZero</name><argument_list>(<argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>unpackCursor</name> += <name>commonSize</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>customData</name></expr></argument>, <argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>customSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>unpackCursor</name> += <name>customSize</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>customData</name> += <name>customSize</name></expr>;</expr_stmt>
					}</block></for>
					<expr_stmt><expr><call><name>MoreBlockZero</name><argument_list>(<argument><expr><name>unpackCursor</name></expr></argument>, <argument><expr><name>commonSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>unpackCursor</name> += <name>commonSize</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> += <name>repeatCount</name> * <name>customSize</name></expr>;</expr_stmt>
				}</block>
				<break>break;</break>
			
			</case><default>default:
				<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
					<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pUnpackPEFDataSection: Unexpected data opcode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>err</name> = <name>cfragFragmentCorruptErr</name></expr>;</expr_stmt>
				<goto>goto <name>leaveNow</name>;</goto>
				<break>break;</break>
		</default>}</block></switch>
	}</block></while>
	
<label><name>leaveNow</name>:</label>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/*	SetupSectionBaseAddresses Rationale
	-----------------------------------
	
	OK, here's where things get weird.  In order to run the relocation
	engine, I need to be able to find the base address of an instantiated
	section of the fragment we're fixing up given only its section number.
	This isn't hard for CFM to do because it's the one that instantiated the
	sections in the first place.  It's surprisingly difficult to do if
	you're not CFM.  [And you don't have access to the private CFM APis for 
	doing it.]
	
	[Alan Lillich is going to kill me when he reads this!  I should point out
	 that TVector's don't have to contain two words, they can be longer,
	 and that the second word isn't necessarily a TOC pointer, it's
	 just that the calling conventions require that it be put in the
	 TOC register when the code is called.
	 
	 Furthermore, the code section isn't always section 0, and the data
	 section isn't always section 1, and there can be zero to many sections
	 of each type.
	 
	 But these niceties are besides the point: I'm doing something tricky 
	 because I don't have a nice API for getting section base addresses.  
	 If I had a nice API for doing that, none of this code would exist.
	]

	The technique is very sneaky (thanks to Eric Grant).  The fragment to 
	fix necessarily has a CFM init routine (because it needs that routine 
	in order to capture the fragment location and connection ID).  Thus the 
	fragment to fix must have a TVector in its data section.  TVectors are 
	interesting because they're made up of two words.  The first is a pointer 
	to the code that implements the routine; the second is a pointer to the TOC
	for the fragment that's exporting the TVector.  How TVectors are
	created is interesting too.  On disk, a TVector consists of two words,
	the first being the offset from the start of the code section to the
	routine, the second being the offset from the start of the data section
	to the TOC base.  When CFM prepares a TVector, it applies the following
	transform:
	
		tvector.codePtr = tvector.codeOffset + base of code section
		tvector.tocPtr  = tvector.tocOffset  + base of data section
		
	Now, you can reverse these questions to make them:
	
		base of code section = tvector.codePtr - tvector.codeOffset
		base of data section = tvector.dataPtr - tvector.dataOffset
	
	So if you can find the relocated contents of the TVector and
	find the original offsets that made up the TVector, you can then
	calculate the base address of both the code and data sections.
	
	Finding the relocated contents of the TVector is easy; I simply 
	require the client to pass in a pointer to its init routine. 
	A routine pointer is a TVector pointer, so you can just cast it 
	and extract the pair of words.

	Finding the original offsets is a trickier.  My technique is to
	look up the init routine in the fragment's loader info header.  This
	yields the section number and offset where the init routine's unrelocated 
	TVector exists.  Once I have that, I can just read the unrelocated TVector
	out of the file and extract the offsets.
*/</comment>

<struct>struct <name>TVector</name> <block>{
	<decl_stmt><decl><type><name>void</name> *</type><name>codePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> *</type><name>tocPtr</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type>struct <name>TVector</name></type> <name>TVector</name>;</typedef>

<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>SetupSectionBaseAddresses</name><parameter_list>(<param><decl><type><name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>)</parameter_list>
	<comment type="line">// This routine initialises the section0Base and section1Base</comment>
	<comment type="line">// base fields of fragToFix to the base addresses of the</comment>
	<comment type="line">// instantiated fragment represented by the other fields</comment>
	<comment type="line">// of fragToFix.  The process works in three states:</comment>
	<comment type="line">//</comment>
	<comment type="line">// 1. 	Find the contents of the relocated TVector of the </comment>
	<comment type="line">//      fragment's initialisation routine, provided to us by </comment>
	<comment type="line">//      the caller.</comment>
	<comment type="line">//</comment>
	<comment type="line">// 2.	Find the contents of the non-relocated TVector by </comment>
	<comment type="line">//      looking it up in the PEF loader info header and then </comment>
	<comment type="line">//      using that to read the TVector contents from disk.</comment>
	<comment type="line">//      This yields the offsets from the section bases for </comment>
	<comment type="line">//      the init routine.</comment>
	<comment type="line">//</comment>
	<comment type="line">// 3.	Subtract 2 from 3.</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> 			<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TVector</name> *</type>			<name>relocatedExport</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SInt32</name></type>				<name>initSection</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt32</name></type>				<name>initOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PEFSectionHeader</name> *</type>	<name>initSectionHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Ptr</name></type>					<name>packedDataSection</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Ptr</name></type>					<name>unpackedDataSection</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TVector</name></type> 			<name>originalOffsets</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>packedDataSection</name>   = <name>nil</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>unpackedDataSection</name> = <name>nil</name></expr>;</expr_stmt>
	
	<comment type="line">// Step 1.</comment>

	<comment type="line">// First find the init routine's TVector, which gives us the relocated </comment>
	<comment type="line">// offsets of the init routine into the data and code sections.</comment>

	<expr_stmt><expr><name>relocatedExport</name> = (<name>TVector</name> *) <name><name>fragToFix</name>-&gt;<name>initRoutine</name></name></expr>;</expr_stmt>
		
	<comment type="line">// Step 2.</comment>
	
	<comment type="line">// Now find the init routine's TVector's offsets in the data section on </comment>
	<comment type="line">// disk.  This gives us the raw offsets from the data and code section </comment>
	<comment type="line">// of the beginning of the init routine.</comment>
	
	<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>initSection</name> = <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>initSection</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>initOffset</name>  = <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>initOffset</name></name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>initSection</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err</name> = <name>cfragFragmentUsageErr</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name>initSection</name> &gt;= 0</expr></argument> )</argument_list></call></expr>;</expr_stmt>		<comment type="line">// Negative indexes are pseudo-sections which are just not allowed!</comment>
		<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name>initSection</name> &lt; <name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>sectionCount</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>initSectionHeader</name> = &amp;<name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>initSection</name></expr>]</index></name></expr>;</expr_stmt>
		
		<comment type="line">// If the data section is packed, unpack it to a temporary buffer and then get the </comment>
		<comment type="line">// original offsets from that buffer.  If the data section is unpacked, just read </comment>
		<comment type="line">// the original offsets directly off the disk.</comment>
		
		<if>if <condition>( <expr><name><name>initSectionHeader</name>-&gt;<name>sectionKind</name></name> == <name>kPEFPackedDataSection</name></expr> )</condition><then> <block>{

			<comment type="line">// Allocate space for packed and unpacked copies of the section.</comment>
			
			<expr_stmt><expr><name>packedDataSection</name> = <call><name>NewPtr</name><argument_list>(<argument><expr><name><name>initSectionHeader</name>-&gt;<name>containerLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>MemError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>unpackedDataSection</name> = <call><name>NewPtr</name><argument_list>(<argument><expr><name><name>initSectionHeader</name>-&gt;<name>unpackedLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>err</name> = <call><name>MemError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>

			<comment type="line">// Read the contents of the packed section.</comment>
			
			<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(	<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>,
										<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name>
										+ <name><name>initSectionHeader</name>-&gt;<name>containerOffset</name></name></expr></argument>,
										<argument><expr><name><name>initSectionHeader</name>-&gt;<name>containerLength</name></name></expr></argument>,
										<argument><expr><name>packedDataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			
			<comment type="line">// Unpack the data into the unpacked section.</comment>
			
			<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>err</name> = <call><name>UnpackPEFDataSection</name><argument_list>( <argument><expr>(<name>UInt8</name> *) <name>packedDataSection</name></expr></argument>,   <argument><expr><name><name>initSectionHeader</name>-&gt;<name>containerLength</name></name></expr></argument>,
								            <argument><expr>(<name>UInt8</name> *) <name>unpackedDataSection</name></expr></argument>, <argument><expr><name><name>initSectionHeader</name>-&gt;<name>unpackedLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			
			<comment type="line">// Extract the init routine's TVector from the unpacked section.</comment>
			
			<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>unpackedDataSection</name> + <name>initOffset</name></expr></argument>, <argument><expr>&amp;<name>originalOffsets</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TVector</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>initSection</name></expr>]</index></name>.<name>sectionKind</name> == <name>kPEFUnpackedDataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <call><name>FSReadAtOffset</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>fileRef</name></name></expr></argument>, 
									<argument><expr><name><name>fragToFix</name>-&gt;<name>locator</name>.<name>offset</name></name>
									+ <name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr><name>initSection</name></expr>]</index></name>.<name>containerOffset</name>
									+ <name>initOffset</name></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TVector</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
									<argument><expr>&amp;<name>originalOffsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>

	<comment type="line">// Step 3.</comment>
		
	<comment type="line">// Do the maths to subtract the unrelocated offsets from the current address </comment>
	<comment type="line">// to get the base address.</comment>
	
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>section0Base</name></name> = ((<name>char</name> *) <name><name>relocatedExport</name>-&gt;<name>codePtr</name></name>) - (<name>UInt32</name>) <name><name>originalOffsets</name>.<name>codePtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fragToFix</name>-&gt;<name>section1Base</name></name> = ((<name>char</name> *) <name><name>relocatedExport</name>-&gt;<name>tocPtr</name></name>)  - (<name>UInt32</name>) <name><name>originalOffsets</name>.<name>tocPtr</name></name></expr>;</expr_stmt>
	}</block></then></if>
	
	<comment type="line">// Clean up.</comment>
	
	<if>if <condition>(<expr><name>packedDataSection</name> != <name>nil</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>DisposePtr</name><argument_list>(<argument><expr><name>packedDataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><call><name>MemError</name><argument_list>()</argument_list></call> == <name>noErr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>unpackedDataSection</name> != <name>nil</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>DisposePtr</name><argument_list>(<argument><expr><name>unpackedDataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><call><name>MemError</name><argument_list>()</argument_list></call> == <name>noErr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>GetSectionBaseAddress</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>, <param><decl><type><name>UInt16</name></type> <name>sectionIndex</name></decl></param>)</parameter_list>
	<comment type="line">// This routine returns the base of the instantiated section</comment>
	<comment type="line">// whose index is sectionIndex.  This routine is the evil twin</comment>
	<comment type="line">// of SetupSectionBaseAddresses.  It simply returns the values</comment>
	<comment type="line">// for section 0 and 1 that we derived in SetupSectionBaseAddresses.</comment>
	<comment type="line">// In a real implementation, this routine would call CFM API</comment>
	<comment type="line">// to get this information, and SetupSectionBaseAddresses would</comment>
	<comment type="line">// not exist, but CFM does not export the necessary APIs to</comment>
	<comment type="line">// third parties.</comment>
<block>{
	<decl_stmt><decl><type><name>void</name> *</type><name>result</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFix</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>tag1</name></name> == <name>kPEFTag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<switch>switch <condition>(<expr><name>sectionIndex</name></expr>)</condition> <block>{
		<case>case <expr>0</expr>:
			<expr_stmt><expr><name>result</name> = <name><name>fragToFix</name>-&gt;<name>section0Base</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr>1</expr>:
			<expr_stmt><expr><name>result</name> = <name><name>fragToFix</name>-&gt;<name>section1Base</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><name>result</name> = <name>nil</name></expr>;</expr_stmt>
			<break>break;</break>
	</default>}</block></switch>
	<return>return <expr><name>result</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>FindImportLibrary</name><parameter_list>(<param><decl><type><name>PEFLoaderInfoHeader</name> *</type><name>loaderSection</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>libraryName</name></decl></param>, <param><decl><type><name>PEFImportedLibrary</name> **</type><name>importLibrary</name></decl></param>)</parameter_list>
	<comment type="line">// This routine finds the import library description (PEFImportedLibrary)</comment>
	<comment type="line">// for the import library libraryName in the PEF loader section.</comment>
	<comment type="line">// It sets *importLibrary to the address of the description.</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> 			<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt32</name></type> 				<name>librariesRemaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PEFImportedLibrary</name> 	*</type><name>thisImportLibrary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Boolean</name></type> 			<name>found</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>loaderSection</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>libraryName</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>importLibrary</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="line">// Loop through each import library looking for a matching name.</comment>
	
	<comment type="line">// Initialise thisImportLibrary to point to the byte after the</comment>
	<comment type="line">// end of the loader section's header.</comment>
	
	<expr_stmt><expr><name>thisImportLibrary</name> = <call>(<name>PEFImportedLibrary</name> *) <argument_list>(<argument><expr><name>loaderSection</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>librariesRemaining</name> = <name><name>loaderSection</name>-&gt;<name>importedLibraryCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>found</name> = <name>false</name></expr>;</expr_stmt>
	<while>while <condition>( <expr><name>librariesRemaining</name> &gt; 0 &amp;&amp; ! <name>found</name></expr> )</condition> <block>{
		<comment type="line">// PEF defines that import library names will have</comment>
		<comment type="line">// a null terminator, so we can just use strcmp.</comment>
		<expr_stmt><expr><name>found</name> = (<call><name>strcmp</name><argument_list>( <argument><expr><name>libraryName</name></expr></argument>,
						<argument><expr>((<name>char</name> *)<name>loaderSection</name>)
						+ <name><name>loaderSection</name>-&gt;<name>loaderStringsOffset</name></name> 
						+ <name><name>thisImportLibrary</name>-&gt;<name>nameOffset</name></name></expr></argument>)</argument_list></call> == 0)</expr>;</expr_stmt>
		<comment type="line">// *** Remove ANSI strcmp eventually.</comment>
		<if>if <condition>( <expr>! <name>found</name></expr> )</condition><then> <block>{
			<expr_stmt><expr><name>thisImportLibrary</name> += 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>librariesRemaining</name> -= 1</expr>;</expr_stmt>
		}</block></then></if>
	}</block></while>
	
	<if>if <condition>(<expr><name>found</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>importLibrary</name> = <name>thisImportLibrary</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr>*<name>importLibrary</name> = <name>nil</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>err</name> = <name>cfragNoLibraryErr</name></expr>;</expr_stmt>
	}</block></else></if>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>LookupSymbol</name><parameter_list>(<param><decl><type><name>CFMLateImportLookupProc</name></type> <name>lookup</name></decl></param>, <param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>,
							<param><decl><type><name>PEFLoaderInfoHeader</name> *</type><name>loaderSection</name></decl></param>,
							<param><decl><type><name>UInt32</name></type> <name>symbolIndex</name></decl></param>,
							<param><decl><type><name>UInt32</name> *</type><name>symbolValue</name></decl></param>)</parameter_list>
	<comment type="line">// This routine is used to look up a symbol during relocation.</comment>
	<comment type="line">// "lookup" is a client callback and refCon is its argument.</comment>
	<comment type="line">// Typically refCon is the CFM connection to the library that is</comment>
	<comment type="line">// substituting for the weak linked library.  loaderSection</comment>
	<comment type="line">// is a pointer to the loader section of the fragment to fix up.</comment>
	<comment type="line">// symbolIndex is the index of the imported symbol in the loader section.</comment>
	<comment type="line">// The routine sets the word pointed to by symbolValue to the</comment>
	<comment type="line">// value of the symbol.</comment>
	<comment type="line">//</comment>
	<comment type="line">// The routine works by using symbolIndex to index into the imported</comment>
	<comment type="line">// symbol table to find the offset of the symbol's name in the string</comment>
	<comment type="line">// table.  It then looks up the symbol by calling the client's "lookup"</comment>
	<comment type="line">// function and passes the resulting symbol address back in symbolValue.</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> 			<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt32</name> 				*</type><name>importSymbolTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt32</name></type> 				<name>symbolStringOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Boolean</name></type> 			<name>symbolIsWeak</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFragSymbolClass</name></type> 	<name>symbolClass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 				*</type><name>symbolStringAddress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Str255</name></type> 				<name>symbolString</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>lookup</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>loaderSection</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symbolIndex</name> &lt; <name><name>loaderSection</name>-&gt;<name>totalImportedSymbolCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symbolValue</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="line">// Find the base of the imported symbol table.</comment>
	
	<expr_stmt><expr><name>importSymbolTable</name> = <call>(<name>UInt32</name> *)<argument_list>(<argument><expr>(<call>(<name>char</name> *)<argument_list>(<argument><expr><name>loaderSection</name> + 1</expr></argument>)</argument_list></call>) + (<name><name>loaderSection</name>-&gt;<name>importedLibraryCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PEFImportedLibrary</name></expr></argument>)</argument_list></sizeof>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="line">// Grab the appropriate entry out of the table and</comment>
	<comment type="line">// extract the information from that entry.</comment>
	
	<expr_stmt><expr><name>symbolStringOffset</name> = <name><name>importSymbolTable</name><index>[<expr><name>symbolIndex</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>symbolClass</name> = <call><name>PEFImportedSymbolClass</name><argument_list>(<argument><expr><name>symbolStringOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>symbolIsWeak</name> = ((<name>symbolClass</name> &amp; <name>kPEFWeakImportSymMask</name>) != 0)</expr>;</expr_stmt>
	<expr_stmt><expr><name>symbolClass</name> = <name>symbolClass</name> &amp; ~<name>kPEFWeakImportSymMask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>symbolStringOffset</name> = <call><name>PEFImportedSymbolNameOffset</name><argument_list>(<argument><expr><name>symbolStringOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="line">// Find the string for the symbol in the strings table and</comment>
	<comment type="line">// extract it from the table into a Pascal string on the stack.</comment>
	
	<expr_stmt><expr><name>symbolStringAddress</name> = ((<name>char</name> *)<name>loaderSection</name>) + <name><name>loaderSection</name>-&gt;<name>loaderStringsOffset</name></name> + <name>symbolStringOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>symbolString</name><index>[<expr>0</expr>]</index></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>symbolStringAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="line">// *** remove ANSI strlen</comment>
	<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>symbolStringAddress</name></expr></argument>, <argument><expr>&amp;<name><name>symbolString</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>symbolString</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="line">// Look up the symbol in substitute library.  If it fails, return</comment>
	<comment type="line">// a 0 value and check whether the error is fatal (a strong linked</comment>
	<comment type="line">// symbol) or benign (a weak linked symbol).</comment>
	
	<expr_stmt><expr><name>err</name> = <call><name>lookup</name><argument_list>(<argument><expr><name>symbolString</name></expr></argument>, <argument><expr><name>symbolClass</name></expr></argument>, <argument><expr>(<name>void</name> **) <name>symbolValue</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>symbolValue</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>symbolIsWeak</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="line">// The EngineState structure encapsulates all of the persistent state</comment>
<comment type="line">// of the CFM relocation engine virtual machine.  I originally defined</comment>
<comment type="line">// this structure so I could pass the state around between routines</comment>
<comment type="line">// that implement various virtual opcodes, however I later worked</comment>
<comment type="line">// out that the relocation was sufficiently simple that I could put it</comment>
<comment type="line">// in in one routine.  Still, I left the state in this structure in</comment>
<comment type="line">// case I ever need to reverse that decision.  It's also a convenient</comment>
<comment type="line">// instructional design.</comment>

<struct>struct <name>EngineState</name> <block>{
	<decl_stmt><decl><type><name>UInt32</name></type> <name>currentReloc</name></decl>;</decl_stmt>		<comment type="line">// Index of current relocation opcodes</comment>
	<decl_stmt><decl><type><name>UInt32</name></type> <name>terminatingReloc</name></decl>;</decl_stmt>	<comment type="line">// Index of relocation opcodes which terminates relocation</comment>
	<decl_stmt><decl><type><name>UInt32</name> *</type><name>sectionBase</name></decl>;</decl_stmt>		<comment type="line">// Start of the section</comment>
	<decl_stmt><decl><type><name>UInt32</name> *</type><name>relocAddress</name></decl>;</decl_stmt>		<comment type="line">// Address within the section where the relocations are to be performed</comment>
	<decl_stmt><decl><type><name>UInt32</name></type> <name>importIndex</name></decl>;</decl_stmt>			<comment type="line">// Symbol index, which is used to access an imported symbol's address</comment>
	<decl_stmt><decl><type><name>void</name>  *</type><name>sectionC</name></decl>;</decl_stmt>			<comment type="line">// Memory address of an instantiated section within the PEF container; this variable is used by relocation opcodes that relocate section addresses</comment>
	<decl_stmt><decl><type><name>void</name>  *</type><name>sectionD</name></decl>;</decl_stmt>			<comment type="line">// Memory address of an instantiated section within the PEF container; this variable is used by relocation opcodes that relocate section addresses</comment>
}</block>;</struct>
<typedef>typedef <type>struct <name>EngineState</name></type> <name>EngineState</name>;</typedef>

<comment type="line">// Note:</comment>
<comment type="line">// If I ever have to support the repeat opcodes, I'll probably</comment>
<comment type="line">// have to add a repeat counter to EngineState.</comment>

<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>InitEngineState</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>,
								<param><decl><type><name>UInt16</name></type> <name>relocHeaderIndex</name></decl></param>,
								<param><decl><type><name>EngineState</name> *</type><name>state</name></decl></param>)</parameter_list>
	<comment type="line">// This routine initialises the engine state suitably for</comment>
	<comment type="line">// running the relocation opcodes for the section whose</comment>
	<comment type="line">// index is relocHeaderIndex.  relocHeaderIndex is not a</comment>
	<comment type="line">// a section number.  See the comment where it's used below</comment>
	<comment type="line">// for details.  The routine basically fills out all the fields</comment>
	<comment type="line">// in the EngineState structure as described by</comment>
	<comment type="line">// "Mac OS Runtime Architectures".</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PEFLoaderRelocationHeader</name> *</type><name>relocHeader</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFix</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>state</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// This bit is tricky.  relocHeaderIndex is an index into the relocation</comment>
	<comment type="line">// header table, starting at relocSectionCount (which is in the loader</comment>
	<comment type="line">// section header) for the first relocated section and decrementing</comment>
	<comment type="line">// down to 1 for the last relocated section.  I find the relocation</comment>
	<comment type="line">// header by using relocHeaderIndex as a index backwards from the</comment>
	<comment type="line">// start of the relocation opcodes (ie relocInstrOffset).  If you</comment>
	<comment type="line">// look at the diagram of the layout of the container in</comment>
	<comment type="line">// "PEFBinaryFormat.h", you'll see that the relocation opcodes</comment>
	<comment type="line">// immediately follow the relocation headers.</comment>
	<comment type="line">//</comment>
	<comment type="line">// I did this because the alternative (starting at the loader</comment>
	<comment type="line">// header and stepping past the import library table and the</comment>
	<comment type="line">// import symbol table) was a pain.</comment>

	<expr_stmt><expr><name>relocHeader</name> = <call>(<name>PEFLoaderRelocationHeader</name> *) <argument_list>(<argument><expr>((<name>char</name> *) <name><name>fragToFix</name>-&gt;<name>loaderSection</name></name>) + <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocInstrOffset</name></name> - <name>relocHeaderIndex</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>PEFLoaderRelocationHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>relocHeader</name>-&gt;<name>reservedA</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="line">// PEF spec says it must be; we check to try to catch bugs in calculation of relocHeader</comment>
	
	<expr_stmt><expr><name><name>state</name>-&gt;<name>currentReloc</name></name> = <name><name>relocHeader</name>-&gt;<name>firstRelocOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name>-&gt;<name>terminatingReloc</name></name> = <name><name>relocHeader</name>-&gt;<name>firstRelocOffset</name></name> + <name><name>relocHeader</name>-&gt;<name>relocCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name>-&gt;<name>sectionBase</name></name> = (<name>UInt32</name> *) <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr><name><name>relocHeader</name>-&gt;<name>sectionIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name>-&gt;<name>relocAddress</name></name> = <name><name>state</name>-&gt;<name>sectionBase</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name>-&gt;<name>importIndex</name></name> = 0</expr>;</expr_stmt>

	<comment type="line">// From "Mac OS Runtime Architectures":</comment>
	<comment type="line">//</comment>
	<comment type="line">// The sectionC and sectionD variables actually contain the</comment>
	<comment type="line">// memory address of an instantiated section minus the</comment>
	<comment type="line">// default address for that section. The default address for a</comment>
	<comment type="line">// section is contained in the defaultAddress field of the</comment>
	<comment type="line">// section header. However, in almost all cases the default</comment>
	<comment type="line">// address should be 0, so the simplified definition suffices.</comment>
	<comment type="line">// </comment>
	<comment type="line">// In the debug version, we drop into MacsBug if this weird case</comment>
	<comment type="line">// ever executes because it's more likely we made a mistake than</comment>
	<comment type="line">// we encountered a section with a default address.</comment>

	<expr_stmt><expr><name><name>state</name>-&gt;<name>sectionC</name></name> = <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>state</name>-&gt;<name>sectionC</name></name> != <name>nil</name></expr>)</condition><then> <block>{
		<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
			<if>if <condition>(<expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr>0</expr>]</index></name>.<name>defaultAddress</name> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pInitEngineState: Executing weird case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr>(<name>char</name> *) <name><name>state</name>-&gt;<name>sectionC</name></name> -= <name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr>0</expr>]</index></name>.<name>defaultAddress</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name><name>state</name>-&gt;<name>sectionD</name></name> = <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>state</name>-&gt;<name>sectionD</name></name> != <name>nil</name></expr>)</condition><then> <block>{
		<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
			<if>if <condition>(<expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr>1</expr>]</index></name>.<name>defaultAddress</name> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pInitEngineState: Executing weird case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
		<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr>(<name>char</name> *) <name><name>state</name>-&gt;<name>sectionD</name></name> -= <name><name>fragToFix</name>-&gt;<name>sectionHeaders</name><index>[<expr>1</expr>]</index></name>.<name>defaultAddress</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>state</name>-&gt;<name>relocAddress</name></name> == <name>nil</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err</name> = <name>cfragFragmentUsageErr</name></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="line">// kPEFRelocBasicOpcodes is a table that maps the top 7 bits of the opcode</comment>
<comment type="line">// to a fundamental action.  It's contents are defined for me in "PEFBinaryFormat.h",</comment>
<comment type="line">// which is really convenient.</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>UInt8</name></type> <name><name>kPEFRelocBasicOpcodes</name><index>[<expr><name>kPEFRelocBasicOpcodeRange</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>PEFMaskedBasicOpcodes</name></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>OSStatus</name></type> <name>RunRelocationEngine</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FragToFixInfo</name> *</type><name>fragToFix</name></decl></param>, 
										<param><decl><type><name>PEFImportedLibrary</name>  *</type><name>importLibrary</name></decl></param>, 
										<param><decl><type><name>CFMLateImportLookupProc</name></type> <name>lookup</name></decl></param>, <param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>)</parameter_list>
	<comment type="line">// This is where the rubber really hits the.  Given a fully</comment>
	<comment type="line">// populated fragToFix structure, the import library description</comment>
	<comment type="line">// of the weak imported library we're resolving, and a connection</comment>
	<comment type="line">// to the library we're going to substitute it, re-execute the</comment>
	<comment type="line">// relocation instructions (CFM has already executed them once)</comment>
	<comment type="line">// but only *do* instructions (ie store the change to the data section)</comment>
	<comment type="line">// that CFM skipped because the weak symbols were missing.</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> 	<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EngineState</name></type>	<name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt16</name></type> 		<name>sectionsLeftToRelocate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt32</name></type> 		<name>totalRelocs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt16</name>		*</type><name>relocInstrTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UInt16</name></type> 		<name>opCode</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFix</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>containerHeader</name>.<name>tag1</name></name> == <name>kPEFTag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>sectionHeaders</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>section0Base</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="line">// Technically, having a nil for these two is not a problem, ...</comment>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>section1Base</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="line">// but in practise it a wildly deviant case and we should know about it.</comment>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>importLibrary</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>lookup</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Before entering the loop, work out some information in advance.</comment>

	<comment type="line">// totalRelocs is only used for debugging, to make sure our</comment>
	<comment type="line">// relocation PC (state.currentReloc) doesn't run wild.</comment>
	
	<expr_stmt><expr><name>totalRelocs</name> = (<name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>loaderStringsOffset</name></name> - <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocInstrOffset</name></name>) / <sizeof>sizeof<argument_list>(<argument><expr><name>UInt16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	
	<comment type="line">// relocInstrTable is the base address of the table of relocation</comment>
	<comment type="line">// instructions in the fragment to fix.</comment>
	
	<expr_stmt><expr><name>relocInstrTable</name> = <call>(<name>UInt16</name> *)<argument_list>(<argument><expr>(<name>char</name> *) <name><name>fragToFix</name>-&gt;<name>loaderSection</name></name> + <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocInstrOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="line">// sectionsLeftToRelocate is the loop counter for the outer loop.</comment>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocSectionCount</name></name> &lt;= 0x0FFFF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sectionsLeftToRelocate</name> = <name><name>fragToFix</name>-&gt;<name>loaderSection</name>-&gt;<name>relocSectionCount</name></name></expr>;</expr_stmt>

	<comment type="line">// Now let's run the relocation engine.  We run it once per</comment>
	<comment type="line">// section in the table.  Each time around, we init the engine</comment>
	<comment type="line">// and then loop again, this time executing individual opcodes.</comment>
	<comment type="line">// The opcode loop terminates when the relocation PC</comment>
	<comment type="line">// (state.currentReloc) hits the final opcode (state.terminatingReloc).</comment>
	
	<comment type="line">// Note:</comment>
	<comment type="line">// One design decision I made was to totally re-init the engine state</comment>
	<comment type="line">// for each section.  The CFM spec is unclear as to whether you're supposed</comment>
	<comment type="line">// to totally re-init the engine state, or just re-init the section-specific</comment>
	<comment type="line">// state (ie currentReloc, terminatingReloc, and relocAddress).  I hope this</comment>
	<comment type="line">// is correct, but it's hard to test without having a fragment with multiple</comment>
	<comment type="line">// relocated sections, which is difficult to create.</comment>
	
	<comment type="line">// How do I decide which opcodes should be effective (ie make changes to</comment>
	<comment type="line">// the section being relocated) and which opcodes should just be executed</comment>
	<comment type="line">// for their side effects (ie updated state.relocAddress or state.importIndex)?</comment>
	<comment type="line">// The answer is both simple and subtle.  Opcodes whose actions are dependent</comment>
	<comment type="line">// on a symbol that was in the weak linked library are effective, those that</comment>
	<comment type="line">// an independent of those symbols are not.  The only opcodes that use</comment>
	<comment type="line">// symbolic values are kPEFRelocImportRun and kPEFRelocSmByImport, and</comment>
	<comment type="line">// these are only if the symbol is in the weak linked library.</comment>
	<comment type="line">// All other cases are executed for their side effects only.</comment>
	<comment type="line">//</comment>
	<comment type="line">// How do I determine if a symbol is in the weak linked library?</comment>
	<comment type="line">// Well I know the symbol's index and I know the lower bound and count</comment>
	<comment type="line">// of the symbols in the weak linked library, so I just do a simple</comment>
	<comment type="line">// bounds test, ie </comment>
	<comment type="line">//</comment>
	<comment type="line">//   firstImportedSymbol &lt;= importIndex &lt; firstImportedSymbol + importedSymbolCount</comment>

	<comment type="line">// From this code, it's relatively easy to see which relocation opcodes</comment>
	<comment type="line">// aren't implemented.  If you ever encounter one, you'll find yourself</comment>
	<comment type="line">// in MacsBug with a message telling you which opcode was found.  The</comment>
	<comment type="line">// two big groups of opcodes I skipped were the large format opcodes</comment>
	<comment type="line">// and the repeating opcodes.  I skipped them because:</comment>
	<comment type="line">//</comment>
	<comment type="line">// a) I haven't got a way to generate them in a PEF container that I can </comment>
	<comment type="line">//    test against. Without that, there's no way I could be assured that</comment>
	<comment type="line">//    the code worked.</comment>
	<comment type="line">//</comment>
	<comment type="line">// b) I'm lazy.</comment>

	<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
	<while>while <condition>( <expr><name>sectionsLeftToRelocate</name> &gt; 0</expr> )</condition> <block>{
		<expr_stmt><expr><name>err</name> = <call><name>InitEngineState</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr><name>sectionsLeftToRelocate</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
			<goto>goto <name>leaveNow</name>;</goto>
		}</block></then></if>
		
		<while>while <condition>( <expr><name><name>state</name>.<name>currentReloc</name></name> != <name><name>state</name>.<name>terminatingReloc</name></name></expr> )</condition> <block>{
			
			<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>( <argument><expr><name><name>state</name>.<name>currentReloc</name></name> &lt; <name>totalRelocs</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>opCode</name> = <name><name>relocInstrTable</name><index>[<expr><name><name>state</name>.<name>currentReloc</name></name></expr>]</index></name></expr>;</expr_stmt>
			<switch>switch <condition>( <expr><call><name>PEFRelocBasicOpcode</name><argument_list>(<argument><expr><name>opCode</name></expr></argument>)</argument_list></call></expr> )</condition> <block>{
				<case>case <expr><name>kPEFRelocBySectDWithSkip</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt16</name></type> <name>skipCount</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>UInt16</name></type> <name>relocCount</name></decl>;</decl_stmt>
						
						<expr_stmt><expr><name>skipCount</name> = ((<name>opCode</name> &gt;&gt; 6) &amp; 0x00FF)</expr>;</expr_stmt>
						<expr_stmt><expr><name>relocCount</name> = (<name>opCode</name> &amp; 0x003F)</expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += <name>skipCount</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += <name>relocCount</name></expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocBySectC</name></expr>:
				</case><case>case <expr><name>kPEFRelocBySectD</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt16</name></type> <name>runLength</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>runLength</name> = (<name>opCode</name> &amp; 0x01FF) + 1</expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += <name>runLength</name></expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocTVector12</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt16</name></type> <name>runLength</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>runLength</name> = (<name>opCode</name> &amp; 0x01FF) + 1</expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += (<name>runLength</name> * 3)</expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocTVector8</name></expr>:
				</case><case>case <expr><name>kPEFRelocVTable8</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt16</name></type> <name>runLength</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>runLength</name> = (<name>opCode</name> &amp; 0x01FF) + 1</expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += (<name>runLength</name> * 2)</expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocImportRun</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt32</name></type> <name>symbolValue</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>UInt16</name></type> <name>runLength</name></decl>;</decl_stmt>
						
						<expr_stmt><expr><name>runLength</name> = (<name>opCode</name> &amp; 0x01FF) + 1</expr>;</expr_stmt>
						<while>while <condition>(<expr><name>runLength</name> &gt; 0</expr>)</condition> <block>{
							<if>if <condition>( <expr><name><name>state</name>.<name>importIndex</name></name> &gt;= <name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> &amp;&amp; <name><name>state</name>.<name>importIndex</name></name> &lt; (<name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> + <name><name>importLibrary</name>-&gt;<name>importedSymbolCount</name></name>)</expr> )</condition><then> <block>{
								<expr_stmt><expr><name>err</name> = <call><name>LookupSymbol</name><argument_list>(<argument><expr><name>lookup</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>, <argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name></expr></argument>, <argument><expr><name><name>state</name>.<name>importIndex</name></name></expr></argument>, <argument><expr>&amp;<name>symbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
									<goto>goto <name>leaveNow</name>;</goto>
								}</block></then></if>
								<expr_stmt><expr>*(<name><name>state</name>.<name>relocAddress</name></name>) += <name>symbolValue</name></expr>;</expr_stmt>
							}</block></then></if>
							<expr_stmt><expr><name><name>state</name>.<name>importIndex</name></name> += 1</expr>;</expr_stmt>
							<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += 1</expr>;</expr_stmt>
							<expr_stmt><expr><name>runLength</name> -= 1</expr>;</expr_stmt>
						}</block></while>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocSmByImport</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt32</name></type> <name>symbolValue</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>UInt32</name></type> <name>index</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>index</name> = (<name>opCode</name> &amp; 0x01FF)</expr>;</expr_stmt>
						<if>if <condition>( <expr><name>index</name> &gt;= <name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> &amp;&amp; <name>index</name> &lt; (<name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> + <name><name>importLibrary</name>-&gt;<name>importedSymbolCount</name></name>)</expr> )</condition><then> <block>{
							<expr_stmt><expr><name>err</name> = <call><name>LookupSymbol</name><argument_list>(<argument><expr><name>lookup</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>, <argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr>&amp;<name>symbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
								<goto>goto <name>leaveNow</name>;</goto>
							}</block></then></if>
							<expr_stmt><expr>*(<name><name>state</name>.<name>relocAddress</name></name>) += <name>symbolValue</name></expr>;</expr_stmt>
						}</block></then></if>
						<expr_stmt><expr><name><name>state</name>.<name>importIndex</name></name> = <name>index</name> + 1</expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += 1</expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocSmSetSectC</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt32</name></type> <name>index</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>index</name> = (<name>opCode</name> &amp; 0x01FF)</expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>sectionC</name></name> = <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>state</name>.<name>sectionC</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocSmSetSectD</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt32</name></type> <name>index</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>index</name> = (<name>opCode</name> &amp; 0x01FF)</expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>sectionD</name></name> = <call><name>GetSectionBaseAddress</name><argument_list>(<argument><expr><name>fragToFix</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name><name>state</name>.<name>sectionD</name></name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocSmBySection</name></expr>:
					<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += 1</expr>;</expr_stmt>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocIncrPosition</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt16</name></type> <name>offset</name></decl>;</decl_stmt>
						
						<expr_stmt><expr><name>offset</name> = (<name>opCode</name> &amp; 0x0FFF) + 1</expr>;</expr_stmt>
						<expr_stmt><expr>((<name>char</name> *) <name><name>state</name>.<name>relocAddress</name></name>) += <name>offset</name></expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocSmRepeat</name></expr>:
					<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
						<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pRunRelocationEngine: kPEFRelocSmRepeat not yet implemented"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name>err</name> = <name>unimpErr</name></expr>;</expr_stmt>
					<goto>goto <name>leaveNow</name>;</goto>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocSetPosition</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt32</name></type> <name>offset</name></decl>;</decl_stmt>

						<comment type="line">// Lot's of folks have tried various interpretations of the description of </comment>
						<comment type="line">// this opCode in "Mac OS Runtime Architectures" (which states "This instruction </comment>
						<comment type="line">// sets relocAddress to the address of the section offset offset."  *smile*).</comment>
						<comment type="line">// I eventually dug into the CFM source code to find my interpretation, which </comment>
						<comment type="line">// I believe is correct.  The key point is tht the offset is relative to </comment>
						<comment type="line">// the start of the section for which these relocations are being performed.</comment>
						
						<comment type="line">// Skip to next reloc word, which is the second chunk of the offset.</comment>
						
						<expr_stmt><expr><name><name>state</name>.<name>currentReloc</name></name> += 1</expr>;</expr_stmt>
						
						<comment type="line">// Extract offset based on the most significant 10 bits in opCode and </comment>
						<comment type="line">// the next significant 16 bits in the next reloc word.</comment>
						
						<expr_stmt><expr><name>offset</name> = <call><name>PEFRelocSetPosFullOffset</name><argument_list>(<argument><expr><name>opCode</name></expr></argument>, <argument><expr><name><name>relocInstrTable</name><index>[<expr><name><name>state</name>.<name>currentReloc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> = <call>(<name>UInt32</name> *) <argument_list>( <argument><expr>((<name>char</name> *) <name><name>state</name>.<name>sectionBase</name></name>) + <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocLgByImport</name></expr>:
					<block>{
						<decl_stmt><decl><type><name>UInt32</name></type> <name>symbolValue</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>UInt32</name></type> <name>index</name></decl>;</decl_stmt>

						<comment type="line">// Get the 26 bit symbol index from the current and next reloc words.</comment>
						
						<expr_stmt><expr><name><name>state</name>.<name>currentReloc</name></name> += 1</expr>;</expr_stmt>
						<expr_stmt><expr><name>index</name> = <call><name>PEFRelocLgByImportFullIndex</name><argument_list>(<argument><expr><name>opCode</name></expr></argument>, <argument><expr><name><name>relocInstrTable</name><index>[<expr><name><name>state</name>.<name>currentReloc</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						
						<if>if <condition>( <expr><name>index</name> &gt;= <name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> &amp;&amp; <name>index</name> &lt; (<name><name>importLibrary</name>-&gt;<name>firstImportedSymbol</name></name> + <name><name>importLibrary</name>-&gt;<name>importedSymbolCount</name></name>)</expr> )</condition><then> <block>{
							<expr_stmt><expr><name>err</name> = <call><name>LookupSymbol</name><argument_list>(<argument><expr><name>lookup</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>, <argument><expr><name><name>fragToFix</name>-&gt;<name>loaderSection</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr>&amp;<name>symbolValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if>if <condition>(<expr><name>err</name> != <name>noErr</name></expr>)</condition><then> <block>{
								<goto>goto <name>leaveNow</name>;</goto>
							}</block></then></if>
							<expr_stmt><expr>*(<name><name>state</name>.<name>relocAddress</name></name>) += <name>symbolValue</name></expr>;</expr_stmt>
						}</block></then></if>
						<expr_stmt><expr><name><name>state</name>.<name>importIndex</name></name> = <name>index</name> + 1</expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name>.<name>relocAddress</name></name> += 1</expr>;</expr_stmt>
					}</block>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocLgRepeat</name></expr>:
					<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
						<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pRunRelocationEngine: kPEFRelocLgRepeat not yet implemented"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name>err</name> = <name>unimpErr</name></expr>;</expr_stmt>
					<goto>goto <name>leaveNow</name>;</goto>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocLgSetOrBySection</name></expr>:
					<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MORE_DEBUG</name></expr></cpp:if>
						<expr_stmt><expr><call><name>DebugStr</name><argument_list>(<argument><expr>"\pRunRelocationEngine: kPEFRelocLgSetOrBySection not yet implemented"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name>err</name> = <name>unimpErr</name></expr>;</expr_stmt>
					<goto>goto <name>leaveNow</name>;</goto>
					<break>break;</break>
				</case><case>case <expr><name>kPEFRelocUndefinedOpcode</name></expr>:
					<expr_stmt><expr><name>err</name> = <name>cfragFragmentCorruptErr</name></expr>;</expr_stmt>
					<goto>goto <name>leaveNow</name>;</goto>
					<break>break;</break>
				</case><default>default:
					<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>err</name> = <name>cfragFragmentCorruptErr</name></expr>;</expr_stmt>
					<goto>goto <name>leaveNow</name>;</goto>
					<break>break;</break>
			</default>}</block></switch>
			<expr_stmt><expr><name><name>state</name>.<name>currentReloc</name></name> += 1</expr>;</expr_stmt>
		}</block></while>
		
		<expr_stmt><expr><name>sectionsLeftToRelocate</name> -= 1</expr>;</expr_stmt>
	}</block></while>

<label><name>leaveNow</name>:</label>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>extern</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>CFMLateImportCore</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CFragSystem7DiskFlatLocator</name> *</type><name>fragToFixLocator</name></decl></param>,
										<param><decl><type><name>CFragConnectionID</name></type> <name>fragToFixConnID</name></decl></param>,
										<param><decl><type><name>CFragInitFunction</name></type> <name>fragToFixInitRoutine</name></decl></param>,
										<param><decl><type><name>ConstStr255Param</name></type> <name>weakLinkedLibraryName</name></decl></param>,
										<param><decl><type><name>CFMLateImportLookupProc</name></type> <name>lookup</name></decl></param>,
										<param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>)</parameter_list>
	<comment type="line">// See comments in interface part.</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OSStatus</name></type> <name>junk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FragToFixInfo</name></type> <name>fragToFix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PEFImportedLibrary</name> *</type><name>importLibrary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>weakLinkedLibraryNameCString</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFixLocator</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFixConnID</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>fragToFixInitRoutine</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>weakLinkedLibraryName</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>lookup</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	
	<comment type="line">// Fill out the bits of fragToFix which are passed in</comment>
	<comment type="line">// by the client.</comment>
	
	<expr_stmt><expr><call><name>MoreBlockZero</name><argument_list>(<argument><expr>&amp;<name>fragToFix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fragToFix</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragToFix</name>.<name>locator</name></name> = *<name>fragToFixLocator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragToFix</name>.<name>connID</name></name>  = <name>fragToFixConnID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fragToFix</name>.<name>initRoutine</name></name> = <name>fragToFixInitRoutine</name></expr>;</expr_stmt>
	
	<comment type="line">// Make a C string from weakLinkedLibraryName.</comment>
	
	<expr_stmt><expr><call><name>BlockMoveData</name><argument_list>(<argument><expr><name>weakLinkedLibraryName</name> + 1</expr></argument>, <argument><expr><name>weakLinkedLibraryNameCString</name></expr></argument>, <argument><expr><name><name>weakLinkedLibraryName</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>weakLinkedLibraryNameCString</name><index>[<expr><name><name>weakLinkedLibraryName</name><index>[<expr>0</expr>]</index></name></expr>]</index></name> = 0</expr>;</expr_stmt>

	<comment type="line">// Get the basic information from the fragment.</comment>
	<comment type="line">// Fills out the containerHeader, sectionHeaders, loaderSection and fileRef fields</comment>
	<comment type="line">// of fragToFix.</comment>
	
	<expr_stmt><expr><name>err</name> = <call><name>ReadContainerBasics</name><argument_list>(<argument><expr>&amp;<name>fragToFix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Set up the base address fields in fragToFix (ie section0Base and section1Base)</comment>
	<comment type="line">// by looking up our init routine (fragToFix.initRoutine) and subtracting</comment>
	<comment type="line">// away the section offsets (which we get from the disk copy of the section)</comment>
	<comment type="line">// to derive the bases of the sections themselves.</comment>
	
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err</name> = <call><name>SetupSectionBaseAddresses</name><argument_list>(<argument><expr>&amp;<name>fragToFix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	
	<comment type="line">// Look inside the loader section for the import library description</comment>
	<comment type="line">// of weakLinkedLibraryName.  We need this to know the range of symbol</comment>
	<comment type="line">// indexes we're going to fix up.</comment>
	
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err</name> = <call><name>FindImportLibrary</name><argument_list>(<argument><expr><name><name>fragToFix</name>.<name>loaderSection</name></name></expr></argument>, <argument><expr><name>weakLinkedLibraryNameCString</name></expr></argument>, <argument><expr>&amp;<name>importLibrary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	
	<comment type="line">// Do a quick check to ensure that the library was actually imported weak.</comment>
	<comment type="line">// If it wasn't, it doesn't make much sense to resolve its weak imports</comment>
	<comment type="line">// later on.  Resolving them again is likely to be bad.</comment>
	
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name><name>importLibrary</name>-&gt;<name>options</name></name> &amp; <name>kPEFWeakImportLibMask</name>) == 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err</name> = <name>cfragFragmentUsageErr</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	
	<comment type="line">// Now run the main relocation engine.</comment>
	
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err</name> = <call><name>RunRelocationEngine</name><argument_list>(<argument><expr>&amp;<name>fragToFix</name></expr></argument>, <argument><expr><name>importLibrary</name></expr></argument>, <argument><expr><name>lookup</name></expr></argument>, <argument><expr><name>refCon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	
	<comment type="line">// Clean up.</comment>
	
	<if>if <condition>(<expr><name><name>fragToFix</name>.<name>disposeSectionPointers</name></name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name><name>fragToFix</name>.<name>fileRef</name></name> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>junk</name> = <call><name>FSClose</name><argument_list>(<argument><expr><name><name>fragToFix</name>.<name>fileRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>junk</name> == <name>noErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>fragToFix</name>.<name>loaderSection</name></name> != <name>nil</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>DisposePtr</name><argument_list>( <argument><expr>(<name>Ptr</name>) <name><name>fragToFix</name>.<name>loaderSection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><call><name>MemError</name><argument_list>()</argument_list></call> == <name>noErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr><name><name>fragToFix</name>.<name>sectionHeaders</name></name> != <name>nil</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>DisposePtr</name><argument_list>( <argument><expr>(<name>Ptr</name>) <name><name>fragToFix</name>.<name>sectionHeaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><call><name>MemError</name><argument_list>()</argument_list></call> == <name>noErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>FragmentLookup</name><parameter_list>(<param><decl><type><name>ConstStr255Param</name></type> <name>symName</name></decl></param>, <param><decl><type><name>CFragSymbolClass</name></type> <name>symClass</name></decl></param>,
									<param><decl><type><name>void</name> **</type><name>symAddr</name></decl></param>, <param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>)</parameter_list>
	<comment type="line">// This is the CFMLateImportLookupProc callback used when </comment>
	<comment type="line">// late importing from a CFM shared library.</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> <name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFragConnectionID</name></type> <name>connIDToImport</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFragSymbolClass</name></type>  <name>foundSymClass</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symName</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symAddr</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>refCon</name>  != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>connIDToImport</name> = (<name>CFragConnectionID</name>) <name>refCon</name></expr>;</expr_stmt>
	
	<comment type="line">// Shame there's no way to validate that connIDToImport is valid.</comment>

	<expr_stmt><expr><name>err</name> = <call><name>FindSymbol</name><argument_list>(<argument><expr><name>connIDToImport</name></expr></argument>, <argument><expr><name>symName</name></expr></argument>, <argument><expr>(<name>Ptr</name> *) <name>symAddr</name></expr></argument>, <argument><expr>&amp;<name>foundSymClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<comment type="line">// If the symbol isn't of the right class, we act like we didn't </comment>
		<comment type="line">// find it, but also assert in the debug build because weird things </comment>
		<comment type="line">// are afoot.</comment>
		<if>if <condition>(<expr><name>foundSymClass</name> != <name>symClass</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>symAddr</name> = <name>nil</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>err</name> = <name>cfragNoSymbolErr</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>extern</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>CFMLateImportLibrary</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CFragSystem7DiskFlatLocator</name> *</type><name>fragToFixLocator</name></decl></param>,
										<param><decl><type><name>CFragConnectionID</name></type> <name>fragToFixConnID</name></decl></param>,
										<param><decl><type><name>CFragInitFunction</name></type> <name>fragToFixInitRoutine</name></decl></param>,
										<param><decl><type><name>ConstStr255Param</name></type> <name>weakLinkedLibraryName</name></decl></param>,
										<param><decl><type><name>CFragConnectionID</name></type> <name>connIDToImport</name></decl></param>)</parameter_list>
	<comment type="line">// See comments in interface part.</comment>
<block>{
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>connIDToImport</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>CFMLateImportCore</name><argument_list>(<argument><expr><name>fragToFixLocator</name></expr></argument>, <argument><expr><name>fragToFixConnID</name></expr></argument>, <argument><expr><name>fragToFixInitRoutine</name></expr></argument>,
										<argument><expr><name>weakLinkedLibraryName</name></expr></argument>, <argument><expr><name>FragmentLookup</name></expr></argument>, <argument><expr><name>connIDToImport</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>BundleLookup</name><parameter_list>(<param><decl><type><name>ConstStr255Param</name></type> <name>symName</name></decl></param>, <param><decl><type><name>CFragSymbolClass</name></type> <name>symClass</name></decl></param>,
									<param><decl><type><name>void</name> **</type><name>symAddr</name></decl></param>, <param><decl><type><name>void</name> *</type><name>refCon</name></decl></param>)</parameter_list>
	<comment type="line">// This is the CFMLateImportLookupProc callback used when </comment>
	<comment type="line">// late importing from a CFBundle.</comment>
<block>{
	<decl_stmt><decl><type><name>OSStatus</name></type> 	<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFBundleRef</name></type> <name>bundleToImport</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CFStringRef</name></type> <name>symNameStr</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symName</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>symAddr</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>refCon</name>  != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>symNameStr</name> = <name>nil</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>bundleToImport</name> = (<name>CFBundleRef</name>) <name>refCon</name></expr>;</expr_stmt>
	
	<comment type="line">// Shame there's no way to validate that bundleToImport is really a bundle.</comment>
	
	<comment type="line">// We can only find function pointers because CFBundleGetFunctionPointerForName </comment>
	<comment type="line">// only works for function pointers.  So if the client is asking for something </comment>
	<comment type="line">// other than a function pointer (ie TVector symbol) then we don't even true.</comment>
	<comment type="line">// Also assert in the debug build because this shows a certain lack of </comment>
	<comment type="line">// understanding on the part of the client.</comment>
	<comment type="line">//</comment>
	<comment type="line">// CF is being revise to support accessing data symbols using a new API</comment>
	<comment type="line">// (currently this is available to Apple internal developers as </comment>
	<comment type="line">// CFBundleGetDataPointerForName).  When the new API is available in a </comment>
	<comment type="line">// public header file I should revise this code to lift this restriction.</comment>
	
	<expr_stmt><expr><name>err</name> = <name>noErr</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>symClass</name> != <name>kTVectorCFragSymbol</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>err</name> = <name>cfragNoSymbolErr</name></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>symNameStr</name> = <call><name>CFStringCreateWithPascalString</name><argument_list>(<argument><expr><name>kCFAllocatorSystemDefault</name></expr></argument>, 
													<argument><expr><name>symName</name></expr></argument>, <argument><expr><name>kCFStringEncodingMacRoman</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>symNameStr</name> == <name>nil</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err</name> = <name>coreFoundationUnknownErr</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>err</name> == <name>noErr</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>symAddr</name> = <call><name>CFBundleGetFunctionPointerForName</name><argument_list>(<argument><expr><name>bundleToImport</name></expr></argument>, <argument><expr><name>symNameStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>symAddr</name> == <name>nil</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err</name> = <name>cfragNoSymbolErr</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>
	<if>if <condition>(<expr><name>symNameStr</name> != <name>nil</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>symNameStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>extern</specifier> <name>pascal</name> <name>OSStatus</name></type> <name>CFMLateImportBundle</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CFragSystem7DiskFlatLocator</name> *</type><name>fragToFixLocator</name></decl></param>,
										<param><decl><type><name>CFragConnectionID</name></type> <name>fragToFixConnID</name></decl></param>,
										<param><decl><type><name>CFragInitFunction</name></type> <name>fragToFixInitRoutine</name></decl></param>,
										<param><decl><type><name>ConstStr255Param</name></type> <name>weakLinkedLibraryName</name></decl></param>,
										<param><decl><type><name>CFBundleRef</name></type> <name>bundleToImport</name></decl></param>)</parameter_list>
	<comment type="line">// See comments in interface part.</comment>
<block>{
	<expr_stmt><expr><call><name>MoreAssertQ</name><argument_list>(<argument><expr><name>bundleToImport</name> != <name>nil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>CFMLateImportCore</name><argument_list>(<argument><expr><name>fragToFixLocator</name></expr></argument>, <argument><expr><name>fragToFixConnID</name></expr></argument>, <argument><expr><name>fragToFixInitRoutine</name></expr></argument>,
										<argument><expr><name>weakLinkedLibraryName</name></expr></argument>, <argument><expr><name>BundleLookup</name></expr></argument>, <argument><expr><name>bundleToImport</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
